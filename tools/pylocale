#!/usr/bin/env python3

import os
import subprocess
import sys
from typing import List
from pathlib import Path


# ----------------------------------------------------------------------------
# GLOBAL SETTINGS
# ----------------------------------------------------------------------------

APP_NAME: str = "pneo"
APP_ROOT_PACKAGE: str = APP_NAME
LOCALE_DOMAIN: str = APP_NAME

# full relative paths to the locale files.
VALID_LOCALES: List[str] = ['pt_BR', 'en_US']
LOCALE_DIR: str = os.path.join('src', APP_ROOT_PACKAGE, 'locale')
LOCALE_POT: str = os.path.join(LOCALE_DIR, LOCALE_DOMAIN + '.pot')


# ----------------------------------------------------------------------
# OS PROCESS HELPERS
# ----------------------------------------------------------------------

def run_command(command_args: List[str], silent: bool = False) -> bool:
    """
    Runs any shell command using the subprocess module, ensuring cross-platform compatibility.

    Args:
        command_args (List[str]): A list of strings representing the command and its arguments.

        silent (bool): If True, suppresses output unless an error occurs.

    Returns:
        bool: True if the command executed successfully, False otherwise.
    """
    if not silent:
        print(f"--- Running:  {' '.join(command_args)}")

    try:
        # Use subprocess.run to execute the command.
        # check=True raises an exception for non-zero return codes (errors).
        # Using a list for the command ensures cross-platform compatibility.
        result = subprocess.run(
            command_args,
            check=True,
            capture_output=True,
            text=True
        )

        if not silent:
            # Print the standard output and error output from the command
            if result.stdout:
                print(result.stdout.strip())
            if result.stderr:
                print(result.stderr.strip(), file=sys.stderr)

        print("\nâœ… Command executed successfully.")
        return True

    except subprocess.CalledProcessError as e:
        print(f"\nâŒ Error running shell command (Exit Code {e.returncode}):", file=sys.stderr)
        if e.stdout:
            print("--- STDOUT (Context) ---", file=sys.stderr)
            print(e.stdout.strip(), file=sys.stderr)
        if e.stderr:
            print("--- STDERR (Details) ---", file=sys.stderr)
            print(e.stderr.strip(), file=sys.stderr)
        return False

    except FileNotFoundError:
        # This occurs if command executable is not found in the system's PATH
        print("\nâŒ Error: The command executable was not found.", file=sys.stderr)
        return False

    except Exception as e:
        print(f"\nâŒ An unexpected error occurred: {e}", file=sys.stderr)
        return False

    finally:
        print("\n" + "="*50 + "\n")


def run_pybabel_command(pybabel_args: List[str], silent: bool = False) -> bool:
    """
    Runs any pybabel command using the subprocess module, ensuring cross-platform compatibility.

    Args:
        pybabel_args (List[str]): A list of strings representing the pybabel command and its arguments,
                                    e.g., ['extract', '-o', 'messages.pot', '.'].
                                    **Do NOT include 'pybabel' itself.**

        silent (bool): If True, suppresses output unless an error occurs.

    Returns:
        bool: True if the command executed successfully, False otherwise.
    """
    # The full command starts with the 'pybabel' executable.
    command = ['pybabel'] + pybabel_args

    return run_command(command, silent)


# ----------------------------------------------------------------------------
# ENTRY-POINT CHECK
# ----------------------------------------------------------------------------

# This module cannot be loaded by another module.
if __name__ != "__main__":
    sys.exit("This module 'pylocale' cannot be loaded by another module.")
# proceeds only if this program was executed as entry-point...

#  Get the current working directory and extract the last part of the path.
current_dir = os.getcwd()
current_dir_name = os.path.basename(current_dir)

# Check if the current directory is not root of project.
if current_dir_name == "tools":
    # Change the current working directory to the parent directory (root of project).
    parent_dir = os.path.join(current_dir, '..')
    os.chdir(parent_dir)
    print(f"âœ… Detected running from **/tools. Changed directory to: {os.getcwd()}\n")


# ----------------------------------------------------------------------
# APP LOCALIZATION / I18N
# ----------------------------------------------------------------------

result_ok: bool = False

# --- Extract English strings â†’ messages.pot
# Equivalent to:  pybabel extract -F babel.cfg -o src/app/locale/messages.pot .
result_ok = run_pybabel_command(['extract', '-F', 'tools/babel.cfg', '-o', LOCALE_POT, '.'])
if not result_ok:
    print("\nðŸš¨ Please ensure **Babel** is installed in your environment (e.g., `pip install Babel`).", file=sys.stderr)
    sys.exit(1)

# Check if the directory structure and any PO file already exist.
en_us_messages_path: str = os.path.join('src', APP_ROOT_PACKAGE, 'locale', 'en_US', 'LC_MESSAGES', LOCALE_DOMAIN + '.po')
if os.path.exists(en_us_messages_path) and os.path.isfile(en_us_messages_path):
    # --- Update the .PO translation files.
    # Equivalent to:  pybabel update -D messages -i src/app/locale/messages.pot -d src/app/locale
    result_ok = run_pybabel_command(['update', '-D', LOCALE_DOMAIN, '-i', LOCALE_POT, '-d', LOCALE_DIR])
    if not result_ok: sys.exit(1)

    # --- Review, edit, and remove translations marked as fuzzy: #, fuzzy
    # Equivalent to:  grep -n -i -H -r --include="*.po" "fuzzy" src/app/locale
    run_command(['grep', '-n', '-i', '-H', '-r', '--include="*.po"', '"fuzzy"', LOCALE_DIR])

    # --- # Merge all translations into unique POT and PO files, before compilation.
    # Equivalent to:  xgettext myapp/locale/myapp.pot libA/locale/libA.pot -o merged/locale/myapp.pot
    input1: str = os.path.join(LOCALE_DIR, LOCALE_DOMAIN + '.pot')
    input2: str = os.path.join(LOCALE_DIR, 'ngne.pot')
    input3: str = os.path.join(LOCALE_DIR, 'click.pot')
    output: str = os.path.join(LOCALE_DIR, 'messages.pot')
    run_command(['xgettext', input1, input2, input3, '-o', output])

    # execute the command `msgcat` for all languages, each in its locale path.
    for idiom in VALID_LOCALES:
        messages_path: str = os.path.join('src', APP_ROOT_PACKAGE, 'locale', idiom, 'LC_MESSAGES')

        # Equivalent to:  msgcat --use-first --sort-output myapp/locale/es/LC_MESSAGES/myapp.po libA/locale/es/LC_MESSAGES/libA.po -o merged/locale/es/LC_MESSAGES/myapp.po
        input1: str = os.path.join(messages_path, LOCALE_DOMAIN + '.po')
        input2: str = os.path.join(messages_path, 'ngne.po')
        input3: str = os.path.join(messages_path, 'click.po')
        output: str = os.path.join(messages_path, 'messages.po')
        run_command(['msgcat', '--use-first', input1, input2, input3, '-o', output])

else:
    # --- Initialize each language catalog â†’ locale/idiom/LC_MESSAGES/messages.po 
    # Equivalent to:  pybabel init -D messages -i src/app/locale/messages.pot -d src/app/locale -l language
    # NOTE: Recommended even if English is source. This allows translators 
    # to correct source English if needed.
    for idiom in VALID_LOCALES:
        result_ok = run_pybabel_command(['init', '-D', LOCALE_DOMAIN, '-i', LOCALE_POT, '-d', LOCALE_DIR, '-l', idiom])
        if not result_ok: sys.exit(1)

# --- Compile .po â†’ .mo
# The gettext runtime system uses binary .mo files, so you must compile the .po files.
# Equivalent to:  pybabel compile -D messages -d src/app/locale
# NOTE: This will fail if 'messages.po' from the previous command doesn't exist.
result_ok = run_pybabel_command(['compile', '-D', 'messages', '-d', LOCALE_DIR])
if not result_ok: sys.exit(1)

# everything ok!
sys.exit(0)
