#!/usr/bin/env python3

import os
import sys
import subprocess
from typing import List


# ----------------------------------------------------------------------------
# GLOBAL SETTINGS
# ----------------------------------------------------------------------------

APP_NAME: str = "pneo"
APP_ROOT_PACKAGE: str = APP_NAME
LOCALE_DOMAIN: str = APP_NAME

# full relative paths to the locale files.
VALID_LOCALES: List[str] = [ 'en_US', 'pt_BR' ]
LOCALE_DIR: str = os.path.join('src', APP_ROOT_PACKAGE, 'locale')
LOCALE_POT: str = os.path.join(LOCALE_DIR, LOCALE_DOMAIN + '.pot')

# libraries to extract messages.
PACK_LIBS: List[str] = [ 'ngne', 'nasa', 'click' ]
PACK_DIR: str = 'packages'


# ----------------------------------------------------------------------
# OS PROCESS HELPERS
# ----------------------------------------------------------------------

def run_command(command_args: List[str], silent: bool = False) -> bool:
    """
    Runs any shell command using the subprocess module, ensuring cross-platform compatibility.

    Args:
        command_args (List[str]): A list of strings representing the command and its arguments.

        silent (bool): If True, suppresses output unless an error occurs.

    Returns:
        bool: True if the command executed successfully, False otherwise.
    """
    if not silent:
        print(f"--- Running:  {' '.join(command_args)}")

    try:
        # Use subprocess.run to execute the command.
        # check=True raises an exception for non-zero return codes (errors).
        # Using a list for the command ensures cross-platform compatibility.
        result = subprocess.run(
            command_args,
            check=True,
            capture_output=True,
            text=True
        )

        if not silent:
            # Print the standard output and error output from the command
            if result.stdout:
                print(result.stdout.strip())
            if result.stderr:
                print(result.stderr.strip(), file=sys.stderr)

        print("\n✅ Command executed successfully.")
        return True

    except subprocess.CalledProcessError as e:
        print(f"\n❌ Error running shell command (Exit Code {e.returncode}):", file=sys.stderr)
        if e.stdout:
            print("--- STDOUT (Context) ---", file=sys.stderr)
            print(e.stdout.strip(), file=sys.stderr)
        if e.stderr:
            print("--- STDERR (Details) ---", file=sys.stderr)
            print(e.stderr.strip(), file=sys.stderr)
        return False

    except FileNotFoundError:
        # This occurs if command executable is not found in the system's PATH
        print("\n❌ Error: The command executable was not found.", file=sys.stderr)
        return False

    except Exception as e:
        print(f"\n❌ An unexpected error occurred: {e}", file=sys.stderr)
        return False

    finally:
        print("\n" + "="*50 + "\n")


def run_pybabel_command(pybabel_args: List[str], silent: bool = False) -> bool:
    """
    Runs any pybabel command using the subprocess module, ensuring cross-platform compatibility.

    Args:
        pybabel_args (List[str]): A list of strings representing the pybabel command and its arguments,
                                    e.g., ['extract', '-o', 'messages.pot', '.'].
                                    **Do NOT include 'pybabel' itself.**

        silent (bool): If True, suppresses output unless an error occurs.

    Returns:
        bool: True if the command executed successfully, False otherwise.
    """
    # The full command starts with the 'pybabel' executable.
    command = ['pybabel'] + pybabel_args

    return run_command(command, silent)


# ----------------------------------------------------------------------------
# ENTRY-POINT CHECK
# ----------------------------------------------------------------------------

# This module cannot be loaded by another module.
if __name__ != "__main__":
    sys.exit("This module 'pylocale' cannot be loaded by another module.")
# proceeds only if this program was executed as entry-point...

#  Get the current working directory and extract the last part of the path.
current_dir = os.getcwd()
current_dir_name = os.path.basename(current_dir)

# Check if the current directory is not root of project.
if current_dir_name == "tools":
    # Change the current working directory to the parent directory (root of project).
    parent_dir = os.path.join(current_dir, '..')
    os.chdir(parent_dir)
    print(f"✅ Detected running from **/tools. Changed directory to: {os.getcwd()}\n")


# ----------------------------------------------------------------------
# APP LOCALIZATION / I18N
# ----------------------------------------------------------------------

result_ok: bool = False

# --- Extract English strings → messages.pot
# Equivalent to:  pybabel extract -F babel.cfg -o src/app/locale/messages.pot .
result_ok = run_pybabel_command(['extract', '-F', 'tools/babel.cfg', '-o', LOCALE_POT, '.'])
if not result_ok:
    print("\n🚨 Please ensure **Babel** is installed in your environment (e.g., `pip install Babel`).", file=sys.stderr)
    sys.exit(1)

# execute the command `pybabel extract` for all libraries, each with its messages file.
for lib in PACK_LIBS:
    lib_pot: str = os.path.join(LOCALE_DIR, lib + '.pot')
    lib_src: str = os.path.join(PACK_DIR, lib)

    # --- Extract from lib package
    result_ok = run_pybabel_command(['extract', '-F', 'tools/babel.cfg', '-o', lib_pot, lib_src])
    if not result_ok: sys.exit(1)


# --- Update the .PO translation files.
# Equivalent to:  pybabel update -D messages -i src/app/locale/messages.pot -d src/app/locale
for domain in [LOCALE_DOMAIN] + PACK_LIBS:
    domain_pot: str = os.path.join(LOCALE_DIR, domain + '.pot')

    # --- Update from lib package
    result_ok = run_pybabel_command(['update', '-D', domain, '-i', domain_pot, '-d', LOCALE_DIR])
    if not result_ok: sys.exit(1)


# --- Review, edit, and remove translations marked as fuzzy: #, fuzzy
# Equivalent to:  grep -n -i -H -r --include="*.po" "fuzzy" src/app/locale
run_command(['grep', '-n', '-i', '-H', '-r', '--include="*.po"', '"fuzzy"', LOCALE_DIR])


# --- # Merge all translations into unique POT and PO files, before compilation.
# Equivalent to:  xgettext myapp/locale/myapp.pot libA/locale/libA.pot -o merged/locale/myapp.pot
input1: str = os.path.join(LOCALE_DIR, LOCALE_DOMAIN + '.pot')
input2: str = os.path.join(LOCALE_DIR, 'ngne.pot')
input3: str = os.path.join(LOCALE_DIR, 'nasa.pot')
input4: str = os.path.join(LOCALE_DIR, 'click.pot')
output: str = os.path.join(LOCALE_DIR, 'messages.pot')
run_command(['xgettext', input1, input2, input3, input4, '-o', output])


# execute the command `msgcat` for all languages, each in its locale path.
for idiom in VALID_LOCALES:
    messages_path: str = os.path.join('src', APP_ROOT_PACKAGE, 'locale', idiom, 'LC_MESSAGES')

    # Equivalent to:  msgcat --use-first --sort-output myapp/locale/es/LC_MESSAGES/myapp.po libA/locale/es/LC_MESSAGES/libA.po -o merged/locale/es/LC_MESSAGES/myapp.po
    input1: str = os.path.join(messages_path, LOCALE_DOMAIN + '.po')
    input2: str = os.path.join(messages_path, 'ngne.po')
    input3: str = os.path.join(messages_path, 'nasa.po')
    input4: str = os.path.join(messages_path, 'click.po')
    output: str = os.path.join(messages_path, 'messages.po')
    run_command(['msgcat', '--use-first', input1, input2, input3, input4, '-o', output])


# --- Compile .po → .mo
# The gettext runtime system uses binary .mo files, so you must compile the .po files.
# Equivalent to:  pybabel compile -D messages -d src/app/locale
# NOTE: This will fail if 'messages.po' from the previous command doesn't exist.
result_ok = run_pybabel_command(['compile', '-D', 'messages', '-d', LOCALE_DIR])
if not result_ok: sys.exit(1)

# everything ok!
sys.exit(0)
