# Generated from NeoBasicParser.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,465,3595,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
        91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,
        98,7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,
        2,104,7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,
        7,109,2,110,7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,
        2,115,7,115,2,116,7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,
        7,120,2,121,7,121,2,122,7,122,2,123,7,123,2,124,7,124,2,125,7,125,
        2,126,7,126,2,127,7,127,2,128,7,128,2,129,7,129,2,130,7,130,2,131,
        7,131,2,132,7,132,2,133,7,133,2,134,7,134,2,135,7,135,2,136,7,136,
        2,137,7,137,2,138,7,138,2,139,7,139,2,140,7,140,2,141,7,141,2,142,
        7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,7,146,2,147,7,147,
        2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,7,152,2,153,
        7,153,2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,7,158,
        2,159,7,159,2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,2,164,
        7,164,2,165,7,165,2,166,7,166,2,167,7,167,2,168,7,168,2,169,7,169,
        2,170,7,170,2,171,7,171,2,172,7,172,2,173,7,173,2,174,7,174,2,175,
        7,175,2,176,7,176,2,177,7,177,2,178,7,178,2,179,7,179,2,180,7,180,
        2,181,7,181,2,182,7,182,2,183,7,183,2,184,7,184,2,185,7,185,2,186,
        7,186,2,187,7,187,2,188,7,188,2,189,7,189,2,190,7,190,2,191,7,191,
        2,192,7,192,2,193,7,193,2,194,7,194,2,195,7,195,2,196,7,196,2,197,
        7,197,2,198,7,198,2,199,7,199,2,200,7,200,2,201,7,201,2,202,7,202,
        2,203,7,203,2,204,7,204,2,205,7,205,2,206,7,206,2,207,7,207,2,208,
        7,208,2,209,7,209,2,210,7,210,2,211,7,211,2,212,7,212,2,213,7,213,
        2,214,7,214,2,215,7,215,2,216,7,216,2,217,7,217,2,218,7,218,2,219,
        7,219,2,220,7,220,2,221,7,221,2,222,7,222,2,223,7,223,2,224,7,224,
        2,225,7,225,2,226,7,226,2,227,7,227,2,228,7,228,2,229,7,229,2,230,
        7,230,2,231,7,231,2,232,7,232,2,233,7,233,2,234,7,234,2,235,7,235,
        2,236,7,236,2,237,7,237,2,238,7,238,2,239,7,239,2,240,7,240,2,241,
        7,241,2,242,7,242,2,243,7,243,2,244,7,244,2,245,7,245,2,246,7,246,
        2,247,7,247,2,248,7,248,2,249,7,249,2,250,7,250,2,251,7,251,2,252,
        7,252,2,253,7,253,2,254,7,254,2,255,7,255,2,256,7,256,2,257,7,257,
        2,258,7,258,2,259,7,259,2,260,7,260,2,261,7,261,2,262,7,262,2,263,
        7,263,2,264,7,264,2,265,7,265,2,266,7,266,2,267,7,267,2,268,7,268,
        2,269,7,269,2,270,7,270,2,271,7,271,2,272,7,272,2,273,7,273,2,274,
        7,274,2,275,7,275,2,276,7,276,2,277,7,277,2,278,7,278,2,279,7,279,
        2,280,7,280,2,281,7,281,2,282,7,282,2,283,7,283,2,284,7,284,2,285,
        7,285,2,286,7,286,2,287,7,287,2,288,7,288,2,289,7,289,2,290,7,290,
        2,291,7,291,2,292,7,292,2,293,7,293,2,294,7,294,2,295,7,295,2,296,
        7,296,2,297,7,297,2,298,7,298,2,299,7,299,2,300,7,300,2,301,7,301,
        2,302,7,302,2,303,7,303,2,304,7,304,2,305,7,305,2,306,7,306,2,307,
        7,307,2,308,7,308,2,309,7,309,2,310,7,310,2,311,7,311,2,312,7,312,
        2,313,7,313,2,314,7,314,2,315,7,315,2,316,7,316,2,317,7,317,2,318,
        7,318,2,319,7,319,2,320,7,320,2,321,7,321,2,322,7,322,2,323,7,323,
        2,324,7,324,2,325,7,325,2,326,7,326,2,327,7,327,2,328,7,328,2,329,
        7,329,2,330,7,330,2,331,7,331,2,332,7,332,2,333,7,333,2,334,7,334,
        2,335,7,335,2,336,7,336,2,337,7,337,2,338,7,338,2,339,7,339,2,340,
        7,340,2,341,7,341,2,342,7,342,2,343,7,343,2,344,7,344,2,345,7,345,
        2,346,7,346,2,347,7,347,2,348,7,348,2,349,7,349,2,350,7,350,2,351,
        7,351,2,352,7,352,2,353,7,353,2,354,7,354,2,355,7,355,2,356,7,356,
        2,357,7,357,2,358,7,358,2,359,7,359,2,360,7,360,2,361,7,361,2,362,
        7,362,2,363,7,363,2,364,7,364,2,365,7,365,2,366,7,366,2,367,7,367,
        2,368,7,368,2,369,7,369,2,370,7,370,2,371,7,371,2,372,7,372,2,373,
        7,373,2,374,7,374,2,375,7,375,2,376,7,376,2,377,7,377,2,378,7,378,
        2,379,7,379,2,380,7,380,2,381,7,381,2,382,7,382,2,383,7,383,2,384,
        7,384,2,385,7,385,2,386,7,386,2,387,7,387,2,388,7,388,2,389,7,389,
        2,390,7,390,2,391,7,391,2,392,7,392,2,393,7,393,2,394,7,394,2,395,
        7,395,2,396,7,396,2,397,7,397,2,398,7,398,2,399,7,399,2,400,7,400,
        2,401,7,401,2,402,7,402,2,403,7,403,2,404,7,404,2,405,7,405,2,406,
        7,406,2,407,7,407,2,408,7,408,2,409,7,409,2,410,7,410,2,411,7,411,
        2,412,7,412,2,413,7,413,2,414,7,414,2,415,7,415,2,416,7,416,2,417,
        7,417,2,418,7,418,2,419,7,419,2,420,7,420,2,421,7,421,2,422,7,422,
        2,423,7,423,2,424,7,424,2,425,7,425,2,426,7,426,2,427,7,427,2,428,
        7,428,2,429,7,429,2,430,7,430,2,431,7,431,2,432,7,432,2,433,7,433,
        2,434,7,434,2,435,7,435,2,436,7,436,2,437,7,437,2,438,7,438,2,439,
        7,439,2,440,7,440,2,441,7,441,2,442,7,442,2,443,7,443,2,444,7,444,
        2,445,7,445,2,446,7,446,2,447,7,447,2,448,7,448,2,449,7,449,2,450,
        7,450,2,451,7,451,1,0,1,0,1,0,1,1,1,1,1,2,1,2,1,3,1,3,1,3,3,3,915,
        8,3,1,4,1,4,1,4,4,4,920,8,4,11,4,12,4,921,1,5,1,5,1,5,1,5,1,5,5,
        5,929,8,5,10,5,12,5,932,9,5,1,5,1,5,1,6,1,6,1,6,3,6,939,8,6,1,7,
        1,7,1,7,1,7,1,8,1,8,1,8,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,3,9,956,
        8,9,1,10,1,10,1,10,3,10,961,8,10,1,10,1,10,1,11,1,11,1,11,3,11,968,
        8,11,1,12,1,12,1,12,3,12,973,8,12,1,13,1,13,1,13,1,14,1,14,1,15,
        1,15,3,15,982,8,15,1,16,1,16,1,16,1,17,1,17,1,17,1,17,1,18,1,18,
        1,19,1,19,1,19,5,19,996,8,19,10,19,12,19,999,9,19,1,20,3,20,1002,
        8,20,1,20,1,20,1,21,3,21,1007,8,21,1,21,1,21,1,22,1,22,1,22,1,23,
        1,23,3,23,1016,8,23,1,24,1,24,3,24,1020,8,24,1,25,3,25,1023,8,25,
        1,25,1,25,3,25,1027,8,25,1,26,1,26,1,26,5,26,1032,8,26,10,26,12,
        26,1035,9,26,1,27,1,27,1,27,5,27,1040,8,27,10,27,12,27,1043,9,27,
        1,28,1,28,1,28,5,28,1048,8,28,10,28,12,28,1051,9,28,1,29,1,29,1,
        29,5,29,1056,8,29,10,29,12,29,1059,9,29,1,30,1,30,1,30,5,30,1064,
        8,30,10,30,12,30,1067,9,30,1,31,1,31,1,31,5,31,1072,8,31,10,31,12,
        31,1075,9,31,1,32,1,32,1,32,1,32,1,32,3,32,1082,8,32,1,33,1,33,1,
        33,3,33,1087,8,33,1,34,1,34,3,34,1091,8,34,1,35,1,35,1,35,1,36,1,
        36,1,36,1,37,1,37,3,37,1101,8,37,1,38,1,38,1,38,3,38,1106,8,38,1,
        39,1,39,1,39,1,39,1,39,1,40,1,40,1,40,5,40,1116,8,40,10,40,12,40,
        1119,9,40,1,41,1,41,3,41,1123,8,41,1,42,1,42,3,42,1127,8,42,1,43,
        1,43,1,43,4,43,1132,8,43,11,43,12,43,1133,1,44,1,44,1,44,3,44,1139,
        8,44,1,45,1,45,1,45,1,45,1,45,1,46,1,46,1,46,5,46,1149,8,46,10,46,
        12,46,1152,9,46,1,47,1,47,1,48,1,48,1,49,1,49,1,49,5,49,1161,8,49,
        10,49,12,49,1164,9,49,1,50,1,50,1,51,1,51,1,51,3,51,1171,8,51,1,
        52,1,52,1,52,1,52,1,52,1,53,1,53,1,53,5,53,1181,8,53,10,53,12,53,
        1184,9,53,1,54,1,54,1,54,1,54,3,54,1190,8,54,1,55,1,55,1,56,1,56,
        1,56,4,56,1197,8,56,11,56,12,56,1198,1,57,1,57,1,57,1,57,1,58,1,
        58,1,58,1,58,1,59,1,59,1,60,1,60,1,60,3,60,1214,8,60,1,60,1,60,1,
        61,1,61,1,62,1,62,1,63,1,63,1,63,3,63,1225,8,63,1,64,1,64,1,64,1,
        64,1,64,1,65,1,65,1,65,5,65,1235,8,65,10,65,12,65,1238,9,65,1,66,
        1,66,1,66,3,66,1243,8,66,1,67,1,67,1,68,1,68,1,68,4,68,1250,8,68,
        11,68,12,68,1251,1,69,1,69,1,69,1,69,1,70,4,70,1259,8,70,11,70,12,
        70,1260,1,70,1,70,1,70,1,70,1,70,3,70,1268,8,70,1,71,1,71,1,71,3,
        71,1273,8,71,1,72,1,72,3,72,1277,8,72,1,72,5,72,1280,8,72,10,72,
        12,72,1283,9,72,1,72,3,72,1286,8,72,1,73,1,73,1,73,1,73,3,73,1292,
        8,73,1,74,1,74,1,75,1,75,1,75,1,75,1,75,1,75,5,75,1302,8,75,10,75,
        12,75,1305,9,75,1,75,1,75,1,76,1,76,3,76,1311,8,76,1,76,1,76,1,76,
        3,76,1316,8,76,1,76,5,76,1319,8,76,10,76,12,76,1322,9,76,1,77,1,
        77,1,77,1,78,1,78,1,78,1,79,1,79,1,79,3,79,1333,8,79,1,80,1,80,3,
        80,1337,8,80,1,80,1,80,1,81,1,81,1,81,5,81,1344,8,81,10,81,12,81,
        1347,9,81,1,82,1,82,3,82,1351,8,82,1,82,1,82,1,83,1,83,3,83,1357,
        8,83,1,83,1,83,1,84,1,84,1,84,5,84,1364,8,84,10,84,12,84,1367,9,
        84,1,85,3,85,1370,8,85,1,85,3,85,1373,8,85,1,85,3,85,1376,8,85,1,
        85,1,85,3,85,1380,8,85,1,85,3,85,1383,8,85,1,85,1,85,3,85,1387,8,
        85,1,86,1,86,1,86,1,86,1,86,1,86,3,86,1395,8,86,1,87,1,87,1,88,1,
        88,1,89,1,89,1,89,1,89,1,89,1,89,3,89,1407,8,89,1,90,1,90,1,90,1,
        90,3,90,1413,8,90,1,91,1,91,1,92,1,92,1,92,1,93,1,93,1,94,1,94,1,
        94,1,95,4,95,1426,8,95,11,95,12,95,1427,1,95,3,95,1431,8,95,1,96,
        1,96,1,96,1,96,1,96,1,96,1,97,1,97,1,97,1,97,3,97,1443,8,97,1,97,
        1,97,1,98,1,98,1,98,1,98,1,98,1,98,1,98,1,98,1,98,1,98,1,98,1,98,
        1,98,1,98,1,98,1,98,1,98,1,98,3,98,1465,8,98,1,99,1,99,1,100,1,100,
        1,100,3,100,1472,8,100,1,101,1,101,1,101,1,101,1,101,1,102,1,102,
        1,102,5,102,1482,8,102,10,102,12,102,1485,9,102,1,103,1,103,3,103,
        1489,8,103,1,104,1,104,1,104,1,104,1,105,1,105,3,105,1497,8,105,
        1,105,1,105,1,105,1,106,1,106,1,107,1,107,1,107,3,107,1507,8,107,
        1,108,1,108,1,108,1,108,1,108,1,109,1,109,1,109,5,109,1517,8,109,
        10,109,12,109,1520,9,109,1,110,1,110,1,110,3,110,1525,8,110,1,111,
        1,111,1,111,1,111,1,112,1,112,1,112,1,112,1,112,4,112,1536,8,112,
        11,112,12,112,1537,1,113,1,113,1,113,1,113,1,113,1,113,1,114,1,114,
        1,115,1,115,1,115,3,115,1551,8,115,1,116,1,116,1,116,1,116,1,116,
        1,117,1,117,1,117,5,117,1561,8,117,10,117,12,117,1564,9,117,1,118,
        1,118,1,118,3,118,1569,8,118,1,119,1,119,1,119,1,119,3,119,1575,
        8,119,1,120,1,120,1,120,4,120,1580,8,120,11,120,12,120,1581,1,121,
        1,121,1,121,1,121,1,121,1,121,1,122,1,122,1,123,1,123,1,123,3,123,
        1595,8,123,1,124,1,124,1,124,1,124,1,124,1,125,1,125,1,125,5,125,
        1605,8,125,10,125,12,125,1608,9,125,1,126,1,126,1,126,3,126,1613,
        8,126,1,127,1,127,1,127,1,127,3,127,1619,8,127,1,128,1,128,1,128,
        4,128,1624,8,128,11,128,12,128,1625,1,129,1,129,1,129,1,129,1,129,
        1,129,1,130,1,130,1,131,1,131,1,131,1,131,1,131,3,131,1641,8,131,
        1,131,3,131,1644,8,131,1,132,1,132,1,133,1,133,1,133,1,133,3,133,
        1652,8,133,1,133,1,133,1,134,1,134,1,135,1,135,1,135,1,135,3,135,
        1662,8,135,1,135,3,135,1665,8,135,1,135,1,135,1,136,1,136,1,137,
        1,137,1,137,1,137,1,137,3,137,1676,8,137,1,137,3,137,1679,8,137,
        1,138,1,138,1,139,1,139,1,139,1,139,1,139,3,139,1688,8,139,1,139,
        3,139,1691,8,139,1,140,1,140,1,141,1,141,1,141,1,141,3,141,1699,
        8,141,1,141,3,141,1702,8,141,1,142,1,142,1,143,1,143,1,143,1,143,
        1,143,3,143,1711,8,143,1,143,3,143,1714,8,143,1,144,1,144,3,144,
        1718,8,144,1,145,3,145,1721,8,145,1,145,1,145,3,145,1725,8,145,1,
        146,1,146,1,147,1,147,1,147,1,147,1,147,3,147,1734,8,147,1,147,3,
        147,1737,8,147,1,148,1,148,3,148,1741,8,148,1,148,1,148,1,149,1,
        149,1,150,1,150,1,150,3,150,1750,8,150,1,150,3,150,1753,8,150,1,
        150,3,150,1756,8,150,1,150,1,150,1,151,1,151,1,152,1,152,3,152,1764,
        8,152,1,153,1,153,1,153,1,154,1,154,1,154,1,154,1,154,1,155,1,155,
        1,155,5,155,1777,8,155,10,155,12,155,1780,9,155,1,156,1,156,1,156,
        3,156,1785,8,156,1,157,1,157,3,157,1789,8,157,1,157,1,157,3,157,
        1793,8,157,1,158,1,158,1,158,5,158,1798,8,158,10,158,12,158,1801,
        9,158,1,159,1,159,1,160,1,160,1,160,3,160,1808,8,160,1,160,1,160,
        1,161,1,161,3,161,1814,8,161,1,162,1,162,1,162,1,163,1,163,1,163,
        1,163,1,163,1,164,1,164,1,164,5,164,1827,8,164,10,164,12,164,1830,
        9,164,1,165,1,165,1,165,1,165,3,165,1836,8,165,1,166,1,166,3,166,
        1840,8,166,1,166,1,166,3,166,1844,8,166,1,167,1,167,1,168,1,168,
        1,168,4,168,1851,8,168,11,168,12,168,1852,1,169,1,169,1,169,1,169,
        1,170,1,170,1,171,1,171,1,171,3,171,1864,8,171,1,171,1,171,1,172,
        1,172,1,173,1,173,1,174,1,174,1,174,3,174,1875,8,174,1,174,3,174,
        1878,8,174,1,174,1,174,1,175,1,175,1,176,1,176,1,177,1,177,1,177,
        3,177,1889,8,177,1,177,3,177,1892,8,177,1,177,3,177,1895,8,177,1,
        177,1,177,1,178,1,178,3,178,1901,8,178,1,179,1,179,1,179,1,180,1,
        180,1,180,5,180,1909,8,180,10,180,12,180,1912,9,180,1,181,1,181,
        3,181,1916,8,181,1,181,1,181,3,181,1920,8,181,1,182,1,182,1,183,
        1,183,1,184,1,184,1,184,3,184,1929,8,184,1,184,3,184,1932,8,184,
        1,184,3,184,1935,8,184,1,184,1,184,1,185,1,185,1,186,1,186,1,186,
        1,186,3,186,1945,8,186,1,187,1,187,1,188,1,188,1,188,3,188,1952,
        8,188,1,188,3,188,1955,8,188,1,188,1,188,1,189,1,189,1,189,1,189,
        1,190,1,190,1,190,5,190,1966,8,190,10,190,12,190,1969,9,190,1,191,
        1,191,1,191,3,191,1974,8,191,1,191,1,191,1,192,1,192,1,193,1,193,
        3,193,1982,8,193,1,193,3,193,1985,8,193,1,193,1,193,1,194,1,194,
        1,195,1,195,1,195,3,195,1994,8,195,1,195,3,195,1997,8,195,1,195,
        1,195,3,195,2001,8,195,1,195,1,195,1,196,1,196,1,197,1,197,3,197,
        2009,8,197,1,198,1,198,3,198,2013,8,198,1,198,3,198,2016,8,198,1,
        198,3,198,2019,8,198,1,198,1,198,1,199,1,199,3,199,2025,8,199,1,
        199,3,199,2028,8,199,1,199,3,199,2031,8,199,1,199,1,199,1,200,1,
        200,1,200,1,200,1,200,1,200,1,200,1,200,1,200,1,200,3,200,2045,8,
        200,1,201,1,201,1,201,1,201,1,201,1,202,1,202,1,202,5,202,2055,8,
        202,10,202,12,202,2058,9,202,1,203,1,203,1,203,1,203,1,203,3,203,
        2065,8,203,1,204,1,204,1,204,1,204,1,204,1,204,1,204,3,204,2074,
        8,204,1,204,1,204,1,204,1,204,1,204,1,204,1,204,1,204,1,204,1,204,
        1,204,1,204,1,204,5,204,2089,8,204,10,204,12,204,2092,9,204,1,205,
        1,205,1,206,1,206,1,207,1,207,1,207,1,207,1,207,3,207,2103,8,207,
        1,208,1,208,1,208,1,208,1,209,1,209,1,209,4,209,2112,8,209,11,209,
        12,209,2113,1,210,1,210,1,210,1,210,1,211,1,211,1,211,1,211,1,211,
        1,211,1,211,1,211,3,211,2128,8,211,1,212,1,212,1,212,1,213,1,213,
        3,213,2135,8,213,1,213,3,213,2138,8,213,1,214,1,214,3,214,2142,8,
        214,1,214,3,214,2145,8,214,1,215,1,215,3,215,2149,8,215,1,216,1,
        216,3,216,2153,8,216,1,217,1,217,1,217,1,218,1,218,1,218,1,218,1,
        218,1,218,1,218,1,218,3,218,2166,8,218,1,219,1,219,1,219,3,219,2171,
        8,219,1,220,1,220,1,220,3,220,2176,8,220,1,221,1,221,1,221,3,221,
        2181,8,221,1,222,1,222,1,222,1,223,1,223,3,223,2188,8,223,1,224,
        1,224,1,224,1,225,1,225,1,225,1,226,1,226,1,226,1,227,1,227,1,227,
        3,227,2202,8,227,1,228,1,228,1,228,1,228,1,228,1,229,1,229,1,229,
        1,229,3,229,2213,8,229,1,230,1,230,1,230,1,231,1,231,1,231,1,231,
        3,231,2222,8,231,1,232,1,232,1,232,1,232,3,232,2228,8,232,1,233,
        1,233,1,234,1,234,3,234,2234,8,234,1,235,1,235,1,236,1,236,5,236,
        2240,8,236,10,236,12,236,2243,9,236,1,236,3,236,2246,8,236,1,237,
        1,237,1,237,1,237,1,238,1,238,1,238,1,238,1,238,1,239,1,239,1,239,
        1,239,1,240,1,240,4,240,2263,8,240,11,240,12,240,2264,1,240,3,240,
        2268,8,240,1,241,1,241,3,241,2272,8,241,1,242,1,242,1,242,1,242,
        1,242,1,243,1,243,5,243,2281,8,243,10,243,12,243,2284,9,243,1,244,
        1,244,1,244,3,244,2289,8,244,1,245,1,245,1,245,3,245,2294,8,245,
        1,245,1,245,1,246,1,246,4,246,2300,8,246,11,246,12,246,2301,1,246,
        3,246,2305,8,246,1,247,1,247,1,247,1,248,1,248,1,248,1,248,1,248,
        1,249,1,249,1,249,1,249,1,250,1,250,3,250,2321,8,250,1,251,1,251,
        3,251,2325,8,251,1,251,1,251,1,252,1,252,1,252,3,252,2332,8,252,
        1,253,3,253,2335,8,253,1,253,3,253,2338,8,253,1,253,1,253,1,254,
        1,254,3,254,2344,8,254,1,254,3,254,2347,8,254,1,254,1,254,1,255,
        1,255,1,255,1,255,3,255,2355,8,255,1,255,3,255,2358,8,255,1,256,
        1,256,1,256,1,257,1,257,1,257,1,258,1,258,1,258,3,258,2369,8,258,
        1,259,1,259,3,259,2373,8,259,1,260,1,260,1,260,1,260,1,260,3,260,
        2380,8,260,1,261,1,261,1,261,1,262,1,262,1,262,1,263,1,263,1,263,
        1,263,1,264,1,264,5,264,2394,8,264,10,264,12,264,2397,9,264,1,264,
        1,264,1,265,1,265,1,265,1,266,1,266,1,266,1,266,1,267,1,267,1,268,
        1,268,1,268,3,268,2413,8,268,1,269,1,269,3,269,2417,8,269,1,269,
        3,269,2420,8,269,1,270,1,270,3,270,2424,8,270,1,270,1,270,1,271,
        1,271,1,271,1,272,1,272,1,272,1,272,1,272,1,272,3,272,2437,8,272,
        1,273,1,273,3,273,2441,8,273,1,274,1,274,1,275,1,275,1,276,1,276,
        1,277,1,277,1,277,1,277,1,277,3,277,2454,8,277,1,278,1,278,1,278,
        3,278,2459,8,278,1,278,1,278,3,278,2463,8,278,1,278,1,278,3,278,
        2467,8,278,1,278,1,278,3,278,2471,8,278,1,278,1,278,3,278,2475,8,
        278,1,278,1,278,3,278,2479,8,278,1,278,1,278,3,278,2483,8,278,1,
        278,1,278,3,278,2487,8,278,1,278,1,278,3,278,2491,8,278,1,278,1,
        278,3,278,2495,8,278,1,279,1,279,3,279,2499,8,279,1,279,3,279,2502,
        8,279,1,280,1,280,1,280,3,280,2507,8,280,1,281,1,281,1,281,3,281,
        2512,8,281,1,282,1,282,1,282,1,282,1,282,1,282,1,283,1,283,1,283,
        5,283,2523,8,283,10,283,12,283,2526,9,283,1,284,1,284,1,284,5,284,
        2531,8,284,10,284,12,284,2534,9,284,1,285,1,285,1,285,3,285,2539,
        8,285,1,286,1,286,1,286,3,286,2544,8,286,1,287,1,287,1,287,3,287,
        2549,8,287,1,288,1,288,1,288,3,288,2554,8,288,1,289,1,289,1,289,
        3,289,2559,8,289,1,290,1,290,1,290,3,290,2564,8,290,1,291,1,291,
        1,291,3,291,2569,8,291,1,292,1,292,1,292,1,292,1,292,1,292,1,292,
        3,292,2578,8,292,1,293,1,293,1,294,1,294,1,295,1,295,1,296,1,296,
        1,297,1,297,1,298,1,298,1,299,1,299,1,300,1,300,1,300,1,300,1,300,
        1,300,1,300,3,300,2601,8,300,1,301,1,301,1,302,1,302,1,303,1,303,
        1,304,1,304,1,305,1,305,1,306,1,306,1,307,1,307,1,308,1,308,1,309,
        1,309,1,310,1,310,1,311,1,311,1,312,1,312,1,313,1,313,1,314,1,314,
        1,315,1,315,1,316,1,316,1,317,1,317,1,318,1,318,1,319,1,319,1,319,
        3,319,2642,8,319,1,320,1,320,1,321,1,321,1,322,1,322,1,323,1,323,
        1,323,1,323,1,323,1,323,1,323,1,323,1,323,1,323,1,323,1,323,1,323,
        1,323,1,323,3,323,2665,8,323,1,324,1,324,3,324,2669,8,324,1,324,
        5,324,2672,8,324,10,324,12,324,2675,9,324,1,325,1,325,3,325,2679,
        8,325,1,326,1,326,5,326,2683,8,326,10,326,12,326,2686,9,326,1,327,
        1,327,5,327,2690,8,327,10,327,12,327,2693,9,327,1,328,1,328,1,328,
        5,328,2698,8,328,10,328,12,328,2701,9,328,1,329,1,329,3,329,2705,
        8,329,1,329,1,329,1,330,1,330,1,330,1,330,1,331,1,331,1,331,5,331,
        2716,8,331,10,331,12,331,2719,9,331,1,332,1,332,1,332,3,332,2724,
        8,332,1,333,1,333,1,333,5,333,2729,8,333,10,333,12,333,2732,9,333,
        1,334,1,334,1,334,1,334,1,334,1,334,3,334,2740,8,334,1,334,1,334,
        1,334,1,334,1,334,1,334,1,334,1,334,1,334,1,334,1,334,1,334,1,334,
        1,334,1,334,1,334,5,334,2758,8,334,10,334,12,334,2761,9,334,1,335,
        1,335,1,335,1,335,1,336,1,336,1,336,1,336,1,336,1,336,1,336,1,336,
        1,336,1,336,1,336,1,336,1,336,1,336,3,336,2781,8,336,1,337,1,337,
        1,337,1,337,1,337,3,337,2788,8,337,1,338,1,338,1,338,1,338,3,338,
        2794,8,338,1,339,1,339,1,340,1,340,1,340,1,340,1,340,1,340,1,340,
        3,340,2805,8,340,1,341,1,341,1,342,1,342,1,343,1,343,1,344,1,344,
        1,345,1,345,1,346,1,346,1,347,1,347,1,348,1,348,1,349,1,349,1,350,
        1,350,1,350,3,350,2828,8,350,1,351,1,351,1,352,1,352,1,353,1,353,
        1,354,1,354,1,355,1,355,1,356,1,356,1,356,1,356,1,356,1,356,1,356,
        1,356,1,356,3,356,2849,8,356,1,357,1,357,1,357,1,357,1,358,1,358,
        1,358,1,359,1,359,1,359,1,359,1,360,1,360,1,360,1,360,1,361,1,361,
        1,361,1,362,1,362,1,362,1,362,1,363,1,363,1,363,1,363,1,364,1,364,
        1,365,1,365,1,365,1,366,1,366,3,366,2884,8,366,1,366,1,366,1,367,
        1,367,3,367,2890,8,367,1,367,1,367,1,368,1,368,1,368,5,368,2897,
        8,368,10,368,12,368,2900,9,368,1,369,3,369,2903,8,369,1,369,1,369,
        1,370,1,370,1,370,1,370,3,370,2911,8,370,1,371,1,371,1,371,1,371,
        1,371,3,371,2918,8,371,1,372,1,372,1,373,1,373,1,373,1,373,1,373,
        1,373,1,373,1,373,1,373,1,373,1,373,1,373,1,373,1,373,1,373,3,373,
        2937,8,373,1,374,1,374,1,375,1,375,1,375,3,375,2944,8,375,1,375,
        1,375,3,375,2948,8,375,1,375,1,375,3,375,2952,8,375,1,375,1,375,
        3,375,2956,8,375,1,375,1,375,3,375,2960,8,375,1,375,1,375,3,375,
        2964,8,375,1,375,1,375,1,375,1,375,1,375,1,375,3,375,2972,8,375,
        1,376,1,376,1,376,1,376,1,376,1,376,1,376,1,376,1,376,1,376,1,376,
        1,376,1,376,1,376,1,376,3,376,2989,8,376,1,377,1,377,1,377,1,377,
        3,377,2995,8,377,1,378,1,378,1,378,1,378,3,378,3001,8,378,1,379,
        1,379,1,379,3,379,3006,8,379,1,380,1,380,1,380,1,380,3,380,3012,
        8,380,1,381,1,381,1,381,3,381,3017,8,381,1,382,1,382,1,382,1,382,
        1,382,1,382,3,382,3025,8,382,1,383,1,383,1,383,1,383,1,383,1,383,
        1,383,1,383,1,383,1,383,1,383,1,383,1,383,3,383,3040,8,383,1,384,
        1,384,1,385,1,385,1,386,1,386,1,386,1,386,1,386,1,386,3,386,3052,
        8,386,1,387,1,387,1,387,1,387,1,387,1,387,1,387,1,387,1,387,1,387,
        3,387,3064,8,387,1,388,1,388,1,388,1,388,1,389,1,389,1,389,3,389,
        3073,8,389,1,389,1,389,1,390,1,390,1,390,1,390,1,390,3,390,3082,
        8,390,1,391,1,391,1,391,1,391,3,391,3088,8,391,1,392,1,392,1,392,
        1,392,1,392,1,392,1,392,1,392,1,392,1,392,1,392,1,392,1,392,1,392,
        1,392,1,392,1,392,3,392,3107,8,392,1,393,1,393,1,393,5,393,3112,
        8,393,10,393,12,393,3115,9,393,1,394,1,394,3,394,3119,8,394,1,395,
        1,395,3,395,3123,8,395,1,396,1,396,5,396,3127,8,396,10,396,12,396,
        3130,9,396,1,396,1,396,1,397,1,397,1,397,5,397,3137,8,397,10,397,
        12,397,3140,9,397,1,397,1,397,1,398,1,398,1,398,1,398,1,399,1,399,
        1,399,5,399,3151,8,399,10,399,12,399,3154,9,399,1,399,1,399,1,400,
        1,400,3,400,3160,8,400,1,401,1,401,5,401,3164,8,401,10,401,12,401,
        3167,9,401,1,401,1,401,1,402,1,402,1,403,1,403,3,403,3175,8,403,
        1,404,1,404,1,404,3,404,3180,8,404,1,405,1,405,3,405,3184,8,405,
        1,406,1,406,1,406,3,406,3189,8,406,1,407,1,407,1,407,1,407,1,408,
        3,408,3196,8,408,1,408,1,408,1,408,3,408,3201,8,408,1,409,1,409,
        1,409,1,409,1,409,3,409,3208,8,409,4,409,3210,8,409,11,409,12,409,
        3211,1,409,1,409,3,409,3216,8,409,1,410,4,410,3219,8,410,11,410,
        12,410,3220,1,411,1,411,1,411,3,411,3226,8,411,1,411,1,411,1,412,
        1,412,1,413,1,413,1,414,1,414,1,414,1,414,1,415,1,415,1,415,4,415,
        3241,8,415,11,415,12,415,3242,1,415,1,415,1,416,1,416,1,416,3,416,
        3250,8,416,1,417,3,417,3253,8,417,1,417,1,417,1,418,1,418,1,418,
        1,418,1,418,3,418,3262,8,418,1,418,1,418,1,418,1,418,1,418,1,418,
        3,418,3270,8,418,1,419,1,419,1,419,5,419,3275,8,419,10,419,12,419,
        3278,9,419,1,420,1,420,1,420,3,420,3283,8,420,1,420,1,420,1,421,
        1,421,1,422,1,422,1,423,1,423,1,423,3,423,3294,8,423,1,424,1,424,
        3,424,3298,8,424,1,424,1,424,1,424,1,425,1,425,1,425,1,425,1,426,
        1,426,1,426,1,426,4,426,3311,8,426,11,426,12,426,3312,1,426,1,426,
        1,427,1,427,3,427,3319,8,427,1,428,1,428,1,429,1,429,1,430,1,430,
        3,430,3327,8,430,1,431,1,431,1,432,1,432,1,433,1,433,1,433,5,433,
        3336,8,433,10,433,12,433,3339,9,433,1,434,1,434,1,434,1,434,1,434,
        1,434,1,434,1,434,1,434,1,434,1,434,3,434,3352,8,434,1,434,1,434,
        1,434,1,434,1,434,1,434,1,434,1,434,1,434,1,434,3,434,3364,8,434,
        1,434,1,434,1,434,1,434,5,434,3370,8,434,10,434,12,434,3373,9,434,
        1,434,1,434,1,434,5,434,3378,8,434,10,434,12,434,3381,9,434,1,435,
        1,435,1,435,1,435,1,435,3,435,3388,8,435,1,436,1,436,3,436,3392,
        8,436,1,437,1,437,1,437,1,437,1,438,1,438,1,438,1,438,1,439,1,439,
        1,439,3,439,3405,8,439,1,440,1,440,1,440,1,440,1,440,1,440,1,440,
        1,440,1,440,1,440,1,440,3,440,3418,8,440,1,440,1,440,1,440,5,440,
        3423,8,440,10,440,12,440,3426,9,440,1,441,1,441,1,441,1,441,1,441,
        1,441,1,441,1,441,1,441,1,441,3,441,3438,8,441,1,441,1,441,1,441,
        5,441,3443,8,441,10,441,12,441,3446,9,441,1,442,1,442,1,442,3,442,
        3451,8,442,1,443,1,443,1,443,1,443,1,443,1,444,4,444,3459,8,444,
        11,444,12,444,3460,1,445,1,445,1,445,5,445,3466,8,445,10,445,12,
        445,3469,9,445,1,446,1,446,1,446,1,446,1,446,1,446,1,446,1,446,4,
        446,3479,8,446,11,446,12,446,3480,1,446,3,446,3484,8,446,1,446,1,
        446,1,446,5,446,3489,8,446,10,446,12,446,3492,9,446,1,446,1,446,
        1,446,1,446,1,446,1,446,3,446,3500,8,446,1,446,1,446,1,446,1,446,
        1,446,1,446,1,446,1,446,1,446,1,446,1,446,1,446,1,446,1,446,1,446,
        1,446,1,446,1,446,1,446,1,446,1,446,1,446,1,446,1,446,1,446,1,446,
        1,446,1,446,1,446,1,446,1,446,1,446,1,446,1,446,1,446,1,446,1,446,
        1,446,1,446,1,446,1,446,1,446,1,446,1,446,1,446,1,446,1,446,1,446,
        1,446,1,446,1,446,1,446,1,446,1,446,1,446,1,446,1,446,1,446,1,446,
        1,446,1,446,3,446,3563,8,446,5,446,3565,8,446,10,446,12,446,3568,
        9,446,1,447,4,447,3571,8,447,11,447,12,447,3572,1,447,3,447,3576,
        8,447,1,448,1,448,1,448,1,448,1,448,1,449,1,449,1,449,1,450,1,450,
        1,450,1,450,1,450,1,451,1,451,1,451,1,451,1,451,0,6,408,668,868,
        880,882,892,452,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,
        36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,
        80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,
        118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,
        150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,
        182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,
        214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,
        246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,
        278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,
        310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,
        342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,
        374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,
        406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,436,
        438,440,442,444,446,448,450,452,454,456,458,460,462,464,466,468,
        470,472,474,476,478,480,482,484,486,488,490,492,494,496,498,500,
        502,504,506,508,510,512,514,516,518,520,522,524,526,528,530,532,
        534,536,538,540,542,544,546,548,550,552,554,556,558,560,562,564,
        566,568,570,572,574,576,578,580,582,584,586,588,590,592,594,596,
        598,600,602,604,606,608,610,612,614,616,618,620,622,624,626,628,
        630,632,634,636,638,640,642,644,646,648,650,652,654,656,658,660,
        662,664,666,668,670,672,674,676,678,680,682,684,686,688,690,692,
        694,696,698,700,702,704,706,708,710,712,714,716,718,720,722,724,
        726,728,730,732,734,736,738,740,742,744,746,748,750,752,754,756,
        758,760,762,764,766,768,770,772,774,776,778,780,782,784,786,788,
        790,792,794,796,798,800,802,804,806,808,810,812,814,816,818,820,
        822,824,826,828,830,832,834,836,838,840,842,844,846,848,850,852,
        854,856,858,860,862,864,866,868,870,872,874,876,878,880,882,884,
        886,888,890,892,894,896,898,900,902,0,49,1,0,381,382,1,0,14,16,2,
        0,292,293,450,450,3,0,290,290,334,334,441,441,2,0,29,29,84,84,2,
        0,40,42,110,111,1,0,283,289,1,0,107,108,1,0,283,284,1,0,294,303,
        1,0,288,289,1,0,304,306,1,0,115,118,1,0,122,123,1,0,119,121,2,0,
        448,448,451,451,1,0,307,308,1,0,309,316,3,0,40,42,109,114,317,328,
        1,0,329,333,1,0,343,352,1,0,334,337,1,0,334,335,2,0,334,334,336,
        336,1,0,353,358,1,0,359,380,3,0,40,42,110,111,291,291,1,0,133,138,
        1,0,139,146,1,0,147,153,1,0,161,167,1,0,154,160,1,0,168,173,1,0,
        174,177,1,0,178,181,1,0,182,183,1,0,184,189,1,0,190,197,1,0,198,
        203,1,0,204,215,4,0,259,259,262,262,265,265,268,268,6,0,4,6,13,13,
        17,17,34,39,45,45,128,132,1,0,216,217,2,0,390,390,404,404,3,0,395,
        395,397,397,399,399,2,0,93,99,452,452,1,0,406,413,7,0,216,217,219,
        237,239,254,260,261,263,264,266,267,269,270,1,0,100,105,3716,0,904,
        1,0,0,0,2,907,1,0,0,0,4,909,1,0,0,0,6,914,1,0,0,0,8,919,1,0,0,0,
        10,923,1,0,0,0,12,938,1,0,0,0,14,940,1,0,0,0,16,944,1,0,0,0,18,955,
        1,0,0,0,20,957,1,0,0,0,22,967,1,0,0,0,24,969,1,0,0,0,26,974,1,0,
        0,0,28,977,1,0,0,0,30,981,1,0,0,0,32,983,1,0,0,0,34,986,1,0,0,0,
        36,990,1,0,0,0,38,992,1,0,0,0,40,1001,1,0,0,0,42,1006,1,0,0,0,44,
        1010,1,0,0,0,46,1013,1,0,0,0,48,1017,1,0,0,0,50,1022,1,0,0,0,52,
        1028,1,0,0,0,54,1036,1,0,0,0,56,1044,1,0,0,0,58,1052,1,0,0,0,60,
        1060,1,0,0,0,62,1068,1,0,0,0,64,1081,1,0,0,0,66,1086,1,0,0,0,68,
        1088,1,0,0,0,70,1092,1,0,0,0,72,1095,1,0,0,0,74,1100,1,0,0,0,76,
        1102,1,0,0,0,78,1107,1,0,0,0,80,1112,1,0,0,0,82,1122,1,0,0,0,84,
        1124,1,0,0,0,86,1128,1,0,0,0,88,1135,1,0,0,0,90,1140,1,0,0,0,92,
        1145,1,0,0,0,94,1153,1,0,0,0,96,1155,1,0,0,0,98,1157,1,0,0,0,100,
        1165,1,0,0,0,102,1167,1,0,0,0,104,1172,1,0,0,0,106,1177,1,0,0,0,
        108,1189,1,0,0,0,110,1191,1,0,0,0,112,1193,1,0,0,0,114,1200,1,0,
        0,0,116,1204,1,0,0,0,118,1208,1,0,0,0,120,1210,1,0,0,0,122,1217,
        1,0,0,0,124,1219,1,0,0,0,126,1221,1,0,0,0,128,1226,1,0,0,0,130,1231,
        1,0,0,0,132,1242,1,0,0,0,134,1244,1,0,0,0,136,1246,1,0,0,0,138,1253,
        1,0,0,0,140,1267,1,0,0,0,142,1272,1,0,0,0,144,1274,1,0,0,0,146,1287,
        1,0,0,0,148,1293,1,0,0,0,150,1295,1,0,0,0,152,1308,1,0,0,0,154,1323,
        1,0,0,0,156,1326,1,0,0,0,158,1332,1,0,0,0,160,1334,1,0,0,0,162,1340,
        1,0,0,0,164,1350,1,0,0,0,166,1354,1,0,0,0,168,1360,1,0,0,0,170,1369,
        1,0,0,0,172,1394,1,0,0,0,174,1396,1,0,0,0,176,1398,1,0,0,0,178,1406,
        1,0,0,0,180,1412,1,0,0,0,182,1414,1,0,0,0,184,1416,1,0,0,0,186,1419,
        1,0,0,0,188,1421,1,0,0,0,190,1425,1,0,0,0,192,1432,1,0,0,0,194,1438,
        1,0,0,0,196,1464,1,0,0,0,198,1466,1,0,0,0,200,1468,1,0,0,0,202,1473,
        1,0,0,0,204,1478,1,0,0,0,206,1488,1,0,0,0,208,1490,1,0,0,0,210,1494,
        1,0,0,0,212,1501,1,0,0,0,214,1503,1,0,0,0,216,1508,1,0,0,0,218,1513,
        1,0,0,0,220,1524,1,0,0,0,222,1526,1,0,0,0,224,1530,1,0,0,0,226,1539,
        1,0,0,0,228,1545,1,0,0,0,230,1547,1,0,0,0,232,1552,1,0,0,0,234,1557,
        1,0,0,0,236,1568,1,0,0,0,238,1570,1,0,0,0,240,1576,1,0,0,0,242,1583,
        1,0,0,0,244,1589,1,0,0,0,246,1591,1,0,0,0,248,1596,1,0,0,0,250,1601,
        1,0,0,0,252,1612,1,0,0,0,254,1614,1,0,0,0,256,1620,1,0,0,0,258,1627,
        1,0,0,0,260,1633,1,0,0,0,262,1635,1,0,0,0,264,1645,1,0,0,0,266,1647,
        1,0,0,0,268,1655,1,0,0,0,270,1657,1,0,0,0,272,1668,1,0,0,0,274,1670,
        1,0,0,0,276,1680,1,0,0,0,278,1682,1,0,0,0,280,1692,1,0,0,0,282,1694,
        1,0,0,0,284,1703,1,0,0,0,286,1705,1,0,0,0,288,1717,1,0,0,0,290,1720,
        1,0,0,0,292,1726,1,0,0,0,294,1728,1,0,0,0,296,1738,1,0,0,0,298,1744,
        1,0,0,0,300,1746,1,0,0,0,302,1759,1,0,0,0,304,1763,1,0,0,0,306,1765,
        1,0,0,0,308,1768,1,0,0,0,310,1773,1,0,0,0,312,1784,1,0,0,0,314,1786,
        1,0,0,0,316,1794,1,0,0,0,318,1802,1,0,0,0,320,1804,1,0,0,0,322,1813,
        1,0,0,0,324,1815,1,0,0,0,326,1818,1,0,0,0,328,1823,1,0,0,0,330,1835,
        1,0,0,0,332,1837,1,0,0,0,334,1845,1,0,0,0,336,1847,1,0,0,0,338,1854,
        1,0,0,0,340,1858,1,0,0,0,342,1860,1,0,0,0,344,1867,1,0,0,0,346,1869,
        1,0,0,0,348,1871,1,0,0,0,350,1881,1,0,0,0,352,1883,1,0,0,0,354,1885,
        1,0,0,0,356,1900,1,0,0,0,358,1902,1,0,0,0,360,1905,1,0,0,0,362,1913,
        1,0,0,0,364,1921,1,0,0,0,366,1923,1,0,0,0,368,1925,1,0,0,0,370,1938,
        1,0,0,0,372,1944,1,0,0,0,374,1946,1,0,0,0,376,1948,1,0,0,0,378,1958,
        1,0,0,0,380,1962,1,0,0,0,382,1973,1,0,0,0,384,1977,1,0,0,0,386,1979,
        1,0,0,0,388,1988,1,0,0,0,390,1990,1,0,0,0,392,2004,1,0,0,0,394,2008,
        1,0,0,0,396,2010,1,0,0,0,398,2022,1,0,0,0,400,2044,1,0,0,0,402,2046,
        1,0,0,0,404,2051,1,0,0,0,406,2064,1,0,0,0,408,2073,1,0,0,0,410,2093,
        1,0,0,0,412,2095,1,0,0,0,414,2102,1,0,0,0,416,2104,1,0,0,0,418,2108,
        1,0,0,0,420,2115,1,0,0,0,422,2127,1,0,0,0,424,2129,1,0,0,0,426,2132,
        1,0,0,0,428,2139,1,0,0,0,430,2146,1,0,0,0,432,2150,1,0,0,0,434,2154,
        1,0,0,0,436,2165,1,0,0,0,438,2167,1,0,0,0,440,2172,1,0,0,0,442,2177,
        1,0,0,0,444,2182,1,0,0,0,446,2185,1,0,0,0,448,2189,1,0,0,0,450,2192,
        1,0,0,0,452,2195,1,0,0,0,454,2201,1,0,0,0,456,2203,1,0,0,0,458,2208,
        1,0,0,0,460,2214,1,0,0,0,462,2221,1,0,0,0,464,2227,1,0,0,0,466,2229,
        1,0,0,0,468,2233,1,0,0,0,470,2235,1,0,0,0,472,2237,1,0,0,0,474,2247,
        1,0,0,0,476,2251,1,0,0,0,478,2256,1,0,0,0,480,2260,1,0,0,0,482,2269,
        1,0,0,0,484,2273,1,0,0,0,486,2278,1,0,0,0,488,2285,1,0,0,0,490,2290,
        1,0,0,0,492,2297,1,0,0,0,494,2306,1,0,0,0,496,2309,1,0,0,0,498,2314,
        1,0,0,0,500,2318,1,0,0,0,502,2322,1,0,0,0,504,2331,1,0,0,0,506,2334,
        1,0,0,0,508,2341,1,0,0,0,510,2350,1,0,0,0,512,2359,1,0,0,0,514,2362,
        1,0,0,0,516,2368,1,0,0,0,518,2372,1,0,0,0,520,2374,1,0,0,0,522,2381,
        1,0,0,0,524,2384,1,0,0,0,526,2387,1,0,0,0,528,2391,1,0,0,0,530,2400,
        1,0,0,0,532,2403,1,0,0,0,534,2407,1,0,0,0,536,2409,1,0,0,0,538,2414,
        1,0,0,0,540,2421,1,0,0,0,542,2427,1,0,0,0,544,2430,1,0,0,0,546,2440,
        1,0,0,0,548,2442,1,0,0,0,550,2444,1,0,0,0,552,2446,1,0,0,0,554,2448,
        1,0,0,0,556,2455,1,0,0,0,558,2496,1,0,0,0,560,2503,1,0,0,0,562,2508,
        1,0,0,0,564,2513,1,0,0,0,566,2519,1,0,0,0,568,2527,1,0,0,0,570,2535,
        1,0,0,0,572,2540,1,0,0,0,574,2545,1,0,0,0,576,2550,1,0,0,0,578,2555,
        1,0,0,0,580,2560,1,0,0,0,582,2565,1,0,0,0,584,2577,1,0,0,0,586,2579,
        1,0,0,0,588,2581,1,0,0,0,590,2583,1,0,0,0,592,2585,1,0,0,0,594,2587,
        1,0,0,0,596,2589,1,0,0,0,598,2591,1,0,0,0,600,2600,1,0,0,0,602,2602,
        1,0,0,0,604,2604,1,0,0,0,606,2606,1,0,0,0,608,2608,1,0,0,0,610,2610,
        1,0,0,0,612,2612,1,0,0,0,614,2614,1,0,0,0,616,2616,1,0,0,0,618,2618,
        1,0,0,0,620,2620,1,0,0,0,622,2622,1,0,0,0,624,2624,1,0,0,0,626,2626,
        1,0,0,0,628,2628,1,0,0,0,630,2630,1,0,0,0,632,2632,1,0,0,0,634,2634,
        1,0,0,0,636,2636,1,0,0,0,638,2641,1,0,0,0,640,2643,1,0,0,0,642,2645,
        1,0,0,0,644,2647,1,0,0,0,646,2664,1,0,0,0,648,2666,1,0,0,0,650,2678,
        1,0,0,0,652,2680,1,0,0,0,654,2687,1,0,0,0,656,2694,1,0,0,0,658,2704,
        1,0,0,0,660,2708,1,0,0,0,662,2712,1,0,0,0,664,2720,1,0,0,0,666,2725,
        1,0,0,0,668,2739,1,0,0,0,670,2762,1,0,0,0,672,2780,1,0,0,0,674,2787,
        1,0,0,0,676,2793,1,0,0,0,678,2795,1,0,0,0,680,2804,1,0,0,0,682,2806,
        1,0,0,0,684,2808,1,0,0,0,686,2810,1,0,0,0,688,2812,1,0,0,0,690,2814,
        1,0,0,0,692,2816,1,0,0,0,694,2818,1,0,0,0,696,2820,1,0,0,0,698,2822,
        1,0,0,0,700,2827,1,0,0,0,702,2829,1,0,0,0,704,2831,1,0,0,0,706,2833,
        1,0,0,0,708,2835,1,0,0,0,710,2837,1,0,0,0,712,2848,1,0,0,0,714,2850,
        1,0,0,0,716,2854,1,0,0,0,718,2857,1,0,0,0,720,2861,1,0,0,0,722,2865,
        1,0,0,0,724,2868,1,0,0,0,726,2872,1,0,0,0,728,2876,1,0,0,0,730,2878,
        1,0,0,0,732,2881,1,0,0,0,734,2887,1,0,0,0,736,2893,1,0,0,0,738,2902,
        1,0,0,0,740,2910,1,0,0,0,742,2917,1,0,0,0,744,2919,1,0,0,0,746,2936,
        1,0,0,0,748,2938,1,0,0,0,750,2971,1,0,0,0,752,2988,1,0,0,0,754,2994,
        1,0,0,0,756,3000,1,0,0,0,758,3005,1,0,0,0,760,3011,1,0,0,0,762,3016,
        1,0,0,0,764,3024,1,0,0,0,766,3039,1,0,0,0,768,3041,1,0,0,0,770,3043,
        1,0,0,0,772,3051,1,0,0,0,774,3063,1,0,0,0,776,3065,1,0,0,0,778,3069,
        1,0,0,0,780,3081,1,0,0,0,782,3087,1,0,0,0,784,3106,1,0,0,0,786,3108,
        1,0,0,0,788,3118,1,0,0,0,790,3122,1,0,0,0,792,3124,1,0,0,0,794,3133,
        1,0,0,0,796,3143,1,0,0,0,798,3147,1,0,0,0,800,3159,1,0,0,0,802,3161,
        1,0,0,0,804,3170,1,0,0,0,806,3174,1,0,0,0,808,3176,1,0,0,0,810,3183,
        1,0,0,0,812,3188,1,0,0,0,814,3190,1,0,0,0,816,3200,1,0,0,0,818,3215,
        1,0,0,0,820,3218,1,0,0,0,822,3225,1,0,0,0,824,3229,1,0,0,0,826,3231,
        1,0,0,0,828,3233,1,0,0,0,830,3237,1,0,0,0,832,3246,1,0,0,0,834,3252,
        1,0,0,0,836,3269,1,0,0,0,838,3271,1,0,0,0,840,3282,1,0,0,0,842,3286,
        1,0,0,0,844,3288,1,0,0,0,846,3293,1,0,0,0,848,3295,1,0,0,0,850,3302,
        1,0,0,0,852,3306,1,0,0,0,854,3318,1,0,0,0,856,3320,1,0,0,0,858,3322,
        1,0,0,0,860,3326,1,0,0,0,862,3328,1,0,0,0,864,3330,1,0,0,0,866,3332,
        1,0,0,0,868,3351,1,0,0,0,870,3387,1,0,0,0,872,3391,1,0,0,0,874,3393,
        1,0,0,0,876,3397,1,0,0,0,878,3404,1,0,0,0,880,3417,1,0,0,0,882,3437,
        1,0,0,0,884,3450,1,0,0,0,886,3452,1,0,0,0,888,3458,1,0,0,0,890,3462,
        1,0,0,0,892,3499,1,0,0,0,894,3570,1,0,0,0,896,3577,1,0,0,0,898,3582,
        1,0,0,0,900,3585,1,0,0,0,902,3590,1,0,0,0,904,905,3,20,10,0,905,
        906,3,2,1,0,906,1,1,0,0,0,907,908,3,8,4,0,908,3,1,0,0,0,909,910,
        3,12,6,0,910,5,1,0,0,0,911,915,3,0,0,0,912,915,3,2,1,0,913,915,3,
        4,2,0,914,911,1,0,0,0,914,912,1,0,0,0,914,913,1,0,0,0,915,7,1,0,
        0,0,916,917,3,12,6,0,917,918,5,423,0,0,918,920,1,0,0,0,919,916,1,
        0,0,0,920,921,1,0,0,0,921,919,1,0,0,0,921,922,1,0,0,0,922,9,1,0,
        0,0,923,924,5,423,0,0,924,925,5,2,0,0,925,930,3,12,6,0,926,927,5,
        423,0,0,927,929,3,12,6,0,928,926,1,0,0,0,929,932,1,0,0,0,930,928,
        1,0,0,0,930,931,1,0,0,0,931,933,1,0,0,0,932,930,1,0,0,0,933,934,
        5,3,0,0,934,11,1,0,0,0,935,939,3,14,7,0,936,939,3,16,8,0,937,939,
        3,18,9,0,938,935,1,0,0,0,938,936,1,0,0,0,938,937,1,0,0,0,939,13,
        1,0,0,0,940,941,3,22,11,0,941,942,5,423,0,0,942,943,3,12,6,0,943,
        15,1,0,0,0,944,945,3,22,11,0,945,946,3,10,5,0,946,17,1,0,0,0,947,
        948,5,418,0,0,948,956,3,18,9,0,949,950,5,417,0,0,950,956,3,18,9,
        0,951,956,3,64,32,0,952,956,3,140,70,0,953,956,3,400,200,0,954,956,
        1,0,0,0,955,947,1,0,0,0,955,949,1,0,0,0,955,951,1,0,0,0,955,952,
        1,0,0,0,955,953,1,0,0,0,955,954,1,0,0,0,956,19,1,0,0,0,957,958,5,
        419,0,0,958,960,5,416,0,0,959,961,3,892,446,0,960,959,1,0,0,0,960,
        961,1,0,0,0,961,962,1,0,0,0,962,963,5,423,0,0,963,21,1,0,0,0,964,
        968,3,24,12,0,965,968,3,26,13,0,966,968,3,30,15,0,967,964,1,0,0,
        0,967,965,1,0,0,0,967,966,1,0,0,0,968,23,1,0,0,0,969,970,5,419,0,
        0,970,972,5,381,0,0,971,973,3,890,445,0,972,971,1,0,0,0,972,973,
        1,0,0,0,973,25,1,0,0,0,974,975,5,420,0,0,975,976,3,28,14,0,976,27,
        1,0,0,0,977,978,3,890,445,0,978,29,1,0,0,0,979,982,3,32,16,0,980,
        982,3,34,17,0,981,979,1,0,0,0,981,980,1,0,0,0,982,31,1,0,0,0,983,
        984,5,421,0,0,984,985,3,12,6,0,985,33,1,0,0,0,986,987,5,422,0,0,
        987,988,3,8,4,0,988,989,5,422,0,0,989,35,1,0,0,0,990,991,5,381,0,
        0,991,37,1,0,0,0,992,997,5,381,0,0,993,994,5,438,0,0,994,996,5,381,
        0,0,995,993,1,0,0,0,996,999,1,0,0,0,997,995,1,0,0,0,997,998,1,0,
        0,0,998,39,1,0,0,0,999,997,1,0,0,0,1000,1002,3,144,72,0,1001,1000,
        1,0,0,0,1001,1002,1,0,0,0,1002,1003,1,0,0,0,1003,1004,5,381,0,0,
        1004,41,1,0,0,0,1005,1007,3,144,72,0,1006,1005,1,0,0,0,1006,1007,
        1,0,0,0,1007,1008,1,0,0,0,1008,1009,3,668,334,0,1009,43,1,0,0,0,
        1010,1011,3,40,20,0,1011,1012,3,668,334,0,1012,45,1,0,0,0,1013,1015,
        3,40,20,0,1014,1016,3,668,334,0,1015,1014,1,0,0,0,1015,1016,1,0,
        0,0,1016,47,1,0,0,0,1017,1019,3,40,20,0,1018,1020,3,660,330,0,1019,
        1018,1,0,0,0,1019,1020,1,0,0,0,1020,49,1,0,0,0,1021,1023,3,144,72,
        0,1022,1021,1,0,0,0,1022,1023,1,0,0,0,1023,1024,1,0,0,0,1024,1026,
        3,38,19,0,1025,1027,3,660,330,0,1026,1025,1,0,0,0,1026,1027,1,0,
        0,0,1027,51,1,0,0,0,1028,1033,5,381,0,0,1029,1030,5,439,0,0,1030,
        1032,5,381,0,0,1031,1029,1,0,0,0,1032,1035,1,0,0,0,1033,1031,1,0,
        0,0,1033,1034,1,0,0,0,1034,53,1,0,0,0,1035,1033,1,0,0,0,1036,1041,
        3,38,19,0,1037,1038,5,439,0,0,1038,1040,3,38,19,0,1039,1037,1,0,
        0,0,1040,1043,1,0,0,0,1041,1039,1,0,0,0,1041,1042,1,0,0,0,1042,55,
        1,0,0,0,1043,1041,1,0,0,0,1044,1049,3,40,20,0,1045,1046,5,439,0,
        0,1046,1048,3,40,20,0,1047,1045,1,0,0,0,1048,1051,1,0,0,0,1049,1047,
        1,0,0,0,1049,1050,1,0,0,0,1050,57,1,0,0,0,1051,1049,1,0,0,0,1052,
        1057,3,42,21,0,1053,1054,5,439,0,0,1054,1056,3,42,21,0,1055,1053,
        1,0,0,0,1056,1059,1,0,0,0,1057,1055,1,0,0,0,1057,1058,1,0,0,0,1058,
        59,1,0,0,0,1059,1057,1,0,0,0,1060,1065,3,44,22,0,1061,1062,5,439,
        0,0,1062,1064,3,44,22,0,1063,1061,1,0,0,0,1064,1067,1,0,0,0,1065,
        1063,1,0,0,0,1065,1066,1,0,0,0,1066,61,1,0,0,0,1067,1065,1,0,0,0,
        1068,1073,3,46,23,0,1069,1070,5,439,0,0,1070,1072,3,46,23,0,1071,
        1069,1,0,0,0,1072,1075,1,0,0,0,1073,1071,1,0,0,0,1073,1074,1,0,0,
        0,1074,63,1,0,0,0,1075,1073,1,0,0,0,1076,1082,3,66,33,0,1077,1082,
        3,74,37,0,1078,1082,3,100,50,0,1079,1082,3,118,59,0,1080,1082,3,
        124,62,0,1081,1076,1,0,0,0,1081,1077,1,0,0,0,1081,1078,1,0,0,0,1081,
        1079,1,0,0,0,1081,1080,1,0,0,0,1082,65,1,0,0,0,1083,1087,3,68,34,
        0,1084,1087,3,70,35,0,1085,1087,3,72,36,0,1086,1083,1,0,0,0,1086,
        1084,1,0,0,0,1086,1085,1,0,0,0,1087,67,1,0,0,0,1088,1090,5,5,0,0,
        1089,1091,3,38,19,0,1090,1089,1,0,0,0,1090,1091,1,0,0,0,1091,69,
        1,0,0,0,1092,1093,5,4,0,0,1093,1094,3,38,19,0,1094,71,1,0,0,0,1095,
        1096,5,6,0,0,1096,1097,3,38,19,0,1097,73,1,0,0,0,1098,1101,3,76,
        38,0,1099,1101,3,88,44,0,1100,1098,1,0,0,0,1100,1099,1,0,0,0,1101,
        75,1,0,0,0,1102,1105,5,7,0,0,1103,1106,3,78,39,0,1104,1106,3,82,
        41,0,1105,1103,1,0,0,0,1105,1104,1,0,0,0,1106,77,1,0,0,0,1107,1108,
        5,423,0,0,1108,1109,5,2,0,0,1109,1110,3,80,40,0,1110,1111,5,3,0,
        0,1111,79,1,0,0,0,1112,1117,3,82,41,0,1113,1114,5,423,0,0,1114,1116,
        3,82,41,0,1115,1113,1,0,0,0,1116,1119,1,0,0,0,1117,1115,1,0,0,0,
        1117,1118,1,0,0,0,1118,81,1,0,0,0,1119,1117,1,0,0,0,1120,1123,3,
        84,42,0,1121,1123,3,86,43,0,1122,1120,1,0,0,0,1122,1121,1,0,0,0,
        1123,83,1,0,0,0,1124,1126,3,96,48,0,1125,1127,3,740,370,0,1126,1125,
        1,0,0,0,1126,1127,1,0,0,0,1127,85,1,0,0,0,1128,1131,3,84,42,0,1129,
        1130,5,439,0,0,1130,1132,3,84,42,0,1131,1129,1,0,0,0,1132,1133,1,
        0,0,0,1133,1131,1,0,0,0,1133,1134,1,0,0,0,1134,87,1,0,0,0,1135,1138,
        5,8,0,0,1136,1139,3,90,45,0,1137,1139,3,94,47,0,1138,1136,1,0,0,
        0,1138,1137,1,0,0,0,1139,89,1,0,0,0,1140,1141,5,423,0,0,1141,1142,
        5,2,0,0,1142,1143,3,92,46,0,1143,1144,5,3,0,0,1144,91,1,0,0,0,1145,
        1150,3,94,47,0,1146,1147,5,423,0,0,1147,1149,3,94,47,0,1148,1146,
        1,0,0,0,1149,1152,1,0,0,0,1150,1148,1,0,0,0,1150,1151,1,0,0,0,1151,
        93,1,0,0,0,1152,1150,1,0,0,0,1153,1154,3,98,49,0,1154,95,1,0,0,0,
        1155,1156,7,0,0,0,1156,97,1,0,0,0,1157,1162,3,96,48,0,1158,1159,
        5,439,0,0,1159,1161,3,96,48,0,1160,1158,1,0,0,0,1161,1164,1,0,0,
        0,1162,1160,1,0,0,0,1162,1163,1,0,0,0,1163,99,1,0,0,0,1164,1162,
        1,0,0,0,1165,1166,3,102,51,0,1166,101,1,0,0,0,1167,1170,5,9,0,0,
        1168,1171,3,104,52,0,1169,1171,3,108,54,0,1170,1168,1,0,0,0,1170,
        1169,1,0,0,0,1171,103,1,0,0,0,1172,1173,5,423,0,0,1173,1174,5,2,
        0,0,1174,1175,3,106,53,0,1175,1176,5,3,0,0,1176,105,1,0,0,0,1177,
        1182,3,108,54,0,1178,1179,5,423,0,0,1179,1181,3,108,54,0,1180,1178,
        1,0,0,0,1181,1184,1,0,0,0,1182,1180,1,0,0,0,1182,1183,1,0,0,0,1183,
        107,1,0,0,0,1184,1182,1,0,0,0,1185,1190,3,110,55,0,1186,1190,3,112,
        56,0,1187,1190,3,114,57,0,1188,1190,3,116,58,0,1189,1185,1,0,0,0,
        1189,1186,1,0,0,0,1189,1187,1,0,0,0,1189,1188,1,0,0,0,1190,109,1,
        0,0,0,1191,1192,3,38,19,0,1192,111,1,0,0,0,1193,1196,3,110,55,0,
        1194,1195,5,439,0,0,1195,1197,3,110,55,0,1196,1194,1,0,0,0,1197,
        1198,1,0,0,0,1198,1196,1,0,0,0,1198,1199,1,0,0,0,1199,113,1,0,0,
        0,1200,1201,3,38,19,0,1201,1202,5,10,0,0,1202,1203,5,381,0,0,1203,
        115,1,0,0,0,1204,1205,3,54,27,0,1205,1206,5,11,0,0,1206,1207,3,38,
        19,0,1207,117,1,0,0,0,1208,1209,3,120,60,0,1209,119,1,0,0,0,1210,
        1211,5,13,0,0,1211,1213,3,50,25,0,1212,1214,3,156,78,0,1213,1212,
        1,0,0,0,1213,1214,1,0,0,0,1214,1215,1,0,0,0,1215,1216,3,122,61,0,
        1216,121,1,0,0,0,1217,1218,3,10,5,0,1218,123,1,0,0,0,1219,1220,3,
        126,63,0,1220,125,1,0,0,0,1221,1224,5,12,0,0,1222,1225,3,128,64,
        0,1223,1225,3,132,66,0,1224,1222,1,0,0,0,1224,1223,1,0,0,0,1225,
        127,1,0,0,0,1226,1227,5,423,0,0,1227,1228,5,2,0,0,1228,1229,3,130,
        65,0,1229,1230,5,3,0,0,1230,129,1,0,0,0,1231,1236,3,132,66,0,1232,
        1233,5,423,0,0,1233,1235,3,132,66,0,1234,1232,1,0,0,0,1235,1238,
        1,0,0,0,1236,1234,1,0,0,0,1236,1237,1,0,0,0,1237,131,1,0,0,0,1238,
        1236,1,0,0,0,1239,1243,3,134,67,0,1240,1243,3,136,68,0,1241,1243,
        3,138,69,0,1242,1239,1,0,0,0,1242,1240,1,0,0,0,1242,1241,1,0,0,0,
        1243,133,1,0,0,0,1244,1245,3,784,392,0,1245,135,1,0,0,0,1246,1249,
        3,134,67,0,1247,1248,5,439,0,0,1248,1250,3,134,67,0,1249,1247,1,
        0,0,0,1250,1251,1,0,0,0,1251,1249,1,0,0,0,1251,1252,1,0,0,0,1252,
        137,1,0,0,0,1253,1254,3,786,393,0,1254,1255,5,10,0,0,1255,1256,3,
        46,23,0,1256,139,1,0,0,0,1257,1259,3,142,71,0,1258,1257,1,0,0,0,
        1259,1260,1,0,0,0,1260,1258,1,0,0,0,1260,1261,1,0,0,0,1261,1262,
        1,0,0,0,1262,1263,3,140,70,0,1263,1268,1,0,0,0,1264,1268,3,150,75,
        0,1265,1268,3,196,98,0,1266,1268,3,372,186,0,1267,1258,1,0,0,0,1267,
        1264,1,0,0,0,1267,1265,1,0,0,0,1267,1266,1,0,0,0,1268,141,1,0,0,
        0,1269,1273,3,144,72,0,1270,1273,3,146,73,0,1271,1273,3,148,74,0,
        1272,1269,1,0,0,0,1272,1270,1,0,0,0,1272,1271,1,0,0,0,1273,143,1,
        0,0,0,1274,1281,3,648,324,0,1275,1277,5,423,0,0,1276,1275,1,0,0,
        0,1276,1277,1,0,0,0,1277,1278,1,0,0,0,1278,1280,3,648,324,0,1279,
        1276,1,0,0,0,1280,1283,1,0,0,0,1281,1279,1,0,0,0,1281,1282,1,0,0,
        0,1282,1285,1,0,0,0,1283,1281,1,0,0,0,1284,1286,5,423,0,0,1285,1284,
        1,0,0,0,1285,1286,1,0,0,0,1286,145,1,0,0,0,1287,1288,5,304,0,0,1288,
        1289,3,662,331,0,1289,1291,5,305,0,0,1290,1292,5,423,0,0,1291,1290,
        1,0,0,0,1291,1292,1,0,0,0,1292,147,1,0,0,0,1293,1294,7,1,0,0,1294,
        149,1,0,0,0,1295,1296,3,148,74,0,1296,1297,5,423,0,0,1297,1298,5,
        2,0,0,1298,1303,3,140,70,0,1299,1300,5,423,0,0,1300,1302,3,140,70,
        0,1301,1299,1,0,0,0,1302,1305,1,0,0,0,1303,1301,1,0,0,0,1303,1304,
        1,0,0,0,1304,1306,1,0,0,0,1305,1303,1,0,0,0,1306,1307,5,3,0,0,1307,
        151,1,0,0,0,1308,1310,5,40,0,0,1309,1311,3,148,74,0,1310,1309,1,
        0,0,0,1310,1311,1,0,0,0,1311,1312,1,0,0,0,1312,1320,3,668,334,0,
        1313,1315,5,439,0,0,1314,1316,3,148,74,0,1315,1314,1,0,0,0,1315,
        1316,1,0,0,0,1316,1317,1,0,0,0,1317,1319,3,668,334,0,1318,1313,1,
        0,0,0,1319,1322,1,0,0,0,1320,1318,1,0,0,0,1320,1321,1,0,0,0,1321,
        153,1,0,0,0,1322,1320,1,0,0,0,1323,1324,5,41,0,0,1324,1325,3,666,
        333,0,1325,155,1,0,0,0,1326,1327,5,42,0,0,1327,1328,3,666,333,0,
        1328,157,1,0,0,0,1329,1333,5,28,0,0,1330,1331,5,27,0,0,1331,1333,
        3,666,333,0,1332,1329,1,0,0,0,1332,1330,1,0,0,0,1333,159,1,0,0,0,
        1334,1336,5,432,0,0,1335,1337,3,162,81,0,1336,1335,1,0,0,0,1336,
        1337,1,0,0,0,1337,1338,1,0,0,0,1338,1339,5,433,0,0,1339,161,1,0,
        0,0,1340,1345,3,164,82,0,1341,1342,5,439,0,0,1342,1344,3,164,82,
        0,1343,1341,1,0,0,0,1344,1347,1,0,0,0,1345,1343,1,0,0,0,1345,1346,
        1,0,0,0,1346,163,1,0,0,0,1347,1345,1,0,0,0,1348,1349,5,381,0,0,1349,
        1351,5,353,0,0,1350,1348,1,0,0,0,1350,1351,1,0,0,0,1351,1352,1,0,
        0,0,1352,1353,3,892,446,0,1353,165,1,0,0,0,1354,1356,5,432,0,0,1355,
        1357,3,168,84,0,1356,1355,1,0,0,0,1356,1357,1,0,0,0,1357,1358,1,
        0,0,0,1358,1359,5,433,0,0,1359,167,1,0,0,0,1360,1365,3,170,85,0,
        1361,1362,5,439,0,0,1362,1364,3,170,85,0,1363,1361,1,0,0,0,1364,
        1367,1,0,0,0,1365,1363,1,0,0,0,1365,1366,1,0,0,0,1366,169,1,0,0,
        0,1367,1365,1,0,0,0,1368,1370,3,172,86,0,1369,1368,1,0,0,0,1369,
        1370,1,0,0,0,1370,1372,1,0,0,0,1371,1373,3,144,72,0,1372,1371,1,
        0,0,0,1372,1373,1,0,0,0,1373,1375,1,0,0,0,1374,1376,3,174,87,0,1375,
        1374,1,0,0,0,1375,1376,1,0,0,0,1376,1377,1,0,0,0,1377,1382,5,381,
        0,0,1378,1380,3,176,88,0,1379,1378,1,0,0,0,1379,1380,1,0,0,0,1380,
        1381,1,0,0,0,1381,1383,3,668,334,0,1382,1379,1,0,0,0,1382,1383,1,
        0,0,0,1383,1386,1,0,0,0,1384,1385,5,353,0,0,1385,1387,3,892,446,
        0,1386,1384,1,0,0,0,1386,1387,1,0,0,0,1387,171,1,0,0,0,1388,1395,
        5,20,0,0,1389,1395,5,31,0,0,1390,1395,5,112,0,0,1391,1392,5,112,
        0,0,1392,1395,5,26,0,0,1393,1395,5,26,0,0,1394,1388,1,0,0,0,1394,
        1389,1,0,0,0,1394,1390,1,0,0,0,1394,1391,1,0,0,0,1394,1393,1,0,0,
        0,1395,173,1,0,0,0,1396,1397,7,2,0,0,1397,175,1,0,0,0,1398,1399,
        7,3,0,0,1399,177,1,0,0,0,1400,1407,3,668,334,0,1401,1407,3,666,333,
        0,1402,1403,5,432,0,0,1403,1404,3,666,333,0,1404,1405,5,433,0,0,
        1405,1407,1,0,0,0,1406,1400,1,0,0,0,1406,1401,1,0,0,0,1406,1402,
        1,0,0,0,1407,179,1,0,0,0,1408,1413,3,184,92,0,1409,1413,3,188,94,
        0,1410,1413,3,190,95,0,1411,1413,3,182,91,0,1412,1408,1,0,0,0,1412,
        1409,1,0,0,0,1412,1410,1,0,0,0,1412,1411,1,0,0,0,1413,181,1,0,0,
        0,1414,1415,3,10,5,0,1415,183,1,0,0,0,1416,1417,5,441,0,0,1417,1418,
        3,186,93,0,1418,185,1,0,0,0,1419,1420,7,4,0,0,1420,187,1,0,0,0,1421,
        1422,5,340,0,0,1422,1423,3,892,446,0,1423,189,1,0,0,0,1424,1426,
        3,192,96,0,1425,1424,1,0,0,0,1426,1427,1,0,0,0,1427,1425,1,0,0,0,
        1427,1428,1,0,0,0,1428,1430,1,0,0,0,1429,1431,3,194,97,0,1430,1429,
        1,0,0,0,1430,1431,1,0,0,0,1431,191,1,0,0,0,1432,1433,5,423,0,0,1433,
        1434,5,451,0,0,1434,1435,3,890,445,0,1435,1436,5,340,0,0,1436,1437,
        3,892,446,0,1437,193,1,0,0,0,1438,1439,5,423,0,0,1439,1442,5,451,
        0,0,1440,1441,5,51,0,0,1441,1443,5,340,0,0,1442,1440,1,0,0,0,1442,
        1443,1,0,0,0,1443,1444,1,0,0,0,1444,1445,3,892,446,0,1445,195,1,
        0,0,0,1446,1465,3,198,99,0,1447,1465,3,212,106,0,1448,1465,3,228,
        114,0,1449,1465,3,244,122,0,1450,1465,3,260,130,0,1451,1465,3,264,
        132,0,1452,1465,3,268,134,0,1453,1465,3,272,136,0,1454,1465,3,276,
        138,0,1455,1465,3,280,140,0,1456,1465,3,284,142,0,1457,1465,3,292,
        146,0,1458,1465,3,298,149,0,1459,1465,3,318,159,0,1460,1465,3,340,
        170,0,1461,1465,3,346,173,0,1462,1465,3,352,176,0,1463,1465,3,366,
        183,0,1464,1446,1,0,0,0,1464,1447,1,0,0,0,1464,1448,1,0,0,0,1464,
        1449,1,0,0,0,1464,1450,1,0,0,0,1464,1451,1,0,0,0,1464,1452,1,0,0,
        0,1464,1453,1,0,0,0,1464,1454,1,0,0,0,1464,1455,1,0,0,0,1464,1456,
        1,0,0,0,1464,1457,1,0,0,0,1464,1458,1,0,0,0,1464,1459,1,0,0,0,1464,
        1460,1,0,0,0,1464,1461,1,0,0,0,1464,1462,1,0,0,0,1464,1463,1,0,0,
        0,1465,197,1,0,0,0,1466,1467,3,200,100,0,1467,199,1,0,0,0,1468,1471,
        5,17,0,0,1469,1472,3,202,101,0,1470,1472,3,206,103,0,1471,1469,1,
        0,0,0,1471,1470,1,0,0,0,1472,201,1,0,0,0,1473,1474,5,423,0,0,1474,
        1475,5,2,0,0,1475,1476,3,204,102,0,1476,1477,5,3,0,0,1477,203,1,
        0,0,0,1478,1483,3,206,103,0,1479,1480,5,423,0,0,1480,1482,3,206,
        103,0,1481,1479,1,0,0,0,1482,1485,1,0,0,0,1483,1481,1,0,0,0,1483,
        1484,1,0,0,0,1484,205,1,0,0,0,1485,1483,1,0,0,0,1486,1489,3,208,
        104,0,1487,1489,3,210,105,0,1488,1486,1,0,0,0,1488,1487,1,0,0,0,
        1489,207,1,0,0,0,1490,1491,3,48,24,0,1491,1492,7,5,0,0,1492,1493,
        3,668,334,0,1493,209,1,0,0,0,1494,1496,3,48,24,0,1495,1497,3,668,
        334,0,1496,1495,1,0,0,0,1496,1497,1,0,0,0,1497,1498,1,0,0,0,1498,
        1499,5,441,0,0,1499,1500,3,774,387,0,1500,211,1,0,0,0,1501,1502,
        3,214,107,0,1502,213,1,0,0,0,1503,1506,5,18,0,0,1504,1507,3,216,
        108,0,1505,1507,3,220,110,0,1506,1504,1,0,0,0,1506,1505,1,0,0,0,
        1507,215,1,0,0,0,1508,1509,5,423,0,0,1509,1510,5,2,0,0,1510,1511,
        3,218,109,0,1511,1512,5,3,0,0,1512,217,1,0,0,0,1513,1518,3,220,110,
        0,1514,1515,5,423,0,0,1515,1517,3,220,110,0,1516,1514,1,0,0,0,1517,
        1520,1,0,0,0,1518,1516,1,0,0,0,1518,1519,1,0,0,0,1519,219,1,0,0,
        0,1520,1518,1,0,0,0,1521,1525,3,222,111,0,1522,1525,3,224,112,0,
        1523,1525,3,226,113,0,1524,1521,1,0,0,0,1524,1522,1,0,0,0,1524,1523,
        1,0,0,0,1525,221,1,0,0,0,1526,1527,3,46,23,0,1527,1528,3,640,320,
        0,1528,1529,3,892,446,0,1529,223,1,0,0,0,1530,1535,3,222,111,0,1531,
        1532,5,439,0,0,1532,1533,3,222,111,0,1533,1534,5,2,0,0,1534,1536,
        1,0,0,0,1535,1531,1,0,0,0,1536,1537,1,0,0,0,1537,1535,1,0,0,0,1537,
        1538,1,0,0,0,1538,225,1,0,0,0,1539,1540,5,432,0,0,1540,1541,3,62,
        31,0,1541,1542,5,433,0,0,1542,1543,3,642,321,0,1543,1544,3,890,445,
        0,1544,227,1,0,0,0,1545,1546,3,230,115,0,1546,229,1,0,0,0,1547,1550,
        5,19,0,0,1548,1551,3,232,116,0,1549,1551,3,236,118,0,1550,1548,1,
        0,0,0,1550,1549,1,0,0,0,1551,231,1,0,0,0,1552,1553,5,423,0,0,1553,
        1554,5,2,0,0,1554,1555,3,234,117,0,1555,1556,5,3,0,0,1556,233,1,
        0,0,0,1557,1562,3,236,118,0,1558,1559,5,423,0,0,1559,1561,3,236,
        118,0,1560,1558,1,0,0,0,1561,1564,1,0,0,0,1562,1560,1,0,0,0,1562,
        1563,1,0,0,0,1563,235,1,0,0,0,1564,1562,1,0,0,0,1565,1569,3,238,
        119,0,1566,1569,3,240,120,0,1567,1569,3,242,121,0,1568,1565,1,0,
        0,0,1568,1566,1,0,0,0,1568,1567,1,0,0,0,1569,237,1,0,0,0,1570,1574,
        3,46,23,0,1571,1572,3,640,320,0,1572,1573,3,892,446,0,1573,1575,
        1,0,0,0,1574,1571,1,0,0,0,1574,1575,1,0,0,0,1575,239,1,0,0,0,1576,
        1579,3,238,119,0,1577,1578,5,439,0,0,1578,1580,3,238,119,0,1579,
        1577,1,0,0,0,1580,1581,1,0,0,0,1581,1579,1,0,0,0,1581,1582,1,0,0,
        0,1582,241,1,0,0,0,1583,1584,5,432,0,0,1584,1585,3,62,31,0,1585,
        1586,5,433,0,0,1586,1587,3,642,321,0,1587,1588,3,890,445,0,1588,
        243,1,0,0,0,1589,1590,3,246,123,0,1590,245,1,0,0,0,1591,1594,5,20,
        0,0,1592,1595,3,248,124,0,1593,1595,3,252,126,0,1594,1592,1,0,0,
        0,1594,1593,1,0,0,0,1595,247,1,0,0,0,1596,1597,5,423,0,0,1597,1598,
        5,2,0,0,1598,1599,3,250,125,0,1599,1600,5,3,0,0,1600,249,1,0,0,0,
        1601,1606,3,252,126,0,1602,1603,5,423,0,0,1603,1605,3,252,126,0,
        1604,1602,1,0,0,0,1605,1608,1,0,0,0,1606,1604,1,0,0,0,1606,1607,
        1,0,0,0,1607,251,1,0,0,0,1608,1606,1,0,0,0,1609,1613,3,254,127,0,
        1610,1613,3,256,128,0,1611,1613,3,258,129,0,1612,1609,1,0,0,0,1612,
        1610,1,0,0,0,1612,1611,1,0,0,0,1613,253,1,0,0,0,1614,1618,3,46,23,
        0,1615,1616,3,640,320,0,1616,1617,3,892,446,0,1617,1619,1,0,0,0,
        1618,1615,1,0,0,0,1618,1619,1,0,0,0,1619,255,1,0,0,0,1620,1623,3,
        254,127,0,1621,1622,5,439,0,0,1622,1624,3,254,127,0,1623,1621,1,
        0,0,0,1624,1625,1,0,0,0,1625,1623,1,0,0,0,1625,1626,1,0,0,0,1626,
        257,1,0,0,0,1627,1628,5,432,0,0,1628,1629,3,62,31,0,1629,1630,5,
        433,0,0,1630,1631,3,642,321,0,1631,1632,3,890,445,0,1632,259,1,0,
        0,0,1633,1634,3,262,131,0,1634,261,1,0,0,0,1635,1636,5,21,0,0,1636,
        1637,3,50,25,0,1637,1638,3,166,83,0,1638,1640,3,178,89,0,1639,1641,
        3,158,79,0,1640,1639,1,0,0,0,1640,1641,1,0,0,0,1641,1643,1,0,0,0,
        1642,1644,3,180,90,0,1643,1642,1,0,0,0,1643,1644,1,0,0,0,1644,263,
        1,0,0,0,1645,1646,3,266,133,0,1646,265,1,0,0,0,1647,1648,5,22,0,
        0,1648,1649,3,50,25,0,1649,1651,3,166,83,0,1650,1652,3,158,79,0,
        1651,1650,1,0,0,0,1651,1652,1,0,0,0,1652,1653,1,0,0,0,1653,1654,
        3,180,90,0,1654,267,1,0,0,0,1655,1656,3,270,135,0,1656,269,1,0,0,
        0,1657,1658,5,30,0,0,1658,1659,3,50,25,0,1659,1661,3,166,83,0,1660,
        1662,3,156,78,0,1661,1660,1,0,0,0,1661,1662,1,0,0,0,1662,1664,1,
        0,0,0,1663,1665,3,158,79,0,1664,1663,1,0,0,0,1664,1665,1,0,0,0,1665,
        1666,1,0,0,0,1666,1667,3,180,90,0,1667,271,1,0,0,0,1668,1669,3,274,
        137,0,1669,273,1,0,0,0,1670,1671,5,23,0,0,1671,1672,3,50,25,0,1672,
        1673,3,166,83,0,1673,1675,3,178,89,0,1674,1676,3,158,79,0,1675,1674,
        1,0,0,0,1675,1676,1,0,0,0,1676,1678,1,0,0,0,1677,1679,3,180,90,0,
        1678,1677,1,0,0,0,1678,1679,1,0,0,0,1679,275,1,0,0,0,1680,1681,3,
        278,139,0,1681,277,1,0,0,0,1682,1683,5,24,0,0,1683,1684,3,50,25,
        0,1684,1685,3,166,83,0,1685,1687,3,178,89,0,1686,1688,3,158,79,0,
        1687,1686,1,0,0,0,1687,1688,1,0,0,0,1688,1690,1,0,0,0,1689,1691,
        3,180,90,0,1690,1689,1,0,0,0,1690,1691,1,0,0,0,1691,279,1,0,0,0,
        1692,1693,3,282,141,0,1693,281,1,0,0,0,1694,1695,5,25,0,0,1695,1696,
        3,50,25,0,1696,1698,3,166,83,0,1697,1699,3,158,79,0,1698,1697,1,
        0,0,0,1698,1699,1,0,0,0,1699,1701,1,0,0,0,1700,1702,3,180,90,0,1701,
        1700,1,0,0,0,1701,1702,1,0,0,0,1702,283,1,0,0,0,1703,1704,3,286,
        143,0,1704,285,1,0,0,0,1705,1706,5,32,0,0,1706,1707,3,288,144,0,
        1707,1708,3,166,83,0,1708,1710,3,178,89,0,1709,1711,3,158,79,0,1710,
        1709,1,0,0,0,1710,1711,1,0,0,0,1711,1713,1,0,0,0,1712,1714,3,180,
        90,0,1713,1712,1,0,0,0,1713,1714,1,0,0,0,1714,287,1,0,0,0,1715,1718,
        3,50,25,0,1716,1718,3,290,145,0,1717,1715,1,0,0,0,1717,1716,1,0,
        0,0,1718,289,1,0,0,0,1719,1721,3,144,72,0,1720,1719,1,0,0,0,1720,
        1721,1,0,0,0,1721,1722,1,0,0,0,1722,1724,3,646,323,0,1723,1725,3,
        660,330,0,1724,1723,1,0,0,0,1724,1725,1,0,0,0,1725,291,1,0,0,0,1726,
        1727,3,294,147,0,1727,293,1,0,0,0,1728,1729,5,33,0,0,1729,1730,3,
        50,25,0,1730,1731,3,296,148,0,1731,1733,3,178,89,0,1732,1734,3,158,
        79,0,1733,1732,1,0,0,0,1733,1734,1,0,0,0,1734,1736,1,0,0,0,1735,
        1737,3,180,90,0,1736,1735,1,0,0,0,1736,1737,1,0,0,0,1737,295,1,0,
        0,0,1738,1740,5,434,0,0,1739,1741,3,168,84,0,1740,1739,1,0,0,0,1740,
        1741,1,0,0,0,1741,1742,1,0,0,0,1742,1743,5,435,0,0,1743,297,1,0,
        0,0,1744,1745,3,300,150,0,1745,299,1,0,0,0,1746,1747,5,34,0,0,1747,
        1749,3,50,25,0,1748,1750,3,166,83,0,1749,1748,1,0,0,0,1749,1750,
        1,0,0,0,1750,1752,1,0,0,0,1751,1753,3,302,151,0,1752,1751,1,0,0,
        0,1752,1753,1,0,0,0,1753,1755,1,0,0,0,1754,1756,3,156,78,0,1755,
        1754,1,0,0,0,1755,1756,1,0,0,0,1756,1757,1,0,0,0,1757,1758,3,304,
        152,0,1758,301,1,0,0,0,1759,1760,3,668,334,0,1760,303,1,0,0,0,1761,
        1764,3,306,153,0,1762,1764,3,308,154,0,1763,1761,1,0,0,0,1763,1762,
        1,0,0,0,1764,305,1,0,0,0,1765,1766,5,441,0,0,1766,1767,3,316,158,
        0,1767,307,1,0,0,0,1768,1769,5,423,0,0,1769,1770,5,2,0,0,1770,1771,
        3,310,155,0,1771,1772,5,3,0,0,1772,309,1,0,0,0,1773,1778,3,312,156,
        0,1774,1775,5,423,0,0,1775,1777,3,312,156,0,1776,1774,1,0,0,0,1777,
        1780,1,0,0,0,1778,1776,1,0,0,0,1778,1779,1,0,0,0,1779,311,1,0,0,
        0,1780,1778,1,0,0,0,1781,1785,3,12,6,0,1782,1785,3,314,157,0,1783,
        1785,3,316,158,0,1784,1781,1,0,0,0,1784,1782,1,0,0,0,1784,1783,1,
        0,0,0,1785,313,1,0,0,0,1786,1788,3,40,20,0,1787,1789,3,160,80,0,
        1788,1787,1,0,0,0,1788,1789,1,0,0,0,1789,1792,1,0,0,0,1790,1791,
        5,353,0,0,1791,1793,3,892,446,0,1792,1790,1,0,0,0,1792,1793,1,0,
        0,0,1793,315,1,0,0,0,1794,1799,3,314,157,0,1795,1796,5,439,0,0,1796,
        1798,3,314,157,0,1797,1795,1,0,0,0,1798,1801,1,0,0,0,1799,1797,1,
        0,0,0,1799,1800,1,0,0,0,1800,317,1,0,0,0,1801,1799,1,0,0,0,1802,
        1803,3,320,160,0,1803,319,1,0,0,0,1804,1805,5,35,0,0,1805,1807,3,
        50,25,0,1806,1808,3,156,78,0,1807,1806,1,0,0,0,1807,1808,1,0,0,0,
        1808,1809,1,0,0,0,1809,1810,3,322,161,0,1810,321,1,0,0,0,1811,1814,
        3,324,162,0,1812,1814,3,326,163,0,1813,1811,1,0,0,0,1813,1812,1,
        0,0,0,1814,323,1,0,0,0,1815,1816,5,441,0,0,1816,1817,3,336,168,0,
        1817,325,1,0,0,0,1818,1819,5,423,0,0,1819,1820,5,2,0,0,1820,1821,
        3,328,164,0,1821,1822,5,3,0,0,1822,327,1,0,0,0,1823,1828,3,330,165,
        0,1824,1825,5,423,0,0,1825,1827,3,330,165,0,1826,1824,1,0,0,0,1827,
        1830,1,0,0,0,1828,1826,1,0,0,0,1828,1829,1,0,0,0,1829,329,1,0,0,
        0,1830,1828,1,0,0,0,1831,1836,3,12,6,0,1832,1836,3,332,166,0,1833,
        1836,3,336,168,0,1834,1836,3,338,169,0,1835,1831,1,0,0,0,1835,1832,
        1,0,0,0,1835,1833,1,0,0,0,1835,1834,1,0,0,0,1836,331,1,0,0,0,1837,
        1839,3,46,23,0,1838,1840,3,334,167,0,1839,1838,1,0,0,0,1839,1840,
        1,0,0,0,1840,1843,1,0,0,0,1841,1842,5,353,0,0,1842,1844,3,892,446,
        0,1843,1841,1,0,0,0,1843,1844,1,0,0,0,1844,333,1,0,0,0,1845,1846,
        3,768,384,0,1846,335,1,0,0,0,1847,1850,3,332,166,0,1848,1849,5,439,
        0,0,1849,1851,3,332,166,0,1850,1848,1,0,0,0,1851,1852,1,0,0,0,1852,
        1850,1,0,0,0,1852,1853,1,0,0,0,1853,337,1,0,0,0,1854,1855,3,40,20,
        0,1855,1856,5,35,0,0,1856,1857,3,326,163,0,1857,339,1,0,0,0,1858,
        1859,3,342,171,0,1859,341,1,0,0,0,1860,1861,5,36,0,0,1861,1863,3,
        50,25,0,1862,1864,3,152,76,0,1863,1862,1,0,0,0,1863,1864,1,0,0,0,
        1864,1865,1,0,0,0,1865,1866,3,344,172,0,1866,343,1,0,0,0,1867,1868,
        3,10,5,0,1868,345,1,0,0,0,1869,1870,3,348,174,0,1870,347,1,0,0,0,
        1871,1872,5,37,0,0,1872,1874,3,50,25,0,1873,1875,3,154,77,0,1874,
        1873,1,0,0,0,1874,1875,1,0,0,0,1875,1877,1,0,0,0,1876,1878,3,156,
        78,0,1877,1876,1,0,0,0,1877,1878,1,0,0,0,1878,1879,1,0,0,0,1879,
        1880,3,350,175,0,1880,349,1,0,0,0,1881,1882,3,10,5,0,1882,351,1,
        0,0,0,1883,1884,3,354,177,0,1884,353,1,0,0,0,1885,1886,5,38,0,0,
        1886,1888,3,50,25,0,1887,1889,3,152,76,0,1888,1887,1,0,0,0,1888,
        1889,1,0,0,0,1889,1891,1,0,0,0,1890,1892,3,154,77,0,1891,1890,1,
        0,0,0,1891,1892,1,0,0,0,1892,1894,1,0,0,0,1893,1895,3,156,78,0,1894,
        1893,1,0,0,0,1894,1895,1,0,0,0,1895,1896,1,0,0,0,1896,1897,3,356,
        178,0,1897,355,1,0,0,0,1898,1901,3,358,179,0,1899,1901,3,364,182,
        0,1900,1898,1,0,0,0,1900,1899,1,0,0,0,1901,357,1,0,0,0,1902,1903,
        5,441,0,0,1903,1904,3,360,180,0,1904,359,1,0,0,0,1905,1910,3,362,
        181,0,1906,1907,5,439,0,0,1907,1909,3,362,181,0,1908,1906,1,0,0,
        0,1909,1912,1,0,0,0,1910,1908,1,0,0,0,1910,1911,1,0,0,0,1911,361,
        1,0,0,0,1912,1910,1,0,0,0,1913,1915,3,46,23,0,1914,1916,3,334,167,
        0,1915,1914,1,0,0,0,1915,1916,1,0,0,0,1916,1919,1,0,0,0,1917,1918,
        5,353,0,0,1918,1920,3,892,446,0,1919,1917,1,0,0,0,1919,1920,1,0,
        0,0,1920,363,1,0,0,0,1921,1922,3,10,5,0,1922,365,1,0,0,0,1923,1924,
        3,368,184,0,1924,367,1,0,0,0,1925,1926,5,39,0,0,1926,1928,3,50,25,
        0,1927,1929,3,152,76,0,1928,1927,1,0,0,0,1928,1929,1,0,0,0,1929,
        1931,1,0,0,0,1930,1932,3,154,77,0,1931,1930,1,0,0,0,1931,1932,1,
        0,0,0,1932,1934,1,0,0,0,1933,1935,3,156,78,0,1934,1933,1,0,0,0,1934,
        1935,1,0,0,0,1935,1936,1,0,0,0,1936,1937,3,370,185,0,1937,369,1,
        0,0,0,1938,1939,3,10,5,0,1939,371,1,0,0,0,1940,1945,3,374,187,0,
        1941,1945,3,384,192,0,1942,1945,3,388,194,0,1943,1945,3,394,197,
        0,1944,1940,1,0,0,0,1944,1941,1,0,0,0,1944,1942,1,0,0,0,1944,1943,
        1,0,0,0,1945,373,1,0,0,0,1946,1947,3,376,188,0,1947,375,1,0,0,0,
        1948,1949,5,43,0,0,1949,1951,3,166,83,0,1950,1952,3,378,189,0,1951,
        1950,1,0,0,0,1951,1952,1,0,0,0,1952,1954,1,0,0,0,1953,1955,3,158,
        79,0,1954,1953,1,0,0,0,1954,1955,1,0,0,0,1955,1956,1,0,0,0,1956,
        1957,3,180,90,0,1957,377,1,0,0,0,1958,1959,5,436,0,0,1959,1960,3,
        380,190,0,1960,1961,5,437,0,0,1961,379,1,0,0,0,1962,1967,3,382,191,
        0,1963,1964,5,439,0,0,1964,1966,3,382,191,0,1965,1963,1,0,0,0,1966,
        1969,1,0,0,0,1967,1965,1,0,0,0,1967,1968,1,0,0,0,1968,381,1,0,0,
        0,1969,1967,1,0,0,0,1970,1971,3,38,19,0,1971,1972,5,441,0,0,1972,
        1974,1,0,0,0,1973,1970,1,0,0,0,1973,1974,1,0,0,0,1974,1975,1,0,0,
        0,1975,1976,3,892,446,0,1976,383,1,0,0,0,1977,1978,3,386,193,0,1978,
        385,1,0,0,0,1979,1981,5,44,0,0,1980,1982,3,166,83,0,1981,1980,1,
        0,0,0,1981,1982,1,0,0,0,1982,1984,1,0,0,0,1983,1985,3,158,79,0,1984,
        1983,1,0,0,0,1984,1985,1,0,0,0,1985,1986,1,0,0,0,1986,1987,3,180,
        90,0,1987,387,1,0,0,0,1988,1989,3,390,195,0,1989,389,1,0,0,0,1990,
        1991,5,45,0,0,1991,1993,3,50,25,0,1992,1994,3,668,334,0,1993,1992,
        1,0,0,0,1993,1994,1,0,0,0,1994,1996,1,0,0,0,1995,1997,3,334,167,
        0,1996,1995,1,0,0,0,1996,1997,1,0,0,0,1997,2000,1,0,0,0,1998,1999,
        5,353,0,0,1999,2001,3,892,446,0,2000,1998,1,0,0,0,2000,2001,1,0,
        0,0,2001,2002,1,0,0,0,2002,2003,3,392,196,0,2003,391,1,0,0,0,2004,
        2005,3,10,5,0,2005,393,1,0,0,0,2006,2009,3,396,198,0,2007,2009,3,
        398,199,0,2008,2006,1,0,0,0,2008,2007,1,0,0,0,2009,395,1,0,0,0,2010,
        2012,5,46,0,0,2011,2013,3,50,25,0,2012,2011,1,0,0,0,2012,2013,1,
        0,0,0,2013,2015,1,0,0,0,2014,2016,3,166,83,0,2015,2014,1,0,0,0,2015,
        2016,1,0,0,0,2016,2018,1,0,0,0,2017,2019,3,158,79,0,2018,2017,1,
        0,0,0,2018,2019,1,0,0,0,2019,2020,1,0,0,0,2020,2021,3,180,90,0,2021,
        397,1,0,0,0,2022,2024,5,47,0,0,2023,2025,3,50,25,0,2024,2023,1,0,
        0,0,2024,2025,1,0,0,0,2025,2027,1,0,0,0,2026,2028,3,166,83,0,2027,
        2026,1,0,0,0,2027,2028,1,0,0,0,2028,2030,1,0,0,0,2029,2031,3,158,
        79,0,2030,2029,1,0,0,0,2030,2031,1,0,0,0,2031,2032,1,0,0,0,2032,
        2033,3,180,90,0,2033,399,1,0,0,0,2034,2035,3,36,18,0,2035,2036,5,
        441,0,0,2036,2045,1,0,0,0,2037,2038,3,36,18,0,2038,2039,5,441,0,
        0,2039,2040,3,400,200,0,2040,2045,1,0,0,0,2041,2045,3,408,204,0,
        2042,2045,3,462,231,0,2043,2045,3,546,273,0,2044,2034,1,0,0,0,2044,
        2037,1,0,0,0,2044,2041,1,0,0,0,2044,2042,1,0,0,0,2044,2043,1,0,0,
        0,2045,401,1,0,0,0,2046,2047,5,423,0,0,2047,2048,5,2,0,0,2048,2049,
        3,404,202,0,2049,2050,5,3,0,0,2050,403,1,0,0,0,2051,2056,3,400,200,
        0,2052,2053,5,423,0,0,2053,2055,3,400,200,0,2054,2052,1,0,0,0,2055,
        2058,1,0,0,0,2056,2054,1,0,0,0,2056,2057,1,0,0,0,2057,405,1,0,0,
        0,2058,2056,1,0,0,0,2059,2060,5,340,0,0,2060,2065,3,892,446,0,2061,
        2062,5,62,0,0,2062,2065,3,408,204,0,2063,2065,3,402,201,0,2064,2059,
        1,0,0,0,2064,2061,1,0,0,0,2064,2063,1,0,0,0,2065,407,1,0,0,0,2066,
        2067,6,204,-1,0,2067,2074,3,414,207,0,2068,2074,3,422,211,0,2069,
        2074,3,436,218,0,2070,2074,3,454,227,0,2071,2074,3,410,205,0,2072,
        2074,3,412,206,0,2073,2066,1,0,0,0,2073,2068,1,0,0,0,2073,2069,1,
        0,0,0,2073,2070,1,0,0,0,2073,2071,1,0,0,0,2073,2072,1,0,0,0,2074,
        2090,1,0,0,0,2075,2076,10,10,0,0,2076,2077,3,630,315,0,2077,2078,
        3,400,200,0,2078,2089,1,0,0,0,2079,2080,10,9,0,0,2080,2081,5,57,
        0,0,2081,2089,3,400,200,0,2082,2083,10,8,0,0,2083,2084,5,58,0,0,
        2084,2089,3,892,446,0,2085,2086,10,7,0,0,2086,2087,5,59,0,0,2087,
        2089,3,892,446,0,2088,2075,1,0,0,0,2088,2079,1,0,0,0,2088,2082,1,
        0,0,0,2088,2085,1,0,0,0,2089,2092,1,0,0,0,2090,2088,1,0,0,0,2090,
        2091,1,0,0,0,2091,409,1,0,0,0,2092,2090,1,0,0,0,2093,2094,3,890,
        445,0,2094,411,1,0,0,0,2095,2096,5,290,0,0,2096,413,1,0,0,0,2097,
        2098,5,19,0,0,2098,2103,3,414,207,0,2099,2103,3,416,208,0,2100,2103,
        3,418,209,0,2101,2103,3,420,210,0,2102,2097,1,0,0,0,2102,2099,1,
        0,0,0,2102,2100,1,0,0,0,2102,2101,1,0,0,0,2103,415,1,0,0,0,2104,
        2105,3,868,434,0,2105,2106,3,640,320,0,2106,2107,3,892,446,0,2107,
        417,1,0,0,0,2108,2111,3,416,208,0,2109,2110,5,439,0,0,2110,2112,
        3,416,208,0,2111,2109,1,0,0,0,2112,2113,1,0,0,0,2113,2111,1,0,0,
        0,2113,2114,1,0,0,0,2114,419,1,0,0,0,2115,2116,3,866,433,0,2116,
        2117,3,642,321,0,2117,2118,3,890,445,0,2118,421,1,0,0,0,2119,2120,
        3,424,212,0,2120,2121,3,422,211,0,2121,2128,1,0,0,0,2122,2128,3,
        426,213,0,2123,2128,3,428,214,0,2124,2128,3,430,215,0,2125,2128,
        3,432,216,0,2126,2128,3,434,217,0,2127,2119,1,0,0,0,2127,2122,1,
        0,0,0,2127,2123,1,0,0,0,2127,2124,1,0,0,0,2127,2125,1,0,0,0,2127,
        2126,1,0,0,0,2128,423,1,0,0,0,2129,2130,5,87,0,0,2130,2131,3,890,
        445,0,2131,425,1,0,0,0,2132,2134,5,89,0,0,2133,2135,3,890,445,0,
        2134,2133,1,0,0,0,2134,2135,1,0,0,0,2135,2137,1,0,0,0,2136,2138,
        5,439,0,0,2137,2136,1,0,0,0,2137,2138,1,0,0,0,2138,427,1,0,0,0,2139,
        2141,5,88,0,0,2140,2142,3,890,445,0,2141,2140,1,0,0,0,2141,2142,
        1,0,0,0,2142,2144,1,0,0,0,2143,2145,5,439,0,0,2144,2143,1,0,0,0,
        2144,2145,1,0,0,0,2145,429,1,0,0,0,2146,2148,5,90,0,0,2147,2149,
        3,890,445,0,2148,2147,1,0,0,0,2148,2149,1,0,0,0,2149,431,1,0,0,0,
        2150,2152,5,91,0,0,2151,2153,3,890,445,0,2152,2151,1,0,0,0,2152,
        2153,1,0,0,0,2153,433,1,0,0,0,2154,2155,5,92,0,0,2155,2156,3,890,
        445,0,2156,435,1,0,0,0,2157,2166,3,438,219,0,2158,2166,3,440,220,
        0,2159,2166,3,442,221,0,2160,2166,3,444,222,0,2161,2166,3,446,223,
        0,2162,2166,3,448,224,0,2163,2166,3,450,225,0,2164,2166,3,452,226,
        0,2165,2157,1,0,0,0,2165,2158,1,0,0,0,2165,2159,1,0,0,0,2165,2160,
        1,0,0,0,2165,2161,1,0,0,0,2165,2162,1,0,0,0,2165,2163,1,0,0,0,2165,
        2164,1,0,0,0,2166,437,1,0,0,0,2167,2170,5,71,0,0,2168,2171,3,36,
        18,0,2169,2171,5,385,0,0,2170,2168,1,0,0,0,2170,2169,1,0,0,0,2170,
        2171,1,0,0,0,2171,439,1,0,0,0,2172,2175,5,72,0,0,2173,2176,3,36,
        18,0,2174,2176,5,385,0,0,2175,2173,1,0,0,0,2175,2174,1,0,0,0,2175,
        2176,1,0,0,0,2176,441,1,0,0,0,2177,2180,5,54,0,0,2178,2181,3,36,
        18,0,2179,2181,5,385,0,0,2180,2178,1,0,0,0,2180,2179,1,0,0,0,2180,
        2181,1,0,0,0,2181,443,1,0,0,0,2182,2183,5,60,0,0,2183,2184,3,400,
        200,0,2184,445,1,0,0,0,2185,2187,5,73,0,0,2186,2188,3,890,445,0,
        2187,2186,1,0,0,0,2187,2188,1,0,0,0,2188,447,1,0,0,0,2189,2190,5,
        74,0,0,2190,2191,3,890,445,0,2191,449,1,0,0,0,2192,2193,5,75,0,0,
        2193,2194,3,892,446,0,2194,451,1,0,0,0,2195,2196,5,76,0,0,2196,2197,
        3,892,446,0,2197,453,1,0,0,0,2198,2202,3,456,228,0,2199,2202,3,458,
        229,0,2200,2202,3,460,230,0,2201,2198,1,0,0,0,2201,2199,1,0,0,0,
        2201,2200,1,0,0,0,2202,455,1,0,0,0,2203,2204,5,48,0,0,2204,2205,
        3,892,446,0,2205,2206,5,49,0,0,2206,2207,3,400,200,0,2207,457,1,
        0,0,0,2208,2209,5,77,0,0,2209,2212,3,892,446,0,2210,2211,5,78,0,
        0,2211,2213,3,866,433,0,2212,2210,1,0,0,0,2212,2213,1,0,0,0,2213,
        459,1,0,0,0,2214,2215,5,81,0,0,2215,2216,3,890,445,0,2216,461,1,
        0,0,0,2217,2222,3,464,232,0,2218,2222,3,466,233,0,2219,2222,3,468,
        234,0,2220,2222,3,470,235,0,2221,2217,1,0,0,0,2221,2218,1,0,0,0,
        2221,2219,1,0,0,0,2221,2220,1,0,0,0,2222,463,1,0,0,0,2223,2228,3,
        472,236,0,2224,2228,3,480,240,0,2225,2228,3,486,243,0,2226,2228,
        3,492,246,0,2227,2223,1,0,0,0,2227,2224,1,0,0,0,2227,2225,1,0,0,
        0,2227,2226,1,0,0,0,2228,465,1,0,0,0,2229,2230,3,500,250,0,2230,
        467,1,0,0,0,2231,2234,3,528,264,0,2232,2234,3,534,267,0,2233,2231,
        1,0,0,0,2233,2232,1,0,0,0,2234,469,1,0,0,0,2235,2236,3,538,269,0,
        2236,471,1,0,0,0,2237,2241,3,474,237,0,2238,2240,3,476,238,0,2239,
        2238,1,0,0,0,2240,2243,1,0,0,0,2241,2239,1,0,0,0,2241,2242,1,0,0,
        0,2242,2245,1,0,0,0,2243,2241,1,0,0,0,2244,2246,3,478,239,0,2245,
        2244,1,0,0,0,2245,2246,1,0,0,0,2246,473,1,0,0,0,2247,2248,5,48,0,
        0,2248,2249,3,892,446,0,2249,2250,3,406,203,0,2250,475,1,0,0,0,2251,
        2252,5,423,0,0,2252,2253,5,50,0,0,2253,2254,3,892,446,0,2254,2255,
        3,406,203,0,2255,477,1,0,0,0,2256,2257,5,423,0,0,2257,2258,5,51,
        0,0,2258,2259,3,406,203,0,2259,479,1,0,0,0,2260,2262,3,482,241,0,
        2261,2263,3,484,242,0,2262,2261,1,0,0,0,2263,2264,1,0,0,0,2264,2262,
        1,0,0,0,2264,2265,1,0,0,0,2265,2267,1,0,0,0,2266,2268,3,478,239,
        0,2267,2266,1,0,0,0,2267,2268,1,0,0,0,2268,481,1,0,0,0,2269,2271,
        5,52,0,0,2270,2272,3,892,446,0,2271,2270,1,0,0,0,2271,2272,1,0,0,
        0,2272,483,1,0,0,0,2273,2274,5,423,0,0,2274,2275,5,53,0,0,2275,2276,
        3,890,445,0,2276,2277,3,406,203,0,2277,485,1,0,0,0,2278,2282,3,488,
        244,0,2279,2281,3,490,245,0,2280,2279,1,0,0,0,2281,2284,1,0,0,0,
        2282,2280,1,0,0,0,2282,2283,1,0,0,0,2283,487,1,0,0,0,2284,2282,1,
        0,0,0,2285,2286,5,55,0,0,2286,2288,3,890,445,0,2287,2289,3,406,203,
        0,2288,2287,1,0,0,0,2288,2289,1,0,0,0,2289,489,1,0,0,0,2290,2291,
        5,423,0,0,2291,2293,5,56,0,0,2292,2294,3,62,31,0,2293,2292,1,0,0,
        0,2293,2294,1,0,0,0,2294,2295,1,0,0,0,2295,2296,3,406,203,0,2296,
        491,1,0,0,0,2297,2299,3,494,247,0,2298,2300,3,496,248,0,2299,2298,
        1,0,0,0,2300,2301,1,0,0,0,2301,2299,1,0,0,0,2301,2302,1,0,0,0,2302,
        2304,1,0,0,0,2303,2305,3,498,249,0,2304,2303,1,0,0,0,2304,2305,1,
        0,0,0,2305,493,1,0,0,0,2306,2307,5,82,0,0,2307,2308,3,890,445,0,
        2308,495,1,0,0,0,2309,2310,5,423,0,0,2310,2311,5,83,0,0,2311,2312,
        3,890,445,0,2312,2313,3,406,203,0,2313,497,1,0,0,0,2314,2315,5,423,
        0,0,2315,2316,5,84,0,0,2316,2317,3,406,203,0,2317,499,1,0,0,0,2318,
        2320,3,502,251,0,2319,2321,3,526,263,0,2320,2319,1,0,0,0,2320,2321,
        1,0,0,0,2321,501,1,0,0,0,2322,2324,5,63,0,0,2323,2325,3,252,126,
        0,2324,2323,1,0,0,0,2324,2325,1,0,0,0,2325,2326,1,0,0,0,2326,2327,
        3,504,252,0,2327,503,1,0,0,0,2328,2332,3,506,253,0,2329,2332,3,508,
        254,0,2330,2332,3,510,255,0,2331,2328,1,0,0,0,2331,2329,1,0,0,0,
        2331,2330,1,0,0,0,2332,505,1,0,0,0,2333,2335,3,514,257,0,2334,2333,
        1,0,0,0,2334,2335,1,0,0,0,2335,2337,1,0,0,0,2336,2338,3,512,256,
        0,2337,2336,1,0,0,0,2337,2338,1,0,0,0,2338,2339,1,0,0,0,2339,2340,
        3,406,203,0,2340,507,1,0,0,0,2341,2343,3,516,258,0,2342,2344,3,514,
        257,0,2343,2342,1,0,0,0,2343,2344,1,0,0,0,2344,2346,1,0,0,0,2345,
        2347,3,512,256,0,2346,2345,1,0,0,0,2346,2347,1,0,0,0,2347,2348,1,
        0,0,0,2348,2349,3,406,203,0,2349,509,1,0,0,0,2350,2351,3,402,201,
        0,2351,2352,5,423,0,0,2352,2354,3,518,259,0,2353,2355,3,514,257,
        0,2354,2353,1,0,0,0,2354,2355,1,0,0,0,2355,2357,1,0,0,0,2356,2358,
        3,512,256,0,2357,2356,1,0,0,0,2357,2358,1,0,0,0,2358,511,1,0,0,0,
        2359,2360,5,70,0,0,2360,2361,3,408,204,0,2361,513,1,0,0,0,2362,2363,
        5,69,0,0,2363,2364,3,892,446,0,2364,515,1,0,0,0,2365,2369,3,520,
        260,0,2366,2369,3,522,261,0,2367,2369,3,524,262,0,2368,2365,1,0,
        0,0,2368,2366,1,0,0,0,2368,2367,1,0,0,0,2369,517,1,0,0,0,2370,2373,
        3,522,261,0,2371,2373,3,524,262,0,2372,2370,1,0,0,0,2372,2371,1,
        0,0,0,2373,519,1,0,0,0,2374,2375,3,52,26,0,2375,2376,5,65,0,0,2376,
        2379,3,890,445,0,2377,2378,5,66,0,0,2378,2380,3,892,446,0,2379,2377,
        1,0,0,0,2379,2380,1,0,0,0,2380,521,1,0,0,0,2381,2382,5,67,0,0,2382,
        2383,3,892,446,0,2383,523,1,0,0,0,2384,2385,5,68,0,0,2385,2386,3,
        892,446,0,2386,525,1,0,0,0,2387,2388,5,423,0,0,2388,2389,5,49,0,
        0,2389,2390,3,406,203,0,2390,527,1,0,0,0,2391,2395,3,530,265,0,2392,
        2394,3,490,245,0,2393,2392,1,0,0,0,2394,2397,1,0,0,0,2395,2393,1,
        0,0,0,2395,2396,1,0,0,0,2396,2398,1,0,0,0,2397,2395,1,0,0,0,2398,
        2399,3,532,266,0,2399,529,1,0,0,0,2400,2401,5,85,0,0,2401,2402,3,
        406,203,0,2402,531,1,0,0,0,2403,2404,5,423,0,0,2404,2405,5,86,0,
        0,2405,2406,3,406,203,0,2406,533,1,0,0,0,2407,2408,3,536,268,0,2408,
        535,1,0,0,0,2409,2410,5,61,0,0,2410,2412,3,890,445,0,2411,2413,3,
        406,203,0,2412,2411,1,0,0,0,2412,2413,1,0,0,0,2413,537,1,0,0,0,2414,
        2416,3,540,270,0,2415,2417,3,542,271,0,2416,2415,1,0,0,0,2416,2417,
        1,0,0,0,2417,2419,1,0,0,0,2418,2420,3,544,272,0,2419,2418,1,0,0,
        0,2419,2420,1,0,0,0,2420,539,1,0,0,0,2421,2423,5,79,0,0,2422,2424,
        3,40,20,0,2423,2422,1,0,0,0,2423,2424,1,0,0,0,2424,2425,1,0,0,0,
        2425,2426,3,402,201,0,2426,541,1,0,0,0,2427,2428,5,80,0,0,2428,2429,
        3,892,446,0,2429,543,1,0,0,0,2430,2431,5,64,0,0,2431,2432,3,52,26,
        0,2432,2433,5,65,0,0,2433,2436,3,890,445,0,2434,2435,5,66,0,0,2435,
        2437,3,892,446,0,2436,2434,1,0,0,0,2436,2437,1,0,0,0,2437,545,1,
        0,0,0,2438,2441,3,548,274,0,2439,2441,3,550,275,0,2440,2438,1,0,
        0,0,2440,2439,1,0,0,0,2441,547,1,0,0,0,2442,2443,3,552,276,0,2443,
        549,1,0,0,0,2444,2445,3,556,278,0,2445,551,1,0,0,0,2446,2447,3,554,
        277,0,2447,553,1,0,0,0,2448,2449,5,271,0,0,2449,2453,3,892,446,0,
        2450,2454,5,329,0,0,2451,2452,5,329,0,0,2452,2454,3,892,446,0,2453,
        2450,1,0,0,0,2453,2451,1,0,0,0,2453,2454,1,0,0,0,2454,555,1,0,0,
        0,2455,2458,3,558,279,0,2456,2457,5,423,0,0,2457,2459,3,560,280,
        0,2458,2456,1,0,0,0,2458,2459,1,0,0,0,2459,2462,1,0,0,0,2460,2461,
        5,423,0,0,2461,2463,3,562,281,0,2462,2460,1,0,0,0,2462,2463,1,0,
        0,0,2463,2466,1,0,0,0,2464,2465,5,423,0,0,2465,2467,3,564,282,0,
        2466,2464,1,0,0,0,2466,2467,1,0,0,0,2467,2470,1,0,0,0,2468,2469,
        5,423,0,0,2469,2471,3,570,285,0,2470,2468,1,0,0,0,2470,2471,1,0,
        0,0,2471,2474,1,0,0,0,2472,2473,5,423,0,0,2473,2475,3,572,286,0,
        2474,2472,1,0,0,0,2474,2475,1,0,0,0,2475,2478,1,0,0,0,2476,2477,
        5,423,0,0,2477,2479,3,574,287,0,2478,2476,1,0,0,0,2478,2479,1,0,
        0,0,2479,2482,1,0,0,0,2480,2481,5,423,0,0,2481,2483,3,576,288,0,
        2482,2480,1,0,0,0,2482,2483,1,0,0,0,2483,2486,1,0,0,0,2484,2485,
        5,423,0,0,2485,2487,3,578,289,0,2486,2484,1,0,0,0,2486,2487,1,0,
        0,0,2487,2490,1,0,0,0,2488,2489,5,423,0,0,2489,2491,3,580,290,0,
        2490,2488,1,0,0,0,2490,2491,1,0,0,0,2491,2494,1,0,0,0,2492,2493,
        5,423,0,0,2493,2495,3,582,291,0,2494,2492,1,0,0,0,2494,2495,1,0,
        0,0,2495,557,1,0,0,0,2496,2498,5,272,0,0,2497,2499,3,766,383,0,2498,
        2497,1,0,0,0,2498,2499,1,0,0,0,2499,2501,1,0,0,0,2500,2502,3,10,
        5,0,2501,2500,1,0,0,0,2501,2502,1,0,0,0,2502,559,1,0,0,0,2503,2506,
        5,273,0,0,2504,2507,3,890,445,0,2505,2507,3,10,5,0,2506,2504,1,0,
        0,0,2506,2505,1,0,0,0,2507,561,1,0,0,0,2508,2511,5,274,0,0,2509,
        2512,3,890,445,0,2510,2512,3,10,5,0,2511,2509,1,0,0,0,2511,2510,
        1,0,0,0,2512,563,1,0,0,0,2513,2514,5,275,0,0,2514,2515,5,423,0,0,
        2515,2516,5,2,0,0,2516,2517,3,566,283,0,2517,2518,5,3,0,0,2518,565,
        1,0,0,0,2519,2524,3,568,284,0,2520,2521,5,423,0,0,2521,2523,3,568,
        284,0,2522,2520,1,0,0,0,2523,2526,1,0,0,0,2524,2522,1,0,0,0,2524,
        2525,1,0,0,0,2525,567,1,0,0,0,2526,2524,1,0,0,0,2527,2532,3,892,
        446,0,2528,2529,5,451,0,0,2529,2531,3,892,446,0,2530,2528,1,0,0,
        0,2531,2534,1,0,0,0,2532,2530,1,0,0,0,2532,2533,1,0,0,0,2533,569,
        1,0,0,0,2534,2532,1,0,0,0,2535,2538,5,276,0,0,2536,2539,3,890,445,
        0,2537,2539,3,10,5,0,2538,2536,1,0,0,0,2538,2537,1,0,0,0,2539,571,
        1,0,0,0,2540,2543,5,277,0,0,2541,2544,3,890,445,0,2542,2544,3,10,
        5,0,2543,2541,1,0,0,0,2543,2542,1,0,0,0,2544,573,1,0,0,0,2545,2548,
        5,278,0,0,2546,2549,3,890,445,0,2547,2549,3,10,5,0,2548,2546,1,0,
        0,0,2548,2547,1,0,0,0,2549,575,1,0,0,0,2550,2553,5,279,0,0,2551,
        2554,3,890,445,0,2552,2554,3,10,5,0,2553,2551,1,0,0,0,2553,2552,
        1,0,0,0,2554,577,1,0,0,0,2555,2558,5,280,0,0,2556,2559,3,890,445,
        0,2557,2559,3,10,5,0,2558,2556,1,0,0,0,2558,2557,1,0,0,0,2559,579,
        1,0,0,0,2560,2563,5,281,0,0,2561,2564,3,890,445,0,2562,2564,3,10,
        5,0,2563,2561,1,0,0,0,2563,2562,1,0,0,0,2564,581,1,0,0,0,2565,2568,
        5,261,0,0,2566,2569,3,890,445,0,2567,2569,3,10,5,0,2568,2566,1,0,
        0,0,2568,2567,1,0,0,0,2569,583,1,0,0,0,2570,2578,3,586,293,0,2571,
        2578,3,592,296,0,2572,2578,3,588,294,0,2573,2578,3,590,295,0,2574,
        2578,3,594,297,0,2575,2578,3,596,298,0,2576,2578,3,598,299,0,2577,
        2570,1,0,0,0,2577,2571,1,0,0,0,2577,2572,1,0,0,0,2577,2573,1,0,0,
        0,2577,2574,1,0,0,0,2577,2575,1,0,0,0,2577,2576,1,0,0,0,2578,585,
        1,0,0,0,2579,2580,7,6,0,0,2580,587,1,0,0,0,2581,2582,5,124,0,0,2582,
        589,1,0,0,0,2583,2584,5,127,0,0,2584,591,1,0,0,0,2585,2586,5,290,
        0,0,2586,593,1,0,0,0,2587,2588,5,125,0,0,2588,595,1,0,0,0,2589,2590,
        5,126,0,0,2590,597,1,0,0,0,2591,2592,7,7,0,0,2592,599,1,0,0,0,2593,
        2601,3,602,301,0,2594,2601,3,604,302,0,2595,2601,3,606,303,0,2596,
        2601,3,608,304,0,2597,2601,3,610,305,0,2598,2601,3,612,306,0,2599,
        2601,3,614,307,0,2600,2593,1,0,0,0,2600,2594,1,0,0,0,2600,2595,1,
        0,0,0,2600,2596,1,0,0,0,2600,2597,1,0,0,0,2600,2598,1,0,0,0,2600,
        2599,1,0,0,0,2601,601,1,0,0,0,2602,2603,7,8,0,0,2603,603,1,0,0,0,
        2604,2605,7,9,0,0,2605,605,1,0,0,0,2606,2607,7,10,0,0,2607,607,1,
        0,0,0,2608,2609,7,11,0,0,2609,609,1,0,0,0,2610,2611,7,12,0,0,2611,
        611,1,0,0,0,2612,2613,7,13,0,0,2613,613,1,0,0,0,2614,2615,7,14,0,
        0,2615,615,1,0,0,0,2616,2617,7,15,0,0,2617,617,1,0,0,0,2618,2619,
        7,16,0,0,2619,619,1,0,0,0,2620,2621,7,17,0,0,2621,621,1,0,0,0,2622,
        2623,7,18,0,0,2623,623,1,0,0,0,2624,2625,5,341,0,0,2625,625,1,0,
        0,0,2626,2627,5,342,0,0,2627,627,1,0,0,0,2628,2629,7,19,0,0,2629,
        629,1,0,0,0,2630,2631,7,20,0,0,2631,631,1,0,0,0,2632,2633,7,21,0,
        0,2633,633,1,0,0,0,2634,2635,7,22,0,0,2635,635,1,0,0,0,2636,2637,
        7,23,0,0,2637,637,1,0,0,0,2638,2642,3,640,320,0,2639,2642,3,642,
        321,0,2640,2642,3,644,322,0,2641,2638,1,0,0,0,2641,2639,1,0,0,0,
        2641,2640,1,0,0,0,2642,639,1,0,0,0,2643,2644,7,24,0,0,2644,641,1,
        0,0,0,2645,2646,5,353,0,0,2646,643,1,0,0,0,2647,2648,7,25,0,0,2648,
        645,1,0,0,0,2649,2665,3,584,292,0,2650,2665,3,602,301,0,2651,2665,
        3,604,302,0,2652,2665,3,606,303,0,2653,2665,3,608,304,0,2654,2665,
        3,610,305,0,2655,2665,3,612,306,0,2656,2665,3,614,307,0,2657,2665,
        3,616,308,0,2658,2665,3,618,309,0,2659,2665,3,620,310,0,2660,2665,
        3,622,311,0,2661,2665,3,628,314,0,2662,2665,3,630,315,0,2663,2665,
        3,638,319,0,2664,2649,1,0,0,0,2664,2650,1,0,0,0,2664,2651,1,0,0,
        0,2664,2652,1,0,0,0,2664,2653,1,0,0,0,2664,2654,1,0,0,0,2664,2655,
        1,0,0,0,2664,2656,1,0,0,0,2664,2657,1,0,0,0,2664,2658,1,0,0,0,2664,
        2659,1,0,0,0,2664,2660,1,0,0,0,2664,2661,1,0,0,0,2664,2662,1,0,0,
        0,2664,2663,1,0,0,0,2665,647,1,0,0,0,2666,2673,3,650,325,0,2667,
        2669,5,439,0,0,2668,2667,1,0,0,0,2668,2669,1,0,0,0,2669,2670,1,0,
        0,0,2670,2672,3,650,325,0,2671,2668,1,0,0,0,2672,2675,1,0,0,0,2673,
        2671,1,0,0,0,2673,2674,1,0,0,0,2674,649,1,0,0,0,2675,2673,1,0,0,
        0,2676,2679,3,652,326,0,2677,2679,3,654,327,0,2678,2676,1,0,0,0,
        2678,2677,1,0,0,0,2679,651,1,0,0,0,2680,2684,5,382,0,0,2681,2683,
        3,656,328,0,2682,2681,1,0,0,0,2683,2686,1,0,0,0,2684,2682,1,0,0,
        0,2684,2685,1,0,0,0,2685,653,1,0,0,0,2686,2684,1,0,0,0,2687,2691,
        5,383,0,0,2688,2690,3,656,328,0,2689,2688,1,0,0,0,2690,2693,1,0,
        0,0,2691,2689,1,0,0,0,2691,2692,1,0,0,0,2692,655,1,0,0,0,2693,2691,
        1,0,0,0,2694,2699,3,658,329,0,2695,2696,5,439,0,0,2696,2698,3,658,
        329,0,2697,2695,1,0,0,0,2698,2701,1,0,0,0,2699,2697,1,0,0,0,2699,
        2700,1,0,0,0,2700,657,1,0,0,0,2701,2699,1,0,0,0,2702,2703,5,381,
        0,0,2703,2705,5,353,0,0,2704,2702,1,0,0,0,2704,2705,1,0,0,0,2705,
        2706,1,0,0,0,2706,2707,3,892,446,0,2707,659,1,0,0,0,2708,2709,5,
        313,0,0,2709,2710,3,662,331,0,2710,2711,5,315,0,0,2711,661,1,0,0,
        0,2712,2717,3,664,332,0,2713,2714,5,439,0,0,2714,2716,3,664,332,
        0,2715,2713,1,0,0,0,2716,2719,1,0,0,0,2717,2715,1,0,0,0,2717,2718,
        1,0,0,0,2718,663,1,0,0,0,2719,2717,1,0,0,0,2720,2723,3,668,334,0,
        2721,2722,7,26,0,0,2722,2724,3,668,334,0,2723,2721,1,0,0,0,2723,
        2724,1,0,0,0,2724,665,1,0,0,0,2725,2730,3,668,334,0,2726,2727,5,
        439,0,0,2727,2729,3,668,334,0,2728,2726,1,0,0,0,2729,2732,1,0,0,
        0,2730,2728,1,0,0,0,2730,2731,1,0,0,0,2731,667,1,0,0,0,2732,2730,
        1,0,0,0,2733,2734,6,334,-1,0,2734,2735,3,670,335,0,2735,2736,3,668,
        334,9,2736,2740,1,0,0,0,2737,2740,3,674,337,0,2738,2740,3,38,19,
        0,2739,2733,1,0,0,0,2739,2737,1,0,0,0,2739,2738,1,0,0,0,2740,2759,
        1,0,0,0,2741,2742,10,6,0,0,2742,2743,5,115,0,0,2743,2758,3,668,334,
        7,2744,2745,10,5,0,0,2745,2746,5,119,0,0,2746,2758,3,668,334,6,2747,
        2748,10,4,0,0,2748,2749,5,122,0,0,2749,2758,3,668,334,5,2750,2751,
        10,3,0,0,2751,2752,5,291,0,0,2752,2758,3,668,334,4,2753,2754,10,
        8,0,0,2754,2758,3,672,336,0,2755,2756,10,7,0,0,2756,2758,3,660,330,
        0,2757,2741,1,0,0,0,2757,2744,1,0,0,0,2757,2747,1,0,0,0,2757,2750,
        1,0,0,0,2757,2753,1,0,0,0,2757,2755,1,0,0,0,2758,2761,1,0,0,0,2759,
        2757,1,0,0,0,2759,2760,1,0,0,0,2760,669,1,0,0,0,2761,2759,1,0,0,
        0,2762,2763,5,434,0,0,2763,2764,3,890,445,0,2764,2765,5,435,0,0,
        2765,671,1,0,0,0,2766,2781,5,329,0,0,2767,2781,5,331,0,0,2768,2769,
        5,331,0,0,2769,2781,5,331,0,0,2770,2771,5,451,0,0,2771,2781,5,315,
        0,0,2772,2773,5,329,0,0,2773,2781,5,331,0,0,2774,2775,5,329,0,0,
        2775,2776,5,331,0,0,2776,2781,5,331,0,0,2777,2778,5,329,0,0,2778,
        2779,5,451,0,0,2779,2781,5,315,0,0,2780,2766,1,0,0,0,2780,2767,1,
        0,0,0,2780,2768,1,0,0,0,2780,2770,1,0,0,0,2780,2772,1,0,0,0,2780,
        2774,1,0,0,0,2780,2777,1,0,0,0,2781,673,1,0,0,0,2782,2788,3,676,
        338,0,2783,2788,3,700,350,0,2784,2788,3,708,354,0,2785,2788,3,710,
        355,0,2786,2788,3,712,356,0,2787,2782,1,0,0,0,2787,2783,1,0,0,0,
        2787,2784,1,0,0,0,2787,2785,1,0,0,0,2787,2786,1,0,0,0,2788,675,1,
        0,0,0,2789,2794,3,678,339,0,2790,2794,3,680,340,0,2791,2794,3,696,
        348,0,2792,2794,3,698,349,0,2793,2789,1,0,0,0,2793,2790,1,0,0,0,
        2793,2791,1,0,0,0,2793,2792,1,0,0,0,2794,677,1,0,0,0,2795,2796,7,
        27,0,0,2796,679,1,0,0,0,2797,2805,3,682,341,0,2798,2805,3,684,342,
        0,2799,2805,3,688,344,0,2800,2805,3,686,343,0,2801,2805,3,690,345,
        0,2802,2805,3,692,346,0,2803,2805,3,694,347,0,2804,2797,1,0,0,0,
        2804,2798,1,0,0,0,2804,2799,1,0,0,0,2804,2800,1,0,0,0,2804,2801,
        1,0,0,0,2804,2802,1,0,0,0,2804,2803,1,0,0,0,2805,681,1,0,0,0,2806,
        2807,7,28,0,0,2807,683,1,0,0,0,2808,2809,7,29,0,0,2809,685,1,0,0,
        0,2810,2811,7,30,0,0,2811,687,1,0,0,0,2812,2813,7,31,0,0,2813,689,
        1,0,0,0,2814,2815,7,32,0,0,2815,691,1,0,0,0,2816,2817,7,33,0,0,2817,
        693,1,0,0,0,2818,2819,7,34,0,0,2819,695,1,0,0,0,2820,2821,7,35,0,
        0,2821,697,1,0,0,0,2822,2823,7,36,0,0,2823,699,1,0,0,0,2824,2828,
        3,702,351,0,2825,2828,3,704,352,0,2826,2828,3,706,353,0,2827,2824,
        1,0,0,0,2827,2825,1,0,0,0,2827,2826,1,0,0,0,2828,701,1,0,0,0,2829,
        2830,7,37,0,0,2830,703,1,0,0,0,2831,2832,7,38,0,0,2832,705,1,0,0,
        0,2833,2834,7,39,0,0,2834,707,1,0,0,0,2835,2836,7,40,0,0,2836,709,
        1,0,0,0,2837,2838,7,41,0,0,2838,711,1,0,0,0,2839,2849,3,714,357,
        0,2840,2849,3,716,358,0,2841,2849,3,718,359,0,2842,2849,3,720,360,
        0,2843,2849,3,722,361,0,2844,2849,3,724,362,0,2845,2849,3,726,363,
        0,2846,2849,3,728,364,0,2847,2849,3,730,365,0,2848,2839,1,0,0,0,
        2848,2840,1,0,0,0,2848,2841,1,0,0,0,2848,2842,1,0,0,0,2848,2843,
        1,0,0,0,2848,2844,1,0,0,0,2848,2845,1,0,0,0,2848,2846,1,0,0,0,2848,
        2847,1,0,0,0,2849,713,1,0,0,0,2850,2851,5,21,0,0,2851,2852,3,732,
        366,0,2852,2853,3,178,89,0,2853,715,1,0,0,0,2854,2855,5,22,0,0,2855,
        2856,3,738,369,0,2856,717,1,0,0,0,2857,2858,5,23,0,0,2858,2859,3,
        732,366,0,2859,2860,3,178,89,0,2860,719,1,0,0,0,2861,2862,5,24,0,
        0,2862,2863,3,732,366,0,2863,2864,3,178,89,0,2864,721,1,0,0,0,2865,
        2866,5,25,0,0,2866,2867,3,732,366,0,2867,723,1,0,0,0,2868,2869,5,
        32,0,0,2869,2870,3,732,366,0,2870,2871,3,178,89,0,2871,725,1,0,0,
        0,2872,2873,5,33,0,0,2873,2874,3,734,367,0,2874,2875,3,178,89,0,
        2875,727,1,0,0,0,2876,2877,5,46,0,0,2877,729,1,0,0,0,2878,2879,5,
        47,0,0,2879,2880,3,732,366,0,2880,731,1,0,0,0,2881,2883,5,432,0,
        0,2882,2884,3,736,368,0,2883,2882,1,0,0,0,2883,2884,1,0,0,0,2884,
        2885,1,0,0,0,2885,2886,5,433,0,0,2886,733,1,0,0,0,2887,2889,5,434,
        0,0,2888,2890,3,736,368,0,2889,2888,1,0,0,0,2889,2890,1,0,0,0,2890,
        2891,1,0,0,0,2891,2892,5,435,0,0,2892,735,1,0,0,0,2893,2898,3,738,
        369,0,2894,2895,5,439,0,0,2895,2897,3,738,369,0,2896,2894,1,0,0,
        0,2897,2900,1,0,0,0,2898,2896,1,0,0,0,2898,2899,1,0,0,0,2899,737,
        1,0,0,0,2900,2898,1,0,0,0,2901,2903,3,176,88,0,2902,2901,1,0,0,0,
        2902,2903,1,0,0,0,2903,2904,1,0,0,0,2904,2905,3,668,334,0,2905,739,
        1,0,0,0,2906,2911,3,742,371,0,2907,2911,3,754,377,0,2908,2911,3,
        764,382,0,2909,2911,3,846,423,0,2910,2906,1,0,0,0,2910,2907,1,0,
        0,0,2910,2908,1,0,0,0,2910,2909,1,0,0,0,2911,741,1,0,0,0,2912,2918,
        3,744,372,0,2913,2918,3,746,373,0,2914,2918,3,748,374,0,2915,2918,
        3,750,375,0,2916,2918,3,752,376,0,2917,2912,1,0,0,0,2917,2913,1,
        0,0,0,2917,2914,1,0,0,0,2917,2915,1,0,0,0,2917,2916,1,0,0,0,2918,
        743,1,0,0,0,2919,2920,7,42,0,0,2920,745,1,0,0,0,2921,2937,5,384,
        0,0,2922,2937,5,385,0,0,2923,2937,5,386,0,0,2924,2937,5,387,0,0,
        2925,2937,5,388,0,0,2926,2937,5,389,0,0,2927,2937,5,391,0,0,2928,
        2929,5,218,0,0,2929,2937,3,876,438,0,2930,2937,5,219,0,0,2931,2937,
        5,220,0,0,2932,2937,5,221,0,0,2933,2937,5,222,0,0,2934,2937,5,223,
        0,0,2935,2937,5,224,0,0,2936,2921,1,0,0,0,2936,2922,1,0,0,0,2936,
        2923,1,0,0,0,2936,2924,1,0,0,0,2936,2925,1,0,0,0,2936,2926,1,0,0,
        0,2936,2927,1,0,0,0,2936,2928,1,0,0,0,2936,2930,1,0,0,0,2936,2931,
        1,0,0,0,2936,2932,1,0,0,0,2936,2933,1,0,0,0,2936,2934,1,0,0,0,2936,
        2935,1,0,0,0,2937,747,1,0,0,0,2938,2939,7,43,0,0,2939,749,1,0,0,
        0,2940,2972,5,403,0,0,2941,2943,5,225,0,0,2942,2944,3,876,438,0,
        2943,2942,1,0,0,0,2943,2944,1,0,0,0,2944,2972,1,0,0,0,2945,2947,
        5,226,0,0,2946,2948,3,876,438,0,2947,2946,1,0,0,0,2947,2948,1,0,
        0,0,2948,2972,1,0,0,0,2949,2951,5,227,0,0,2950,2952,3,876,438,0,
        2951,2950,1,0,0,0,2951,2952,1,0,0,0,2952,2972,1,0,0,0,2953,2955,
        5,228,0,0,2954,2956,3,876,438,0,2955,2954,1,0,0,0,2955,2956,1,0,
        0,0,2956,2972,1,0,0,0,2957,2959,5,229,0,0,2958,2960,3,876,438,0,
        2959,2958,1,0,0,0,2959,2960,1,0,0,0,2960,2972,1,0,0,0,2961,2963,
        5,230,0,0,2962,2964,3,876,438,0,2963,2962,1,0,0,0,2963,2964,1,0,
        0,0,2964,2972,1,0,0,0,2965,2972,5,231,0,0,2966,2972,5,232,0,0,2967,
        2972,5,233,0,0,2968,2972,5,234,0,0,2969,2972,5,235,0,0,2970,2972,
        5,236,0,0,2971,2940,1,0,0,0,2971,2941,1,0,0,0,2971,2945,1,0,0,0,
        2971,2949,1,0,0,0,2971,2953,1,0,0,0,2971,2957,1,0,0,0,2971,2961,
        1,0,0,0,2971,2965,1,0,0,0,2971,2966,1,0,0,0,2971,2967,1,0,0,0,2971,
        2968,1,0,0,0,2971,2969,1,0,0,0,2971,2970,1,0,0,0,2972,751,1,0,0,
        0,2973,2989,5,393,0,0,2974,2989,5,394,0,0,2975,2976,5,237,0,0,2976,
        2989,3,876,438,0,2977,2978,5,239,0,0,2978,2989,3,876,438,0,2979,
        2980,5,240,0,0,2980,2989,3,876,438,0,2981,2982,5,241,0,0,2982,2989,
        3,876,438,0,2983,2984,5,242,0,0,2984,2989,3,876,438,0,2985,2986,
        5,243,0,0,2986,2989,3,876,438,0,2987,2989,5,244,0,0,2988,2973,1,
        0,0,0,2988,2974,1,0,0,0,2988,2975,1,0,0,0,2988,2977,1,0,0,0,2988,
        2979,1,0,0,0,2988,2981,1,0,0,0,2988,2983,1,0,0,0,2988,2985,1,0,0,
        0,2988,2987,1,0,0,0,2989,753,1,0,0,0,2990,2995,3,756,378,0,2991,
        2995,3,758,379,0,2992,2995,3,760,380,0,2993,2995,3,762,381,0,2994,
        2990,1,0,0,0,2994,2991,1,0,0,0,2994,2992,1,0,0,0,2994,2993,1,0,0,
        0,2995,755,1,0,0,0,2996,2997,5,260,0,0,2997,3001,3,876,438,0,2998,
        2999,5,261,0,0,2999,3001,3,876,438,0,3000,2996,1,0,0,0,3000,2998,
        1,0,0,0,3001,757,1,0,0,0,3002,3003,5,263,0,0,3003,3006,3,876,438,
        0,3004,3006,5,264,0,0,3005,3002,1,0,0,0,3005,3004,1,0,0,0,3006,759,
        1,0,0,0,3007,3008,5,266,0,0,3008,3012,3,876,438,0,3009,3010,5,267,
        0,0,3010,3012,3,876,438,0,3011,3007,1,0,0,0,3011,3009,1,0,0,0,3012,
        761,1,0,0,0,3013,3014,5,269,0,0,3014,3017,3,876,438,0,3015,3017,
        5,270,0,0,3016,3013,1,0,0,0,3016,3015,1,0,0,0,3017,763,1,0,0,0,3018,
        3025,3,766,383,0,3019,3025,3,770,385,0,3020,3025,3,772,386,0,3021,
        3025,3,788,394,0,3022,3025,3,816,408,0,3023,3025,3,834,417,0,3024,
        3018,1,0,0,0,3024,3019,1,0,0,0,3024,3020,1,0,0,0,3024,3021,1,0,0,
        0,3024,3022,1,0,0,0,3024,3023,1,0,0,0,3025,765,1,0,0,0,3026,3040,
        5,397,0,0,3027,3040,5,398,0,0,3028,3040,5,395,0,0,3029,3040,5,396,
        0,0,3030,3040,5,399,0,0,3031,3040,5,400,0,0,3032,3040,5,401,0,0,
        3033,3040,5,402,0,0,3034,3040,5,403,0,0,3035,3040,5,392,0,0,3036,
        3037,5,246,0,0,3037,3040,3,876,438,0,3038,3040,5,245,0,0,3039,3026,
        1,0,0,0,3039,3027,1,0,0,0,3039,3028,1,0,0,0,3039,3029,1,0,0,0,3039,
        3030,1,0,0,0,3039,3031,1,0,0,0,3039,3032,1,0,0,0,3039,3033,1,0,0,
        0,3039,3034,1,0,0,0,3039,3035,1,0,0,0,3039,3036,1,0,0,0,3039,3038,
        1,0,0,0,3040,767,1,0,0,0,3041,3042,7,44,0,0,3042,769,1,0,0,0,3043,
        3044,5,405,0,0,3044,771,1,0,0,0,3045,3052,3,774,387,0,3046,3052,
        3,776,388,0,3047,3052,3,778,389,0,3048,3052,3,780,390,0,3049,3052,
        3,782,391,0,3050,3052,3,784,392,0,3051,3045,1,0,0,0,3051,3046,1,
        0,0,0,3051,3047,1,0,0,0,3051,3048,1,0,0,0,3051,3049,1,0,0,0,3051,
        3050,1,0,0,0,3052,773,1,0,0,0,3053,3054,3,742,371,0,3054,3055,3,
        632,316,0,3055,3056,3,742,371,0,3056,3064,1,0,0,0,3057,3058,3,742,
        371,0,3058,3059,3,634,317,0,3059,3064,1,0,0,0,3060,3061,3,636,318,
        0,3061,3062,3,742,371,0,3062,3064,1,0,0,0,3063,3053,1,0,0,0,3063,
        3057,1,0,0,0,3063,3060,1,0,0,0,3064,775,1,0,0,0,3065,3066,3,742,
        371,0,3066,3067,5,441,0,0,3067,3068,3,892,446,0,3068,777,1,0,0,0,
        3069,3070,5,432,0,0,3070,3072,3,890,445,0,3071,3073,5,439,0,0,3072,
        3071,1,0,0,0,3072,3073,1,0,0,0,3073,3074,1,0,0,0,3074,3075,5,433,
        0,0,3075,779,1,0,0,0,3076,3082,5,403,0,0,3077,3078,5,257,0,0,3078,
        3082,3,876,438,0,3079,3080,5,258,0,0,3080,3082,3,876,438,0,3081,
        3076,1,0,0,0,3081,3077,1,0,0,0,3081,3079,1,0,0,0,3082,781,1,0,0,
        0,3083,3084,5,255,0,0,3084,3088,3,876,438,0,3085,3086,5,256,0,0,
        3086,3088,3,876,438,0,3087,3083,1,0,0,0,3087,3085,1,0,0,0,3088,783,
        1,0,0,0,3089,3107,5,415,0,0,3090,3107,5,414,0,0,3091,3092,5,247,
        0,0,3092,3107,3,876,438,0,3093,3094,5,248,0,0,3094,3107,3,876,438,
        0,3095,3096,5,249,0,0,3096,3107,3,876,438,0,3097,3098,5,250,0,0,
        3098,3107,3,876,438,0,3099,3100,5,251,0,0,3100,3107,3,876,438,0,
        3101,3102,5,252,0,0,3102,3107,3,876,438,0,3103,3104,5,253,0,0,3104,
        3107,3,876,438,0,3105,3107,5,254,0,0,3106,3089,1,0,0,0,3106,3090,
        1,0,0,0,3106,3091,1,0,0,0,3106,3093,1,0,0,0,3106,3095,1,0,0,0,3106,
        3097,1,0,0,0,3106,3099,1,0,0,0,3106,3101,1,0,0,0,3106,3103,1,0,0,
        0,3106,3105,1,0,0,0,3107,785,1,0,0,0,3108,3113,3,784,392,0,3109,
        3110,5,439,0,0,3110,3112,3,784,392,0,3111,3109,1,0,0,0,3112,3115,
        1,0,0,0,3113,3111,1,0,0,0,3113,3114,1,0,0,0,3114,787,1,0,0,0,3115,
        3113,1,0,0,0,3116,3119,3,790,395,0,3117,3119,3,800,400,0,3118,3116,
        1,0,0,0,3118,3117,1,0,0,0,3119,789,1,0,0,0,3120,3123,3,792,396,0,
        3121,3123,3,798,399,0,3122,3120,1,0,0,0,3122,3121,1,0,0,0,3123,791,
        1,0,0,0,3124,3128,3,794,397,0,3125,3127,3,812,406,0,3126,3125,1,
        0,0,0,3127,3130,1,0,0,0,3128,3126,1,0,0,0,3128,3129,1,0,0,0,3129,
        3131,1,0,0,0,3130,3128,1,0,0,0,3131,3132,3,796,398,0,3132,793,1,
        0,0,0,3133,3134,5,313,0,0,3134,3138,3,806,403,0,3135,3137,3,808,
        404,0,3136,3135,1,0,0,0,3137,3140,1,0,0,0,3138,3136,1,0,0,0,3138,
        3139,1,0,0,0,3139,3141,1,0,0,0,3140,3138,1,0,0,0,3141,3142,5,315,
        0,0,3142,795,1,0,0,0,3143,3144,5,461,0,0,3144,3145,3,806,403,0,3145,
        3146,5,315,0,0,3146,797,1,0,0,0,3147,3148,5,313,0,0,3148,3152,3,
        806,403,0,3149,3151,3,808,404,0,3150,3149,1,0,0,0,3151,3154,1,0,
        0,0,3152,3150,1,0,0,0,3152,3153,1,0,0,0,3153,3155,1,0,0,0,3154,3152,
        1,0,0,0,3155,3156,5,462,0,0,3156,799,1,0,0,0,3157,3160,3,802,401,
        0,3158,3160,3,804,402,0,3159,3157,1,0,0,0,3159,3158,1,0,0,0,3160,
        801,1,0,0,0,3161,3165,5,463,0,0,3162,3164,3,812,406,0,3163,3162,
        1,0,0,0,3164,3167,1,0,0,0,3165,3163,1,0,0,0,3165,3166,1,0,0,0,3166,
        3168,1,0,0,0,3167,3165,1,0,0,0,3168,3169,5,464,0,0,3169,803,1,0,
        0,0,3170,3171,5,464,0,0,3171,805,1,0,0,0,3172,3175,5,381,0,0,3173,
        3175,3,38,19,0,3174,3172,1,0,0,0,3174,3173,1,0,0,0,3175,807,1,0,
        0,0,3176,3179,3,806,403,0,3177,3178,5,353,0,0,3178,3180,3,810,405,
        0,3179,3177,1,0,0,0,3179,3180,1,0,0,0,3180,809,1,0,0,0,3181,3184,
        3,740,370,0,3182,3184,3,814,407,0,3183,3181,1,0,0,0,3183,3182,1,
        0,0,0,3184,811,1,0,0,0,3185,3189,3,790,395,0,3186,3189,3,814,407,
        0,3187,3189,5,1,0,0,3188,3185,1,0,0,0,3188,3186,1,0,0,0,3188,3187,
        1,0,0,0,3189,813,1,0,0,0,3190,3191,5,436,0,0,3191,3192,3,892,446,
        0,3192,3193,5,437,0,0,3193,815,1,0,0,0,3194,3196,3,668,334,0,3195,
        3194,1,0,0,0,3195,3196,1,0,0,0,3196,3197,1,0,0,0,3197,3201,3,818,
        409,0,3198,3201,3,828,414,0,3199,3201,3,830,415,0,3200,3195,1,0,
        0,0,3200,3198,1,0,0,0,3200,3199,1,0,0,0,3201,817,1,0,0,0,3202,3203,
        5,434,0,0,3203,3216,5,435,0,0,3204,3209,5,434,0,0,3205,3207,3,820,
        410,0,3206,3208,5,439,0,0,3207,3206,1,0,0,0,3207,3208,1,0,0,0,3208,
        3210,1,0,0,0,3209,3205,1,0,0,0,3210,3211,1,0,0,0,3211,3209,1,0,0,
        0,3211,3212,1,0,0,0,3212,3213,1,0,0,0,3213,3214,5,435,0,0,3214,3216,
        1,0,0,0,3215,3202,1,0,0,0,3215,3204,1,0,0,0,3216,819,1,0,0,0,3217,
        3219,3,822,411,0,3218,3217,1,0,0,0,3219,3220,1,0,0,0,3220,3218,1,
        0,0,0,3220,3221,1,0,0,0,3221,821,1,0,0,0,3222,3223,3,824,412,0,3223,
        3224,5,441,0,0,3224,3226,1,0,0,0,3225,3222,1,0,0,0,3225,3226,1,0,
        0,0,3226,3227,1,0,0,0,3227,3228,3,826,413,0,3228,823,1,0,0,0,3229,
        3230,3,892,446,0,3230,825,1,0,0,0,3231,3232,3,892,446,0,3232,827,
        1,0,0,0,3233,3234,5,434,0,0,3234,3235,5,435,0,0,3235,3236,3,892,
        446,0,3236,829,1,0,0,0,3237,3238,5,434,0,0,3238,3240,3,890,445,0,
        3239,3241,3,832,416,0,3240,3239,1,0,0,0,3241,3242,1,0,0,0,3242,3240,
        1,0,0,0,3242,3243,1,0,0,0,3243,3244,1,0,0,0,3244,3245,5,435,0,0,
        3245,831,1,0,0,0,3246,3249,3,544,272,0,3247,3248,5,48,0,0,3248,3250,
        3,892,446,0,3249,3247,1,0,0,0,3249,3250,1,0,0,0,3250,833,1,0,0,0,
        3251,3253,3,668,334,0,3252,3251,1,0,0,0,3252,3253,1,0,0,0,3253,3254,
        1,0,0,0,3254,3255,3,836,418,0,3255,835,1,0,0,0,3256,3257,5,436,0,
        0,3257,3270,5,437,0,0,3258,3259,5,436,0,0,3259,3261,3,838,419,0,
        3260,3262,5,439,0,0,3261,3260,1,0,0,0,3261,3262,1,0,0,0,3262,3263,
        1,0,0,0,3263,3264,5,437,0,0,3264,3270,1,0,0,0,3265,3266,5,436,0,
        0,3266,3267,3,10,5,0,3267,3268,5,437,0,0,3268,3270,1,0,0,0,3269,
        3256,1,0,0,0,3269,3258,1,0,0,0,3269,3265,1,0,0,0,3270,837,1,0,0,
        0,3271,3276,3,840,420,0,3272,3273,5,439,0,0,3273,3275,3,840,420,
        0,3274,3272,1,0,0,0,3275,3278,1,0,0,0,3276,3274,1,0,0,0,3276,3277,
        1,0,0,0,3277,839,1,0,0,0,3278,3276,1,0,0,0,3279,3280,3,842,421,0,
        3280,3281,5,441,0,0,3281,3283,1,0,0,0,3282,3279,1,0,0,0,3282,3283,
        1,0,0,0,3283,3284,1,0,0,0,3284,3285,3,844,422,0,3285,841,1,0,0,0,
        3286,3287,3,46,23,0,3287,843,1,0,0,0,3288,3289,3,892,446,0,3289,
        845,1,0,0,0,3290,3294,3,848,424,0,3291,3294,3,850,425,0,3292,3294,
        3,852,426,0,3293,3290,1,0,0,0,3293,3291,1,0,0,0,3293,3292,1,0,0,
        0,3294,847,1,0,0,0,3295,3297,5,106,0,0,3296,3298,3,168,84,0,3297,
        3296,1,0,0,0,3297,3298,1,0,0,0,3298,3299,1,0,0,0,3299,3300,5,340,
        0,0,3300,3301,3,890,445,0,3301,849,1,0,0,0,3302,3303,5,453,0,0,3303,
        3304,3,404,202,0,3304,3305,5,433,0,0,3305,851,1,0,0,0,3306,3307,
        3,600,300,0,3307,3308,5,453,0,0,3308,3310,3,892,446,0,3309,3311,
        3,832,416,0,3310,3309,1,0,0,0,3311,3312,1,0,0,0,3312,3310,1,0,0,
        0,3312,3313,1,0,0,0,3313,3314,1,0,0,0,3314,3315,5,433,0,0,3315,853,
        1,0,0,0,3316,3319,3,856,428,0,3317,3319,3,858,429,0,3318,3316,1,
        0,0,0,3318,3317,1,0,0,0,3319,855,1,0,0,0,3320,3321,7,45,0,0,3321,
        857,1,0,0,0,3322,3323,7,46,0,0,3323,859,1,0,0,0,3324,3327,3,862,
        431,0,3325,3327,3,864,432,0,3326,3324,1,0,0,0,3326,3325,1,0,0,0,
        3327,861,1,0,0,0,3328,3329,7,47,0,0,3329,863,1,0,0,0,3330,3331,7,
        48,0,0,3331,865,1,0,0,0,3332,3337,3,868,434,0,3333,3334,5,439,0,
        0,3334,3336,3,868,434,0,3335,3333,1,0,0,0,3336,3339,1,0,0,0,3337,
        3335,1,0,0,0,3337,3338,1,0,0,0,3338,867,1,0,0,0,3339,3337,1,0,0,
        0,3340,3341,6,434,-1,0,3341,3352,3,870,435,0,3342,3352,3,874,437,
        0,3343,3352,3,876,438,0,3344,3345,3,584,292,0,3345,3346,3,868,434,
        4,3346,3352,1,0,0,0,3347,3348,3,872,436,0,3348,3349,3,868,434,2,
        3349,3352,1,0,0,0,3350,3352,3,888,444,0,3351,3340,1,0,0,0,3351,3342,
        1,0,0,0,3351,3343,1,0,0,0,3351,3344,1,0,0,0,3351,3347,1,0,0,0,3351,
        3350,1,0,0,0,3352,3379,1,0,0,0,3353,3354,10,7,0,0,3354,3355,5,438,
        0,0,3355,3378,3,868,434,8,3356,3357,10,8,0,0,3357,3358,5,434,0,0,
        3358,3359,3,878,439,0,3359,3360,5,435,0,0,3360,3378,1,0,0,0,3361,
        3363,10,6,0,0,3362,3364,3,660,330,0,3363,3362,1,0,0,0,3363,3364,
        1,0,0,0,3364,3365,1,0,0,0,3365,3378,3,160,80,0,3366,3367,10,5,0,
        0,3367,3371,3,890,445,0,3368,3370,3,886,443,0,3369,3368,1,0,0,0,
        3370,3373,1,0,0,0,3371,3369,1,0,0,0,3371,3372,1,0,0,0,3372,3378,
        1,0,0,0,3373,3371,1,0,0,0,3374,3375,10,3,0,0,3375,3376,5,440,0,0,
        3376,3378,3,884,442,0,3377,3353,1,0,0,0,3377,3356,1,0,0,0,3377,3361,
        1,0,0,0,3377,3366,1,0,0,0,3377,3374,1,0,0,0,3378,3381,1,0,0,0,3379,
        3377,1,0,0,0,3379,3380,1,0,0,0,3380,869,1,0,0,0,3381,3379,1,0,0,
        0,3382,3388,3,854,427,0,3383,3388,3,740,370,0,3384,3388,5,381,0,
        0,3385,3388,3,38,19,0,3386,3388,3,668,334,0,3387,3382,1,0,0,0,3387,
        3383,1,0,0,0,3387,3384,1,0,0,0,3387,3385,1,0,0,0,3387,3386,1,0,0,
        0,3388,871,1,0,0,0,3389,3392,3,860,430,0,3390,3392,3,38,19,0,3391,
        3389,1,0,0,0,3391,3390,1,0,0,0,3392,873,1,0,0,0,3393,3394,5,432,
        0,0,3394,3395,3,400,200,0,3395,3396,5,433,0,0,3396,875,1,0,0,0,3397,
        3398,5,432,0,0,3398,3399,3,892,446,0,3399,3400,5,433,0,0,3400,877,
        1,0,0,0,3401,3405,3,890,445,0,3402,3405,3,880,440,0,3403,3405,3,
        882,441,0,3404,3401,1,0,0,0,3404,3402,1,0,0,0,3404,3403,1,0,0,0,
        3405,879,1,0,0,0,3406,3407,6,440,-1,0,3407,3408,3,892,446,0,3408,
        3409,3,632,316,0,3409,3410,3,892,446,0,3410,3418,1,0,0,0,3411,3412,
        3,892,446,0,3412,3413,3,634,317,0,3413,3418,1,0,0,0,3414,3415,3,
        636,318,0,3415,3416,3,892,446,0,3416,3418,1,0,0,0,3417,3406,1,0,
        0,0,3417,3411,1,0,0,0,3417,3414,1,0,0,0,3418,3424,1,0,0,0,3419,3420,
        10,1,0,0,3420,3421,5,334,0,0,3421,3423,3,892,446,0,3422,3419,1,0,
        0,0,3423,3426,1,0,0,0,3424,3422,1,0,0,0,3424,3425,1,0,0,0,3425,881,
        1,0,0,0,3426,3424,1,0,0,0,3427,3428,6,441,-1,0,3428,3429,3,892,446,
        0,3429,3430,5,441,0,0,3430,3431,3,892,446,0,3431,3438,1,0,0,0,3432,
        3433,5,441,0,0,3433,3438,3,892,446,0,3434,3435,3,892,446,0,3435,
        3436,5,441,0,0,3436,3438,1,0,0,0,3437,3427,1,0,0,0,3437,3432,1,0,
        0,0,3437,3434,1,0,0,0,3438,3444,1,0,0,0,3439,3440,10,1,0,0,3440,
        3441,5,441,0,0,3441,3443,3,892,446,0,3442,3439,1,0,0,0,3443,3446,
        1,0,0,0,3444,3442,1,0,0,0,3444,3445,1,0,0,0,3445,883,1,0,0,0,3446,
        3444,1,0,0,0,3447,3451,3,668,334,0,3448,3451,5,382,0,0,3449,3451,
        3,768,384,0,3450,3447,1,0,0,0,3450,3448,1,0,0,0,3450,3449,1,0,0,
        0,3451,885,1,0,0,0,3452,3453,5,450,0,0,3453,3454,5,381,0,0,3454,
        3455,5,353,0,0,3455,3456,3,892,446,0,3456,887,1,0,0,0,3457,3459,
        3,766,383,0,3458,3457,1,0,0,0,3459,3460,1,0,0,0,3460,3458,1,0,0,
        0,3460,3461,1,0,0,0,3461,889,1,0,0,0,3462,3467,3,892,446,0,3463,
        3464,5,439,0,0,3464,3466,3,892,446,0,3465,3463,1,0,0,0,3466,3469,
        1,0,0,0,3467,3465,1,0,0,0,3467,3468,1,0,0,0,3468,891,1,0,0,0,3469,
        3467,1,0,0,0,3470,3471,6,446,-1,0,3471,3500,3,868,434,0,3472,3500,
        3,894,447,0,3473,3500,3,900,450,0,3474,3500,3,902,451,0,3475,3478,
        3,868,434,0,3476,3477,5,339,0,0,3477,3479,3,872,436,0,3478,3476,
        1,0,0,0,3479,3480,1,0,0,0,3480,3478,1,0,0,0,3480,3481,1,0,0,0,3481,
        3483,1,0,0,0,3482,3484,3,892,446,0,3483,3482,1,0,0,0,3483,3484,1,
        0,0,0,3484,3500,1,0,0,0,3485,3490,3,872,436,0,3486,3487,5,339,0,
        0,3487,3489,3,872,436,0,3488,3486,1,0,0,0,3489,3492,1,0,0,0,3490,
        3488,1,0,0,0,3490,3491,1,0,0,0,3491,3493,1,0,0,0,3492,3490,1,0,0,
        0,3493,3494,3,890,445,0,3494,3500,1,0,0,0,3495,3496,3,868,434,0,
        3496,3497,3,160,80,0,3497,3498,3,846,423,0,3498,3500,1,0,0,0,3499,
        3470,1,0,0,0,3499,3472,1,0,0,0,3499,3473,1,0,0,0,3499,3474,1,0,0,
        0,3499,3475,1,0,0,0,3499,3485,1,0,0,0,3499,3495,1,0,0,0,3500,3566,
        1,0,0,0,3501,3502,10,21,0,0,3502,3503,3,602,301,0,3503,3504,3,892,
        446,22,3504,3565,1,0,0,0,3505,3506,10,20,0,0,3506,3507,3,604,302,
        0,3507,3508,3,892,446,21,3508,3565,1,0,0,0,3509,3510,10,19,0,0,3510,
        3511,3,608,304,0,3511,3512,3,892,446,20,3512,3565,1,0,0,0,3513,3514,
        10,18,0,0,3514,3515,3,606,303,0,3515,3516,3,892,446,19,3516,3565,
        1,0,0,0,3517,3518,10,17,0,0,3518,3519,3,616,308,0,3519,3520,3,892,
        446,18,3520,3565,1,0,0,0,3521,3522,10,16,0,0,3522,3523,3,618,309,
        0,3523,3524,3,892,446,17,3524,3565,1,0,0,0,3525,3526,10,15,0,0,3526,
        3527,3,620,310,0,3527,3528,3,892,446,16,3528,3565,1,0,0,0,3529,3530,
        10,14,0,0,3530,3531,3,622,311,0,3531,3532,3,892,446,15,3532,3565,
        1,0,0,0,3533,3534,10,13,0,0,3534,3535,3,610,305,0,3535,3536,3,892,
        446,14,3536,3565,1,0,0,0,3537,3538,10,12,0,0,3538,3539,3,612,306,
        0,3539,3540,3,892,446,13,3540,3565,1,0,0,0,3541,3542,10,11,0,0,3542,
        3543,3,614,307,0,3543,3544,3,892,446,12,3544,3565,1,0,0,0,3545,3546,
        10,10,0,0,3546,3547,3,624,312,0,3547,3548,3,892,446,11,3548,3565,
        1,0,0,0,3549,3550,10,9,0,0,3550,3551,3,626,313,0,3551,3552,3,892,
        446,10,3552,3565,1,0,0,0,3553,3554,10,7,0,0,3554,3555,5,48,0,0,3555,
        3556,3,892,446,0,3556,3557,5,51,0,0,3557,3558,3,892,446,8,3558,3565,
        1,0,0,0,3559,3560,10,8,0,0,3560,3562,3,628,314,0,3561,3563,3,892,
        446,0,3562,3561,1,0,0,0,3562,3563,1,0,0,0,3563,3565,1,0,0,0,3564,
        3501,1,0,0,0,3564,3505,1,0,0,0,3564,3509,1,0,0,0,3564,3513,1,0,0,
        0,3564,3517,1,0,0,0,3564,3521,1,0,0,0,3564,3525,1,0,0,0,3564,3529,
        1,0,0,0,3564,3533,1,0,0,0,3564,3537,1,0,0,0,3564,3541,1,0,0,0,3564,
        3545,1,0,0,0,3564,3549,1,0,0,0,3564,3553,1,0,0,0,3564,3559,1,0,0,
        0,3565,3568,1,0,0,0,3566,3564,1,0,0,0,3566,3567,1,0,0,0,3567,893,
        1,0,0,0,3568,3566,1,0,0,0,3569,3571,3,896,448,0,3570,3569,1,0,0,
        0,3571,3572,1,0,0,0,3572,3570,1,0,0,0,3572,3573,1,0,0,0,3573,3575,
        1,0,0,0,3574,3576,3,898,449,0,3575,3574,1,0,0,0,3575,3576,1,0,0,
        0,3576,895,1,0,0,0,3577,3578,5,451,0,0,3578,3579,3,892,446,0,3579,
        3580,5,340,0,0,3580,3581,3,892,446,0,3581,897,1,0,0,0,3582,3583,
        5,451,0,0,3583,3584,3,892,446,0,3584,899,1,0,0,0,3585,3586,3,784,
        392,0,3586,3587,5,436,0,0,3587,3588,3,404,202,0,3588,3589,5,437,
        0,0,3589,901,1,0,0,0,3590,3591,3,868,434,0,3591,3592,3,638,319,0,
        3592,3593,3,892,446,0,3593,903,1,0,0,0,341,914,921,930,938,955,960,
        967,972,981,997,1001,1006,1015,1019,1022,1026,1033,1041,1049,1057,
        1065,1073,1081,1086,1090,1100,1105,1117,1122,1126,1133,1138,1150,
        1162,1170,1182,1189,1198,1213,1224,1236,1242,1251,1260,1267,1272,
        1276,1281,1285,1291,1303,1310,1315,1320,1332,1336,1345,1350,1356,
        1365,1369,1372,1375,1379,1382,1386,1394,1406,1412,1427,1430,1442,
        1464,1471,1483,1488,1496,1506,1518,1524,1537,1550,1562,1568,1574,
        1581,1594,1606,1612,1618,1625,1640,1643,1651,1661,1664,1675,1678,
        1687,1690,1698,1701,1710,1713,1717,1720,1724,1733,1736,1740,1749,
        1752,1755,1763,1778,1784,1788,1792,1799,1807,1813,1828,1835,1839,
        1843,1852,1863,1874,1877,1888,1891,1894,1900,1910,1915,1919,1928,
        1931,1934,1944,1951,1954,1967,1973,1981,1984,1993,1996,2000,2008,
        2012,2015,2018,2024,2027,2030,2044,2056,2064,2073,2088,2090,2102,
        2113,2127,2134,2137,2141,2144,2148,2152,2165,2170,2175,2180,2187,
        2201,2212,2221,2227,2233,2241,2245,2264,2267,2271,2282,2288,2293,
        2301,2304,2320,2324,2331,2334,2337,2343,2346,2354,2357,2368,2372,
        2379,2395,2412,2416,2419,2423,2436,2440,2453,2458,2462,2466,2470,
        2474,2478,2482,2486,2490,2494,2498,2501,2506,2511,2524,2532,2538,
        2543,2548,2553,2558,2563,2568,2577,2600,2641,2664,2668,2673,2678,
        2684,2691,2699,2704,2717,2723,2730,2739,2757,2759,2780,2787,2793,
        2804,2827,2848,2883,2889,2898,2902,2910,2917,2936,2943,2947,2951,
        2955,2959,2963,2971,2988,2994,3000,3005,3011,3016,3024,3039,3051,
        3063,3072,3081,3087,3106,3113,3118,3122,3128,3138,3152,3159,3165,
        3174,3179,3183,3188,3195,3200,3207,3211,3215,3220,3225,3242,3249,
        3252,3261,3269,3276,3282,3293,3297,3312,3318,3326,3337,3351,3363,
        3371,3377,3379,3387,3391,3404,3417,3424,3437,3444,3450,3460,3467,
        3480,3483,3490,3499,3562,3564,3566,3572,3575
    ]

class NeoBasicParser ( Parser ):

    grammarFileName = "NeoBasicParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "'>>>>'", "'<<<<'", "'module'", 
                     "'applet'", "'notabene'", "'define'", "'undef'", "'use'", 
                     "'as'", "'of'", "'include'", "'interface'", "'public'", 
                     "'protected'", "'private'", "'type'", "'const'", "'let'", 
                     "'var'", "'cast'", "'fact'", "'func'", "'feed'", "'sub'", 
                     "'out'", "'raises'", "'nopanic'", "'delete'", "'macro'", 
                     "'val'", "'operator'", "'event'", "'enum'", "'struct'", 
                     "'proto'", "'trait'", "'class'", "'object'", "'extends'", 
                     "'implements'", "'mixes'", "'construct'", "'destruct'", 
                     "'property'", "'get'", "'set'", "'if'", "'then'", "'elif'", 
                     "'else'", "'match'", "'case'", "'fallthrough'", "'try'", 
                     "'catch'", "'otherwise'", "'unless'", "'till'", "'defer'", 
                     "'with'", "'do'", "'loop'", "'for'", "'each'", "'step'", 
                     "'while'", "'until'", "'upto'", "'next'", "'continue'", 
                     "'break'", "'return'", "'yield'", "'raise'", "'panic'", 
                     "'go'", "'into'", "'gosub'", "'fork'", "'await'", "'switch'", 
                     "'when'", "'default'", "'begin'", "'end'", "'at'", 
                     "'scan'", "'echo'", "'alert'", "'entry'", "'play'", 
                     "'this'", "'iota'", "'nth'", "'it'", "'self'", "'super'", 
                     "'parent'", "'all'", "'any'", "'lot'", "'nil'", "'one'", 
                     "'two'", "'lambda'", "'typeof'", "'sizeof'", "'instanceof'", 
                     "'ancestorof'", "'is'", "'in'", "'between'", "'like'", 
                     "'and'", "'AND'", "'andn'", "'nand'", "'or'", "'OR'", 
                     "'nor'", "'xor'", "'nxor'", "'not'", "'new'", "'nab'", 
                     "'del'", "'atom'", "'auto'", "'span'", "'view'", "'void'", 
                     "'bool8'", "'bool16'", "'bool32'", "'bool64'", "'bool128'", 
                     "'bool'", "'byte'", "'nat8'", "'nat16'", "'nat32'", 
                     "'nat64'", "'nat128'", "'natural'", "'bignatural'", 
                     "'int8'", "'int16'", "'int32'", "'int64'", "'int128'", 
                     "'int'", "'bigint'", "'real8'", "'real16'", "'real32'", 
                     "'real64'", "'real128'", "'real'", "'bigreal'", "'dec8'", 
                     "'dec16'", "'dec32'", "'dec64'", "'dec128'", "'decimal'", 
                     "'money'", "'ratio8'", "'ratio16'", "'ratio32'", "'ratio64'", 
                     "'ratio128'", "'ratio'", "'complex32'", "'complex64'", 
                     "'complex128'", "'complex'", "'quatern32'", "'quatern64'", 
                     "'quatern128'", "'quatern'", "'date'", "'elapse'", 
                     "'ascii'", "'wchar'", "'char8'", "'char16'", "'char32'", 
                     "'char'", "'ansi'", "'wstr'", "'string8'", "'string16'", 
                     "'string32'", "'string'", "'regex'", "'binary'", "'inet'", 
                     "'path'", "'uri'", "'range'", "'pair'", "'tuple'", 
                     "'Array'", "'List'", "'Map'", "'Channel'", "'Vector'", 
                     "'Matrix'", "'Set'", "'Queue'", "'Deque'", "'Xml'", 
                     "'Table'", "'Memo'", "'True'", "'False'", "'Nonzero'", 
                     "'Zero'", "'MinValue'", "'MaxValue'", "'NaN'", "'PositiveInfinity'", 
                     "'NegativeInfinity'", "'LocalDate'", "'LocalDateTime'", 
                     "'OffsetDate'", "'OffsetDateTime'", "'ZonedDate'", 
                     "'ZonedDateTime'", "'Tomorrow'", "'Today'", "'Now'", 
                     "'Yesterday'", "'Eon'", "'Epoch'", "'Letter'", "'Mark'", 
                     "'Digit'", "'Punctuation'", "'Symbol'", "'Separator'", 
                     "'NonPrintable'", "'Null'", "'Blank'", "'Nonblank'", 
                     "'Folder'", "'File'", "'LinkFile'", "'PipeFile'", "'SocketFile'", 
                     "'BlockDevice'", "'charDevice'", "'NullDevice'", "'Url'", 
                     "'Urn'", "'Ipv4'", "'Ipv6'", "'Result'", "'Okay'", 
                     "'Fail'", "'Maybe'", "'Some'", "'None'", "'Either'", 
                     "'Yea'", "'Nay'", "'Stream'", "'Datum'", "'EoT'", "'assert'", 
                     "'unit'", "'from'", "'once'", "'data'", "'call'", "'hide'", 
                     "'show'", "'stay'", "'pass'", "'past'", "'fail'", "'^'", 
                     "'^/'", "'*!'", "'++'", "'--'", "'+'", "'-'", "'...'", 
                     "'::'", "'**'", "'~~'", "'*'", "'/'", "'\\u00F7'", 
                     "'%'", "'%%'", "'%/'", "'%*'", "'%+'", "'%-'", "'%^'", 
                     "'<<'", "'>>'", "'>>>'", "'?:'", "'<=>'", "'=='", "'!='", 
                     "'~=='", "'~!='", "'<'", "'<='", "'>'", "'>='", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'?%'", "'!%'", "'!'", "'!!'", "'?'", 
                     "'??'", "'!?'", "'..'", "'>..'", "'..<'", "'>..<'", 
                     "':-'", "'->'", "'=>'", "'=>>'", "'|>'", "'&&'", "'?&'", 
                     "'!&'", "'||'", "'&>>'", "'&>'", "'&1>>'", "'&1>'", 
                     "'&2>>'", "'&2>'", "'='", "':='", "'~='", "'<-'", "'<<-'", 
                     "'<|'", "'^='", "'^/='", "'*='", "'/='", "'\\u00F7='", 
                     "'%='", "'%%='", "'%/='", "'%*='", "'%+='", "'%-='", 
                     "'%^='", "'+='", "'-='", "'|='", "'&='", "'<<='", "'>>='", 
                     "'>>>='", "'??='", "'&&='", "'||='", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'$*'", "'$?'", 
                     "'$!'", "'$$?'", "'$$!'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "'#!'", "'#$'", "'#?'", "'##?'", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'('", "')'", "'['", "']'", "'{'", "'}'", 
                     "'.'", "','", "';'", "':'", "'''", "'\"'", "'`'", "'@'", 
                     "'#'", "'$'", "'&'", "'\\'", "'~'", "'|'", "'_'", "'(\\'", 
                     "'[['", "']]'", "'{{'", "'}}'", "',,'", "';;'", "'^^'", 
                     "'</'", "'/>'", "'<>'", "'</>'" ]

    symbolicNames = [ "<INVALID>", "XML_CONTENT", "INDENT", "DEDENT", "MODULE", 
                      "APPLET", "NOTABENE", "DEFINE", "UNDEF", "USE", "AS", 
                      "OF", "INCLUDE", "INTERFACE", "PUBLIC", "PROTECTED", 
                      "PRIVATE", "TYPE", "CONST", "LET", "VAR", "CAST", 
                      "FACT", "FUNC", "FEED", "SUB", "OUT", "RAISES", "NOPANIC", 
                      "DELETE", "MACRO", "VAL", "OPERATOR", "EVENT", "ENUM", 
                      "STRUCT", "PROTO", "TRAIT", "CLASS", "OBJECT", "EXTENDS", 
                      "IMPLEMENTS", "MIXES", "CONSTRUCT", "DESTRUCT", "PROPERTY", 
                      "GETTER", "SETTER", "IF", "THEN", "ELIF", "ELSE", 
                      "MATCH", "CASE", "FALLTHROUGH", "TRY", "CATCH", "OTHERWISE", 
                      "UNLESS", "TILL", "DEFER", "WITH", "DO", "LOOP", "FOR", 
                      "EACH", "STEP", "WHILE", "UNTIL", "UPTO", "NEXT", 
                      "CONTINUE", "BREAK", "RETURN", "YIELD", "RAISE", "PANIC", 
                      "GO", "INTO", "GOSUB", "FORK", "AWAIT", "SWITCH", 
                      "WHEN", "DEFAULT", "BEGIN", "END", "AT", "SCAN", "ECHO", 
                      "ALERT", "ENTRY", "PLAY", "THIS", "IOTA", "NTH", "IT", 
                      "SELF", "SUPER", "PARENT", "ALL", "ANY", "LOT", "NIL", 
                      "ONE", "TWO", "LAMBDA", "TYPEOF", "SIZEOF", "INSTANCEOF", 
                      "ANCESTOROF", "IS", "IN", "BETWEEN", "LIKE", "AND", 
                      "NSC_AND", "AND_NOT", "NOT_AND", "OR", "NSC_OR", "NOT_OR", 
                      "XOR", "NOT_XOR", "NOT", "NEW", "NAB", "DEL", "ATOM", 
                      "AUTO", "SPAN", "VIEW", "VOID", "BOOL8", "BOOL16", 
                      "BOOL32", "BOOL64", "BOOL128", "BOOL", "BYTE", "NAT8", 
                      "NAT16", "NAT32", "NAT64", "NAT128", "NATURAL", "BIGNATURAL", 
                      "INT8", "INT16", "INT32", "INT64", "INT128", "INT", 
                      "BIGINT", "REAL8", "REAL16", "REAL32", "REAL64", "REAL128", 
                      "REAL", "BIGREAL", "DEC8", "DEC16", "DEC32", "DEC64", 
                      "DEC128", "DECIMAL", "MONEY", "RATIO8", "RATIO16", 
                      "RATIO32", "RATIO64", "RATIO128", "RATIO", "COMPLEX32", 
                      "COMPLEX64", "COMPLEX128", "COMPLEX", "QUATERN32", 
                      "QUATERN64", "QUATERN128", "QUATERN", "DATE", "ELAPSE", 
                      "ASCII", "WCHAR", "CHAR8", "CHAR16", "CHAR32", "CHAR", 
                      "ANSI", "WSTR", "STRING8", "STRING16", "STRING32", 
                      "STRING", "REGEX", "BINARY", "INET", "PATH", "URI", 
                      "RANGE", "PAIR", "TUPLE", "ARRAY", "LIST", "MAP", 
                      "CHANNEL", "VECTOR", "MATRIX", "SET", "QUEUE", "DEQUE", 
                      "XML", "TABLE", "MEMO", "TRUE", "FALSE", "NONZERO", 
                      "ZERO", "MINVALUE", "MAXVALUE", "NAN", "POSITIVEINFINITY", 
                      "NEGATIVEINFINITY", "LOCALDATE", "LOCALDATETIME", 
                      "OFFSETDATE", "OFFSETDATETIME", "ZONEDDATE", "ZONEDDATETIME", 
                      "TOMORROW", "TODAY", "NOW", "YESTERDAY", "EON", "EPOCH", 
                      "LETTER", "MARK", "DIGIT", "PUNCTUATION", "SYMBOL", 
                      "SEPARATOR", "NONPRINTABLE", "NULL", "BLANK", "NONBLANK", 
                      "FOLDER", "FILE", "LINKLINKFILE", "PIPEFILE", "SOCKETFILE", 
                      "BLOCKDEVICE", "CHARDEVICE", "NULLDEVICE", "URL", 
                      "URN", "IPV4", "IPV6", "RESULT", "OKAY", "FAIL", "MAYBE", 
                      "SOME", "NONE", "EITHER", "YEA", "NAY", "STREAM", 
                      "DATUM", "EOT", "ASSERT", "UNIT", "FROM", "ONCE", 
                      "DATA", "CALL", "HIDE", "SHOW", "STAY", "PASS", "PAST", 
                      "TFAIL", "CARET", "SQUARE_ROOT", "FACTORIAL", "INCREMENT", 
                      "DECREMENT", "PLUS", "HYPHEN", "ELLIPSIS", "LIFETIME", 
                      "NAMED_ARGUMENTS", "NAMED_OPTIONS", "ASTERISK", "SLASH", 
                      "DIVISION", "PERCENT", "QUOTIENT", "PERCENTAGE_RATE", 
                      "PERCENTAGE_AMOUNT", "PERCENTAGE_INCREASE", "PERCENTAGE_DECREASE", 
                      "PERCENTAGE_VARIATION", "DOUBLE_LEFT_ANGLE", "DOUBLE_RIGHT_ANGLE", 
                      "UNSIGNED_RIGHT_SHIFT", "ELVIS_TEST", "THREE_WAY_TEST", 
                      "STRICT_EQUALITY", "STRICT_INEQUALITY", "LOOSE_EQUALITY", 
                      "LOOSE_INEQUALITY", "LEFT_ANGLE", "LESS_OR_EQUALS", 
                      "RIGHT_ANGLE", "GREATER_OR_EQUALS", "IS_NOT", "NOT_IS", 
                      "NOT_IN", "NOT_BETWEEN", "NOT_LIKE", "NOT_INSTANCEOF", 
                      "NOT_ANCESTOROF", "NOT_EXTENDS", "NOT_IMPLEMENTS", 
                      "NOT_MIXES", "DIVISIBLE_BY", "NOT_DIVISIBLE_BY", "EXCLAMATION", 
                      "DOUBLE_EXCLAMATION", "QUESTION", "DOUBLE_QUESTION", 
                      "ERROR_NONE_COALESCING", "INTERVAL_INCLUSIVE", "INTERVAL_LEFT_EXCLUSIVE", 
                      "INTERVAL_RIGHT_EXCLUSIVE", "INTERVAL_EXCLUSIVE", 
                      "NECK_RULE", "FUNCTOR", "IMPLICIT_RETURN", "MONAD_BIND", 
                      "PIPELINE", "EXECUTE_SEQUENCE", "EXECUTE_SEQUENCE_OKAY", 
                      "EXECUTE_SEQUENCE_FAIL", "EXECUTE_BACKGROUND", "APPEND_OUTPUT_REDIRECTION", 
                      "OUTPUT_REDIRECTION", "APPEND_STDOUT_REDIRECTION", 
                      "STDOUT_REDIRECTION", "APPEND_STDERR_REDIRECTION", 
                      "STDERR_REDIRECTION", "EQUAL", "DERIVED_ASSIGNMENT", 
                      "LAZY_ASSIGNMENT", "POP_ONE_ASSIGNMENT", "PULL_ALL_ASSIGNMENT", 
                      "PIPE_ASSIGNMENT", "NTH_POWER_ASSIGNMENT", "NTH_ROOT_ASSIGNMENT", 
                      "MULTIPLICATION_ASSIGNMENT", "REAL_DIVISION_ASSIGNMENT", 
                      "INTEGER_DIVISION_ASSIGNMENT", "MODULO_ASSIGNMENT", 
                      "QUOTIENT_ASSIGNMENT", "PERCENTAGE_RATE_ASSIGNMENT", 
                      "PERCENTAGE_AMOUNT_ASSIGNMENT", "PERCENTAGE_INCREASE_ASSIGNMENT", 
                      "PERCENTAGE_DECREASE_ASSIGNMENT", "PERCENTAGE_VARIATION_ASSIGNMENT", 
                      "ADDITION_ASSIGNMENT", "SUBTRACTION_ASSIGNMENT", "SET_UNION_ASSIGNMENT", 
                      "SET_INTER_ASSIGNMENT", "LEFT_SHIFT_ASSIGNMENT", "SIGNED_RIGHT_SHIFT_ASSIGNMENT", 
                      "UNSIGNED_RIGHT_SHIFT_ASSIGNMENT", "NONE_COALESCING_ASSIGNMENT", 
                      "SHELL_PID_ASSIGNMENT", "SHELL_BKG_PID_ASSIGNMENT", 
                      "IDENTIFIER", "ATOM_IDENTIFIER", "ASPECT_IDENTIFIER", 
                      "NATURAL_LIT", "INTEGER_LIT", "DECIMAL_LIT", "REAL_LIT", 
                      "RATIO_LIT", "IMAGINARY_LIT", "ELAPSE_LIT", "TERM_LIT", 
                      "BINARY_LIT", "ASCII_LIT", "CHAR_LIT", "VERBATIM_SINGLELINE_STRING_LIT", 
                      "VERBATIM_MULTILINE_STRING_LIT", "TEMPLATE_SINGLELINE_STRING_LIT", 
                      "TEMPLATE_MULTILINE_STRING_LIT", "TRANSLATABLE_SINGLELINE_STRING_LIT", 
                      "TRANSLATABLE_MULTILINE_STRING_LIT", "HEREDOC_STRING_LIT", 
                      "REGULAR_EXPRESSION_LIT", "ATOM_DOT_LIT", "ATOM_ELAPSE_LIT", 
                      "ATOM_MUSIC_LIT", "SHELL_CURRENT_OPTIONS", "SHELL_EXIT_STATUS", 
                      "SHELL_ERROR_LEVEL", "SHELL_BKG_EXIT_STATUS", "SHELL_BKG_ERROR_LEVEL", 
                      "SHELL_FILE_DESCRIPTOR", "SHELL_CMD_ARGUMENT", "SHELL_ENV_VARIABLE", 
                      "SHELL_STRING_PATH", "SHELL_PATH", "ABSOLUTE_PATH", 
                      "RUBBERDUCK", "SONGBIRD", "SHEBANG", "SHERLOCK", "WOODSTOCK_LINE", 
                      "WOODSTOCK_BLOCK", "EOS", "ELC", "EOL", "HASHTAG", 
                      "LINE_COMMENT", "BLOCK_COMMENT", "CELL_COMMENT", "BOM", 
                      "WSP", "LEFT_PARENTHESIS", "RIGHT_PARENTHESIS", "LEFT_BRACKET", 
                      "RIGHT_BRACKET", "LEFT_CURLY", "RIGHT_CURLY", "DOT", 
                      "COMMA", "SEMICOLON", "COLON", "APOSTROPHE", "QUOTE", 
                      "BACKTICK", "AT_SIGN", "HASH", "DOLLAR", "AMPERSAND", 
                      "BACKSLASH", "TILDE", "PIPE", "UNDERSCORE", "LAMBDA_PARENTHESIS", 
                      "DOUBLE_LEFT_BRACKET", "DOUBLE_RIGHT_BRACKET", "DOUBLE_LEFT_CURLY", 
                      "DOUBLE_RIGHT_CURLY", "DOUBLE_COMMA", "DOUBLE_SEMICOLON", 
                      "DOUBLE_CARET", "XML_CLOSING_TAG", "XML_SELFCLOSING_TAG", 
                      "XML_OPENING_FRAGMENT", "XML_CLOSING_FRAGMENT", "UnexpectedCharacter" ]

    RULE_scriptProgram = 0
    RULE_sourceCodeProgram = 1
    RULE_oneLinerProgram = 2
    RULE_neoBasic = 3
    RULE_logicalInstructions = 4
    RULE_logicalInstructionSuite = 5
    RULE_logicalInstruction = 6
    RULE_directiveInstructionLiner = 7
    RULE_directiveInstructionSuite = 8
    RULE_instructionSentence = 9
    RULE_shebangInterpreter = 10
    RULE_directiveSentence = 11
    RULE_compilerPragmaDirective = 12
    RULE_shellLookupDirective = 13
    RULE_lookupStatement = 14
    RULE_canaryTestingDirective = 15
    RULE_testingLine = 16
    RULE_testingBlock = 17
    RULE_labelIdentifier = 18
    RULE_qualifiedIdentifier = 19
    RULE_decoratedIdentifier = 20
    RULE_decoratedType = 21
    RULE_typedDecoratedIdentifier = 22
    RULE_inferredDecoratedIdentifier = 23
    RULE_genericDecoratedIdentifier = 24
    RULE_declarationIdentifier = 25
    RULE_identifiers = 26
    RULE_qualifiedIdentifiers = 27
    RULE_decoratedIdentifiers = 28
    RULE_decoratedTypes = 29
    RULE_typedDecoratedIdentifiers = 30
    RULE_inferredDecoratedIdentifiers = 31
    RULE_topLevelSentence = 32
    RULE_identificationSentence = 33
    RULE_appletClause = 34
    RULE_moduleClause = 35
    RULE_notabeneClause = 36
    RULE_deflagSentence = 37
    RULE_defineClause = 38
    RULE_defineSuite = 39
    RULE_defineDeclareBlock = 40
    RULE_defineDeclare = 41
    RULE_defineDeclareSingle = 42
    RULE_defineDeclareMultiple = 43
    RULE_undefClause = 44
    RULE_undefSuite = 45
    RULE_undefDeclareBlock = 46
    RULE_undefDeclare = 47
    RULE_defAtom = 48
    RULE_defAtoms = 49
    RULE_useSentence = 50
    RULE_useClause = 51
    RULE_useSuite = 52
    RULE_useDeclareBlock = 53
    RULE_useDeclare = 54
    RULE_useDeclareSingle = 55
    RULE_useDeclareMultiple = 56
    RULE_useDeclareAs = 57
    RULE_useDeclareOf = 58
    RULE_interfaceSentence = 59
    RULE_interfaceClause = 60
    RULE_interfaceBody = 61
    RULE_includeSentence = 62
    RULE_includeClause = 63
    RULE_includeSuite = 64
    RULE_includeDeclareBlock = 65
    RULE_includeDeclare = 66
    RULE_includeDeclareSingle = 67
    RULE_includeDeclareMultiple = 68
    RULE_includeDeclareAs = 69
    RULE_declarationSentence = 70
    RULE_adhocMetadata = 71
    RULE_metadataDecorators = 72
    RULE_metadataGenerics = 73
    RULE_visibilityModifier = 74
    RULE_visibilityLabelSuite = 75
    RULE_extendsClause = 76
    RULE_implementsClause = 77
    RULE_mixesClause = 78
    RULE_raisesClause = 79
    RULE_parenthesizedArguments = 80
    RULE_namedArguments = 81
    RULE_namedArgument = 82
    RULE_parenthesizedParameters = 83
    RULE_procParameters = 84
    RULE_procParameter = 85
    RULE_modeParameterSpecifier = 86
    RULE_prefixParameterName = 87
    RULE_prefixParameterType = 88
    RULE_procResultType = 89
    RULE_procBody = 90
    RULE_procSuite = 91
    RULE_procSemex = 92
    RULE_procSpecifier = 93
    RULE_procImplicitReturn = 94
    RULE_procPatternGuards = 95
    RULE_guardBranchClause = 96
    RULE_guardElseClause = 97
    RULE_outerDeclareSentence = 98
    RULE_typeSentence = 99
    RULE_typeClause = 100
    RULE_typeSuite = 101
    RULE_typeDeclareBlock = 102
    RULE_typeDeclare = 103
    RULE_typeDeclareSingle = 104
    RULE_typeDeclareSubrange = 105
    RULE_constSentence = 106
    RULE_constClause = 107
    RULE_constSuite = 108
    RULE_constDeclareBlock = 109
    RULE_constDeclare = 110
    RULE_constDeclareSingle = 111
    RULE_constDeclareMultiple = 112
    RULE_constDeclareParallel = 113
    RULE_letSentence = 114
    RULE_letClause = 115
    RULE_letSuite = 116
    RULE_letDeclareBlock = 117
    RULE_letDeclare = 118
    RULE_letDeclareSingle = 119
    RULE_letDeclareMultiple = 120
    RULE_letDeclareParallel = 121
    RULE_varSentence = 122
    RULE_varClause = 123
    RULE_varSuite = 124
    RULE_varDeclareBlock = 125
    RULE_varDeclare = 126
    RULE_varDeclareSingle = 127
    RULE_varDeclareMultiple = 128
    RULE_varDeclareParallel = 129
    RULE_castSentence = 130
    RULE_castClause = 131
    RULE_factSentence = 132
    RULE_factClause = 133
    RULE_macroSentence = 134
    RULE_macroClause = 135
    RULE_funcSentence = 136
    RULE_funcClause = 137
    RULE_feedSentence = 138
    RULE_feedClause = 139
    RULE_subSentence = 140
    RULE_subClause = 141
    RULE_operatorSentence = 142
    RULE_operatorClause = 143
    RULE_operatorIdentifier = 144
    RULE_declarationOperator = 145
    RULE_eventSentence = 146
    RULE_eventClause = 147
    RULE_bracketedParameters = 148
    RULE_enumSentence = 149
    RULE_enumClause = 150
    RULE_enumType = 151
    RULE_enumBody = 152
    RULE_enumSemex = 153
    RULE_enumSuite = 154
    RULE_enumMembersBlock = 155
    RULE_enumMember = 156
    RULE_enumFieldSingle = 157
    RULE_enumFieldMultiple = 158
    RULE_structSentence = 159
    RULE_structClause = 160
    RULE_structBody = 161
    RULE_structSemex = 162
    RULE_structSuite = 163
    RULE_structMembersBlock = 164
    RULE_structMember = 165
    RULE_structFieldSingle = 166
    RULE_attributeTag = 167
    RULE_structFieldMultiple = 168
    RULE_structMemberEmbedded = 169
    RULE_protoSentence = 170
    RULE_protoClause = 171
    RULE_protoBody = 172
    RULE_traitSentence = 173
    RULE_traitClause = 174
    RULE_traitBody = 175
    RULE_classSentence = 176
    RULE_classClause = 177
    RULE_classBody = 178
    RULE_classSemex = 179
    RULE_classFieldMultiple = 180
    RULE_classFieldSimple = 181
    RULE_classSuite = 182
    RULE_objectSentence = 183
    RULE_objectClause = 184
    RULE_objectBody = 185
    RULE_innerDeclareSentence = 186
    RULE_constructSentence = 187
    RULE_constructClause = 188
    RULE_classInitializer = 189
    RULE_classInitializingMembers = 190
    RULE_classInitializingMember = 191
    RULE_destructSentence = 192
    RULE_destructClause = 193
    RULE_propertySentence = 194
    RULE_propertyClause = 195
    RULE_propertyBody = 196
    RULE_propertyAccessorSentence = 197
    RULE_propertyGetterClause = 198
    RULE_propertySetterClause = 199
    RULE_statementSentence = 200
    RULE_statementSuite = 201
    RULE_statementBlock = 202
    RULE_clauseStatement = 203
    RULE_simpleStatement = 204
    RULE_expressionStatement = 205
    RULE_emptyStatement = 206
    RULE_assignmentStatement = 207
    RULE_assignmentSingle = 208
    RULE_assignmentMultiple = 209
    RULE_assignmentParallel = 210
    RULE_consoleStatement = 211
    RULE_atClause = 212
    RULE_echoCommand = 213
    RULE_scanCommand = 214
    RULE_alertCommand = 215
    RULE_entryCommand = 216
    RULE_playCommand = 217
    RULE_deterministicStatement = 218
    RULE_continueSentence = 219
    RULE_breakSentence = 220
    RULE_fallthroughSentence = 221
    RULE_deferSentence = 222
    RULE_returnSentence = 223
    RULE_yieldSentence = 224
    RULE_raiseSentence = 225
    RULE_panicSentence = 226
    RULE_nondeterministicStatement = 227
    RULE_ifThenSentence = 228
    RULE_goSentence = 229
    RULE_awaitSentence = 230
    RULE_compoundStatement = 231
    RULE_conditionalStatement = 232
    RULE_iterationStatement = 233
    RULE_controlFlowStatement = 234
    RULE_concurrencyStatement = 235
    RULE_ifSentence = 236
    RULE_ifClause = 237
    RULE_elifClause = 238
    RULE_elseClause = 239
    RULE_matchSentence = 240
    RULE_matchClause = 241
    RULE_caseClause = 242
    RULE_trySentence = 243
    RULE_tryClause = 244
    RULE_catchClause = 245
    RULE_switchSentence = 246
    RULE_switchClause = 247
    RULE_whenClause = 248
    RULE_defaultClause = 249
    RULE_loopSentence = 250
    RULE_loopClause = 251
    RULE_loopBody = 252
    RULE_loopNoCheck = 253
    RULE_loopCheckFirst = 254
    RULE_loopCheckLast = 255
    RULE_nextClause = 256
    RULE_uptoClause = 257
    RULE_pretestClause = 258
    RULE_posttestClause = 259
    RULE_loopEachClause = 260
    RULE_loopWhileClause = 261
    RULE_loopUntilClause = 262
    RULE_thenClause = 263
    RULE_beginSentence = 264
    RULE_beginClause = 265
    RULE_endClause = 266
    RULE_withSentence = 267
    RULE_withClause = 268
    RULE_gosubSentence = 269
    RULE_gosubClause = 270
    RULE_forkClause = 271
    RULE_forEachClause = 272
    RULE_testingStatement = 273
    RULE_simpleTestStatement = 274
    RULE_compoundTestStatement = 275
    RULE_assertTestStatement = 276
    RULE_assertClause = 277
    RULE_unitTestStatement = 278
    RULE_unitClause = 279
    RULE_fromClause = 280
    RULE_onceClause = 281
    RULE_dataClause = 282
    RULE_dataTable = 283
    RULE_dataRow = 284
    RULE_callClause = 285
    RULE_hideClause = 286
    RULE_showClause = 287
    RULE_stayClause = 288
    RULE_passClause = 289
    RULE_pastClause = 290
    RULE_failClause = 291
    RULE_prefixUnaryOperator = 292
    RULE_unaryArithmeticOperator = 293
    RULE_unaryLogicalOperator = 294
    RULE_unaryArrayOperator = 295
    RULE_unarySpreadOperator = 296
    RULE_unaryCloneOperator = 297
    RULE_unaryMoveOperator = 298
    RULE_unaryMetaOperator = 299
    RULE_binaryArithmeticOperator = 300
    RULE_binaryExponentialOperator = 301
    RULE_binaryMultiplicativeOperator = 302
    RULE_binaryAdditiveOperator = 303
    RULE_bitShiftOperator = 304
    RULE_binaryConjunctionOperator = 305
    RULE_binaryExclusiveDisjunctionOperator = 306
    RULE_binaryDisjunctionOperator = 307
    RULE_binaryArrayOperator = 308
    RULE_binaryComparisonOperator = 309
    RULE_binaryRelationalOperator = 310
    RULE_binaryConditionalOperator = 311
    RULE_binaryMonadBindOperator = 312
    RULE_binaryPipelineOperator = 313
    RULE_coalescingOperator = 314
    RULE_executionFlowOperator = 315
    RULE_intervalOperator = 316
    RULE_leftIntervalOperator = 317
    RULE_rightIntervalOperator = 318
    RULE_assignmentOperator = 319
    RULE_singleAssignmentOperator = 320
    RULE_unpackingAssignmentOperator = 321
    RULE_compoundAssignmentOperator = 322
    RULE_overloadableOperator = 323
    RULE_symbolDecorators = 324
    RULE_symbolDecorator = 325
    RULE_annotationDecorator = 326
    RULE_aspectDecorator = 327
    RULE_taggedValuePairs = 328
    RULE_taggedValuePair = 329
    RULE_genericTypeParameters = 330
    RULE_typeParameters = 331
    RULE_typeParameter = 332
    RULE_types = 333
    RULE_type = 334
    RULE_prefixTypeModifier = 335
    RULE_postfixTypeWrapper = 336
    RULE_nativeType = 337
    RULE_escalarType = 338
    RULE_booleanType = 339
    RULE_numericType = 340
    RULE_numericNatural = 341
    RULE_numericInteger = 342
    RULE_numericDecimal = 343
    RULE_numericReal = 344
    RULE_numericRatio = 345
    RULE_numericComplex = 346
    RULE_numericQuaternion = 347
    RULE_temporalType = 348
    RULE_characterType = 349
    RULE_compoundType = 350
    RULE_sequenceType = 351
    RULE_compositeType = 352
    RULE_collectionType = 353
    RULE_optionType = 354
    RULE_metaType = 355
    RULE_procType = 356
    RULE_castType = 357
    RULE_factType = 358
    RULE_funcType = 359
    RULE_feedType = 360
    RULE_subType = 361
    RULE_operatorType = 362
    RULE_eventType = 363
    RULE_getterType = 364
    RULE_setterType = 365
    RULE_parenthesizedParameterTypes = 366
    RULE_bracketedParameterTypes = 367
    RULE_procParameterTypes = 368
    RULE_procParameterType = 369
    RULE_literal = 370
    RULE_escalarLiteral = 371
    RULE_booleanLiteral = 372
    RULE_numericLiteral = 373
    RULE_elapseLiteral = 374
    RULE_dateLiteral = 375
    RULE_characterLiteral = 376
    RULE_optionLiteral = 377
    RULE_resultLiteral = 378
    RULE_maybeLiteral = 379
    RULE_eitherLiteral = 380
    RULE_streamLiteral = 381
    RULE_compoundLiteral = 382
    RULE_sequenceLiteral = 383
    RULE_stringLiteral = 384
    RULE_musicalLiteral = 385
    RULE_compositeLiteral = 386
    RULE_rangeLiteral = 387
    RULE_pairLiteral = 388
    RULE_tupleLiteral = 389
    RULE_inetLiteral = 390
    RULE_uriLiteral = 391
    RULE_shellPathLiteral = 392
    RULE_shellPathLiterals = 393
    RULE_xmlDocLiteral = 394
    RULE_xmlDocElement = 395
    RULE_xmlElementPaired = 396
    RULE_xmlOpeningElement = 397
    RULE_xmlClosingElement = 398
    RULE_xmlElementSelfClosed = 399
    RULE_xmlDocFragment = 400
    RULE_xmlFragmentPaired = 401
    RULE_xmlFragmentSelfClosed = 402
    RULE_xmlTagName = 403
    RULE_xmlAttributes = 404
    RULE_xmlAttributeValue = 405
    RULE_xmlChildren = 406
    RULE_expressionPlaceholder = 407
    RULE_collectionLiteral = 408
    RULE_collectionLiteralValue = 409
    RULE_elements = 410
    RULE_element = 411
    RULE_elementKey = 412
    RULE_elementValue = 413
    RULE_arrayAosToSoaLiteral = 414
    RULE_listComprehension = 415
    RULE_comprehensionClause = 416
    RULE_objectLiteral = 417
    RULE_objectLiteralValue = 418
    RULE_objectMembers = 419
    RULE_objectMember = 420
    RULE_memberName = 421
    RULE_memberValue = 422
    RULE_lambdaLiteral = 423
    RULE_lambdaClause = 424
    RULE_lambdaStatement = 425
    RULE_arithmeticComprehension = 426
    RULE_predeclaredValue = 427
    RULE_predefinedIdentifier = 428
    RULE_predefinedShellValue = 429
    RULE_predeclaredFunctor = 430
    RULE_predeclaredFact = 431
    RULE_predeclaredFmap = 432
    RULE_primaryExpressions = 433
    RULE_primaryExpression = 434
    RULE_primaryOperand = 435
    RULE_primaryFunctor = 436
    RULE_sos_Expression = 437
    RULE_parenthesizedExpression = 438
    RULE_arrayIndexing = 439
    RULE_intervalExpression = 440
    RULE_sliceExpression = 441
    RULE_formatType = 442
    RULE_macroOption = 443
    RULE_juxtapositionExpression = 444
    RULE_expressions = 445
    RULE_expression = 446
    RULE_guardsExpression = 447
    RULE_guardClause = 448
    RULE_guardDefault = 449
    RULE_shellProcess = 450
    RULE_assignmentExpression = 451

    ruleNames =  [ "scriptProgram", "sourceCodeProgram", "oneLinerProgram", 
                   "neoBasic", "logicalInstructions", "logicalInstructionSuite", 
                   "logicalInstruction", "directiveInstructionLiner", "directiveInstructionSuite", 
                   "instructionSentence", "shebangInterpreter", "directiveSentence", 
                   "compilerPragmaDirective", "shellLookupDirective", "lookupStatement", 
                   "canaryTestingDirective", "testingLine", "testingBlock", 
                   "labelIdentifier", "qualifiedIdentifier", "decoratedIdentifier", 
                   "decoratedType", "typedDecoratedIdentifier", "inferredDecoratedIdentifier", 
                   "genericDecoratedIdentifier", "declarationIdentifier", 
                   "identifiers", "qualifiedIdentifiers", "decoratedIdentifiers", 
                   "decoratedTypes", "typedDecoratedIdentifiers", "inferredDecoratedIdentifiers", 
                   "topLevelSentence", "identificationSentence", "appletClause", 
                   "moduleClause", "notabeneClause", "deflagSentence", "defineClause", 
                   "defineSuite", "defineDeclareBlock", "defineDeclare", 
                   "defineDeclareSingle", "defineDeclareMultiple", "undefClause", 
                   "undefSuite", "undefDeclareBlock", "undefDeclare", "defAtom", 
                   "defAtoms", "useSentence", "useClause", "useSuite", "useDeclareBlock", 
                   "useDeclare", "useDeclareSingle", "useDeclareMultiple", 
                   "useDeclareAs", "useDeclareOf", "interfaceSentence", 
                   "interfaceClause", "interfaceBody", "includeSentence", 
                   "includeClause", "includeSuite", "includeDeclareBlock", 
                   "includeDeclare", "includeDeclareSingle", "includeDeclareMultiple", 
                   "includeDeclareAs", "declarationSentence", "adhocMetadata", 
                   "metadataDecorators", "metadataGenerics", "visibilityModifier", 
                   "visibilityLabelSuite", "extendsClause", "implementsClause", 
                   "mixesClause", "raisesClause", "parenthesizedArguments", 
                   "namedArguments", "namedArgument", "parenthesizedParameters", 
                   "procParameters", "procParameter", "modeParameterSpecifier", 
                   "prefixParameterName", "prefixParameterType", "procResultType", 
                   "procBody", "procSuite", "procSemex", "procSpecifier", 
                   "procImplicitReturn", "procPatternGuards", "guardBranchClause", 
                   "guardElseClause", "outerDeclareSentence", "typeSentence", 
                   "typeClause", "typeSuite", "typeDeclareBlock", "typeDeclare", 
                   "typeDeclareSingle", "typeDeclareSubrange", "constSentence", 
                   "constClause", "constSuite", "constDeclareBlock", "constDeclare", 
                   "constDeclareSingle", "constDeclareMultiple", "constDeclareParallel", 
                   "letSentence", "letClause", "letSuite", "letDeclareBlock", 
                   "letDeclare", "letDeclareSingle", "letDeclareMultiple", 
                   "letDeclareParallel", "varSentence", "varClause", "varSuite", 
                   "varDeclareBlock", "varDeclare", "varDeclareSingle", 
                   "varDeclareMultiple", "varDeclareParallel", "castSentence", 
                   "castClause", "factSentence", "factClause", "macroSentence", 
                   "macroClause", "funcSentence", "funcClause", "feedSentence", 
                   "feedClause", "subSentence", "subClause", "operatorSentence", 
                   "operatorClause", "operatorIdentifier", "declarationOperator", 
                   "eventSentence", "eventClause", "bracketedParameters", 
                   "enumSentence", "enumClause", "enumType", "enumBody", 
                   "enumSemex", "enumSuite", "enumMembersBlock", "enumMember", 
                   "enumFieldSingle", "enumFieldMultiple", "structSentence", 
                   "structClause", "structBody", "structSemex", "structSuite", 
                   "structMembersBlock", "structMember", "structFieldSingle", 
                   "attributeTag", "structFieldMultiple", "structMemberEmbedded", 
                   "protoSentence", "protoClause", "protoBody", "traitSentence", 
                   "traitClause", "traitBody", "classSentence", "classClause", 
                   "classBody", "classSemex", "classFieldMultiple", "classFieldSimple", 
                   "classSuite", "objectSentence", "objectClause", "objectBody", 
                   "innerDeclareSentence", "constructSentence", "constructClause", 
                   "classInitializer", "classInitializingMembers", "classInitializingMember", 
                   "destructSentence", "destructClause", "propertySentence", 
                   "propertyClause", "propertyBody", "propertyAccessorSentence", 
                   "propertyGetterClause", "propertySetterClause", "statementSentence", 
                   "statementSuite", "statementBlock", "clauseStatement", 
                   "simpleStatement", "expressionStatement", "emptyStatement", 
                   "assignmentStatement", "assignmentSingle", "assignmentMultiple", 
                   "assignmentParallel", "consoleStatement", "atClause", 
                   "echoCommand", "scanCommand", "alertCommand", "entryCommand", 
                   "playCommand", "deterministicStatement", "continueSentence", 
                   "breakSentence", "fallthroughSentence", "deferSentence", 
                   "returnSentence", "yieldSentence", "raiseSentence", "panicSentence", 
                   "nondeterministicStatement", "ifThenSentence", "goSentence", 
                   "awaitSentence", "compoundStatement", "conditionalStatement", 
                   "iterationStatement", "controlFlowStatement", "concurrencyStatement", 
                   "ifSentence", "ifClause", "elifClause", "elseClause", 
                   "matchSentence", "matchClause", "caseClause", "trySentence", 
                   "tryClause", "catchClause", "switchSentence", "switchClause", 
                   "whenClause", "defaultClause", "loopSentence", "loopClause", 
                   "loopBody", "loopNoCheck", "loopCheckFirst", "loopCheckLast", 
                   "nextClause", "uptoClause", "pretestClause", "posttestClause", 
                   "loopEachClause", "loopWhileClause", "loopUntilClause", 
                   "thenClause", "beginSentence", "beginClause", "endClause", 
                   "withSentence", "withClause", "gosubSentence", "gosubClause", 
                   "forkClause", "forEachClause", "testingStatement", "simpleTestStatement", 
                   "compoundTestStatement", "assertTestStatement", "assertClause", 
                   "unitTestStatement", "unitClause", "fromClause", "onceClause", 
                   "dataClause", "dataTable", "dataRow", "callClause", "hideClause", 
                   "showClause", "stayClause", "passClause", "pastClause", 
                   "failClause", "prefixUnaryOperator", "unaryArithmeticOperator", 
                   "unaryLogicalOperator", "unaryArrayOperator", "unarySpreadOperator", 
                   "unaryCloneOperator", "unaryMoveOperator", "unaryMetaOperator", 
                   "binaryArithmeticOperator", "binaryExponentialOperator", 
                   "binaryMultiplicativeOperator", "binaryAdditiveOperator", 
                   "bitShiftOperator", "binaryConjunctionOperator", "binaryExclusiveDisjunctionOperator", 
                   "binaryDisjunctionOperator", "binaryArrayOperator", "binaryComparisonOperator", 
                   "binaryRelationalOperator", "binaryConditionalOperator", 
                   "binaryMonadBindOperator", "binaryPipelineOperator", 
                   "coalescingOperator", "executionFlowOperator", "intervalOperator", 
                   "leftIntervalOperator", "rightIntervalOperator", "assignmentOperator", 
                   "singleAssignmentOperator", "unpackingAssignmentOperator", 
                   "compoundAssignmentOperator", "overloadableOperator", 
                   "symbolDecorators", "symbolDecorator", "annotationDecorator", 
                   "aspectDecorator", "taggedValuePairs", "taggedValuePair", 
                   "genericTypeParameters", "typeParameters", "typeParameter", 
                   "types", "type", "prefixTypeModifier", "postfixTypeWrapper", 
                   "nativeType", "escalarType", "booleanType", "numericType", 
                   "numericNatural", "numericInteger", "numericDecimal", 
                   "numericReal", "numericRatio", "numericComplex", "numericQuaternion", 
                   "temporalType", "characterType", "compoundType", "sequenceType", 
                   "compositeType", "collectionType", "optionType", "metaType", 
                   "procType", "castType", "factType", "funcType", "feedType", 
                   "subType", "operatorType", "eventType", "getterType", 
                   "setterType", "parenthesizedParameterTypes", "bracketedParameterTypes", 
                   "procParameterTypes", "procParameterType", "literal", 
                   "escalarLiteral", "booleanLiteral", "numericLiteral", 
                   "elapseLiteral", "dateLiteral", "characterLiteral", "optionLiteral", 
                   "resultLiteral", "maybeLiteral", "eitherLiteral", "streamLiteral", 
                   "compoundLiteral", "sequenceLiteral", "stringLiteral", 
                   "musicalLiteral", "compositeLiteral", "rangeLiteral", 
                   "pairLiteral", "tupleLiteral", "inetLiteral", "uriLiteral", 
                   "shellPathLiteral", "shellPathLiterals", "xmlDocLiteral", 
                   "xmlDocElement", "xmlElementPaired", "xmlOpeningElement", 
                   "xmlClosingElement", "xmlElementSelfClosed", "xmlDocFragment", 
                   "xmlFragmentPaired", "xmlFragmentSelfClosed", "xmlTagName", 
                   "xmlAttributes", "xmlAttributeValue", "xmlChildren", 
                   "expressionPlaceholder", "collectionLiteral", "collectionLiteralValue", 
                   "elements", "element", "elementKey", "elementValue", 
                   "arrayAosToSoaLiteral", "listComprehension", "comprehensionClause", 
                   "objectLiteral", "objectLiteralValue", "objectMembers", 
                   "objectMember", "memberName", "memberValue", "lambdaLiteral", 
                   "lambdaClause", "lambdaStatement", "arithmeticComprehension", 
                   "predeclaredValue", "predefinedIdentifier", "predefinedShellValue", 
                   "predeclaredFunctor", "predeclaredFact", "predeclaredFmap", 
                   "primaryExpressions", "primaryExpression", "primaryOperand", 
                   "primaryFunctor", "sos_Expression", "parenthesizedExpression", 
                   "arrayIndexing", "intervalExpression", "sliceExpression", 
                   "formatType", "macroOption", "juxtapositionExpression", 
                   "expressions", "expression", "guardsExpression", "guardClause", 
                   "guardDefault", "shellProcess", "assignmentExpression" ]

    EOF = Token.EOF
    XML_CONTENT=1
    INDENT=2
    DEDENT=3
    MODULE=4
    APPLET=5
    NOTABENE=6
    DEFINE=7
    UNDEF=8
    USE=9
    AS=10
    OF=11
    INCLUDE=12
    INTERFACE=13
    PUBLIC=14
    PROTECTED=15
    PRIVATE=16
    TYPE=17
    CONST=18
    LET=19
    VAR=20
    CAST=21
    FACT=22
    FUNC=23
    FEED=24
    SUB=25
    OUT=26
    RAISES=27
    NOPANIC=28
    DELETE=29
    MACRO=30
    VAL=31
    OPERATOR=32
    EVENT=33
    ENUM=34
    STRUCT=35
    PROTO=36
    TRAIT=37
    CLASS=38
    OBJECT=39
    EXTENDS=40
    IMPLEMENTS=41
    MIXES=42
    CONSTRUCT=43
    DESTRUCT=44
    PROPERTY=45
    GETTER=46
    SETTER=47
    IF=48
    THEN=49
    ELIF=50
    ELSE=51
    MATCH=52
    CASE=53
    FALLTHROUGH=54
    TRY=55
    CATCH=56
    OTHERWISE=57
    UNLESS=58
    TILL=59
    DEFER=60
    WITH=61
    DO=62
    LOOP=63
    FOR=64
    EACH=65
    STEP=66
    WHILE=67
    UNTIL=68
    UPTO=69
    NEXT=70
    CONTINUE=71
    BREAK=72
    RETURN=73
    YIELD=74
    RAISE=75
    PANIC=76
    GO=77
    INTO=78
    GOSUB=79
    FORK=80
    AWAIT=81
    SWITCH=82
    WHEN=83
    DEFAULT=84
    BEGIN=85
    END=86
    AT=87
    SCAN=88
    ECHO=89
    ALERT=90
    ENTRY=91
    PLAY=92
    THIS=93
    IOTA=94
    NTH=95
    IT=96
    SELF=97
    SUPER=98
    PARENT=99
    ALL=100
    ANY=101
    LOT=102
    NIL=103
    ONE=104
    TWO=105
    LAMBDA=106
    TYPEOF=107
    SIZEOF=108
    INSTANCEOF=109
    ANCESTOROF=110
    IS=111
    IN=112
    BETWEEN=113
    LIKE=114
    AND=115
    NSC_AND=116
    AND_NOT=117
    NOT_AND=118
    OR=119
    NSC_OR=120
    NOT_OR=121
    XOR=122
    NOT_XOR=123
    NOT=124
    NEW=125
    NAB=126
    DEL=127
    ATOM=128
    AUTO=129
    SPAN=130
    VIEW=131
    VOID=132
    BOOL8=133
    BOOL16=134
    BOOL32=135
    BOOL64=136
    BOOL128=137
    BOOL=138
    BYTE=139
    NAT8=140
    NAT16=141
    NAT32=142
    NAT64=143
    NAT128=144
    NATURAL=145
    BIGNATURAL=146
    INT8=147
    INT16=148
    INT32=149
    INT64=150
    INT128=151
    INT=152
    BIGINT=153
    REAL8=154
    REAL16=155
    REAL32=156
    REAL64=157
    REAL128=158
    REAL=159
    BIGREAL=160
    DEC8=161
    DEC16=162
    DEC32=163
    DEC64=164
    DEC128=165
    DECIMAL=166
    MONEY=167
    RATIO8=168
    RATIO16=169
    RATIO32=170
    RATIO64=171
    RATIO128=172
    RATIO=173
    COMPLEX32=174
    COMPLEX64=175
    COMPLEX128=176
    COMPLEX=177
    QUATERN32=178
    QUATERN64=179
    QUATERN128=180
    QUATERN=181
    DATE=182
    ELAPSE=183
    ASCII=184
    WCHAR=185
    CHAR8=186
    CHAR16=187
    CHAR32=188
    CHAR=189
    ANSI=190
    WSTR=191
    STRING8=192
    STRING16=193
    STRING32=194
    STRING=195
    REGEX=196
    BINARY=197
    INET=198
    PATH=199
    URI=200
    RANGE=201
    PAIR=202
    TUPLE=203
    ARRAY=204
    LIST=205
    MAP=206
    CHANNEL=207
    VECTOR=208
    MATRIX=209
    SET=210
    QUEUE=211
    DEQUE=212
    XML=213
    TABLE=214
    MEMO=215
    TRUE=216
    FALSE=217
    NONZERO=218
    ZERO=219
    MINVALUE=220
    MAXVALUE=221
    NAN=222
    POSITIVEINFINITY=223
    NEGATIVEINFINITY=224
    LOCALDATE=225
    LOCALDATETIME=226
    OFFSETDATE=227
    OFFSETDATETIME=228
    ZONEDDATE=229
    ZONEDDATETIME=230
    TOMORROW=231
    TODAY=232
    NOW=233
    YESTERDAY=234
    EON=235
    EPOCH=236
    LETTER=237
    MARK=238
    DIGIT=239
    PUNCTUATION=240
    SYMBOL=241
    SEPARATOR=242
    NONPRINTABLE=243
    NULL=244
    BLANK=245
    NONBLANK=246
    FOLDER=247
    FILE=248
    LINKLINKFILE=249
    PIPEFILE=250
    SOCKETFILE=251
    BLOCKDEVICE=252
    CHARDEVICE=253
    NULLDEVICE=254
    URL=255
    URN=256
    IPV4=257
    IPV6=258
    RESULT=259
    OKAY=260
    FAIL=261
    MAYBE=262
    SOME=263
    NONE=264
    EITHER=265
    YEA=266
    NAY=267
    STREAM=268
    DATUM=269
    EOT=270
    ASSERT=271
    UNIT=272
    FROM=273
    ONCE=274
    DATA=275
    CALL=276
    HIDE=277
    SHOW=278
    STAY=279
    PASS=280
    PAST=281
    TFAIL=282
    CARET=283
    SQUARE_ROOT=284
    FACTORIAL=285
    INCREMENT=286
    DECREMENT=287
    PLUS=288
    HYPHEN=289
    ELLIPSIS=290
    LIFETIME=291
    NAMED_ARGUMENTS=292
    NAMED_OPTIONS=293
    ASTERISK=294
    SLASH=295
    DIVISION=296
    PERCENT=297
    QUOTIENT=298
    PERCENTAGE_RATE=299
    PERCENTAGE_AMOUNT=300
    PERCENTAGE_INCREASE=301
    PERCENTAGE_DECREASE=302
    PERCENTAGE_VARIATION=303
    DOUBLE_LEFT_ANGLE=304
    DOUBLE_RIGHT_ANGLE=305
    UNSIGNED_RIGHT_SHIFT=306
    ELVIS_TEST=307
    THREE_WAY_TEST=308
    STRICT_EQUALITY=309
    STRICT_INEQUALITY=310
    LOOSE_EQUALITY=311
    LOOSE_INEQUALITY=312
    LEFT_ANGLE=313
    LESS_OR_EQUALS=314
    RIGHT_ANGLE=315
    GREATER_OR_EQUALS=316
    IS_NOT=317
    NOT_IS=318
    NOT_IN=319
    NOT_BETWEEN=320
    NOT_LIKE=321
    NOT_INSTANCEOF=322
    NOT_ANCESTOROF=323
    NOT_EXTENDS=324
    NOT_IMPLEMENTS=325
    NOT_MIXES=326
    DIVISIBLE_BY=327
    NOT_DIVISIBLE_BY=328
    EXCLAMATION=329
    DOUBLE_EXCLAMATION=330
    QUESTION=331
    DOUBLE_QUESTION=332
    ERROR_NONE_COALESCING=333
    INTERVAL_INCLUSIVE=334
    INTERVAL_LEFT_EXCLUSIVE=335
    INTERVAL_RIGHT_EXCLUSIVE=336
    INTERVAL_EXCLUSIVE=337
    NECK_RULE=338
    FUNCTOR=339
    IMPLICIT_RETURN=340
    MONAD_BIND=341
    PIPELINE=342
    EXECUTE_SEQUENCE=343
    EXECUTE_SEQUENCE_OKAY=344
    EXECUTE_SEQUENCE_FAIL=345
    EXECUTE_BACKGROUND=346
    APPEND_OUTPUT_REDIRECTION=347
    OUTPUT_REDIRECTION=348
    APPEND_STDOUT_REDIRECTION=349
    STDOUT_REDIRECTION=350
    APPEND_STDERR_REDIRECTION=351
    STDERR_REDIRECTION=352
    EQUAL=353
    DERIVED_ASSIGNMENT=354
    LAZY_ASSIGNMENT=355
    POP_ONE_ASSIGNMENT=356
    PULL_ALL_ASSIGNMENT=357
    PIPE_ASSIGNMENT=358
    NTH_POWER_ASSIGNMENT=359
    NTH_ROOT_ASSIGNMENT=360
    MULTIPLICATION_ASSIGNMENT=361
    REAL_DIVISION_ASSIGNMENT=362
    INTEGER_DIVISION_ASSIGNMENT=363
    MODULO_ASSIGNMENT=364
    QUOTIENT_ASSIGNMENT=365
    PERCENTAGE_RATE_ASSIGNMENT=366
    PERCENTAGE_AMOUNT_ASSIGNMENT=367
    PERCENTAGE_INCREASE_ASSIGNMENT=368
    PERCENTAGE_DECREASE_ASSIGNMENT=369
    PERCENTAGE_VARIATION_ASSIGNMENT=370
    ADDITION_ASSIGNMENT=371
    SUBTRACTION_ASSIGNMENT=372
    SET_UNION_ASSIGNMENT=373
    SET_INTER_ASSIGNMENT=374
    LEFT_SHIFT_ASSIGNMENT=375
    SIGNED_RIGHT_SHIFT_ASSIGNMENT=376
    UNSIGNED_RIGHT_SHIFT_ASSIGNMENT=377
    NONE_COALESCING_ASSIGNMENT=378
    SHELL_PID_ASSIGNMENT=379
    SHELL_BKG_PID_ASSIGNMENT=380
    IDENTIFIER=381
    ATOM_IDENTIFIER=382
    ASPECT_IDENTIFIER=383
    NATURAL_LIT=384
    INTEGER_LIT=385
    DECIMAL_LIT=386
    REAL_LIT=387
    RATIO_LIT=388
    IMAGINARY_LIT=389
    ELAPSE_LIT=390
    TERM_LIT=391
    BINARY_LIT=392
    ASCII_LIT=393
    CHAR_LIT=394
    VERBATIM_SINGLELINE_STRING_LIT=395
    VERBATIM_MULTILINE_STRING_LIT=396
    TEMPLATE_SINGLELINE_STRING_LIT=397
    TEMPLATE_MULTILINE_STRING_LIT=398
    TRANSLATABLE_SINGLELINE_STRING_LIT=399
    TRANSLATABLE_MULTILINE_STRING_LIT=400
    HEREDOC_STRING_LIT=401
    REGULAR_EXPRESSION_LIT=402
    ATOM_DOT_LIT=403
    ATOM_ELAPSE_LIT=404
    ATOM_MUSIC_LIT=405
    SHELL_CURRENT_OPTIONS=406
    SHELL_EXIT_STATUS=407
    SHELL_ERROR_LEVEL=408
    SHELL_BKG_EXIT_STATUS=409
    SHELL_BKG_ERROR_LEVEL=410
    SHELL_FILE_DESCRIPTOR=411
    SHELL_CMD_ARGUMENT=412
    SHELL_ENV_VARIABLE=413
    SHELL_STRING_PATH=414
    SHELL_PATH=415
    ABSOLUTE_PATH=416
    RUBBERDUCK=417
    SONGBIRD=418
    SHEBANG=419
    SHERLOCK=420
    WOODSTOCK_LINE=421
    WOODSTOCK_BLOCK=422
    EOS=423
    ELC=424
    EOL=425
    HASHTAG=426
    LINE_COMMENT=427
    BLOCK_COMMENT=428
    CELL_COMMENT=429
    BOM=430
    WSP=431
    LEFT_PARENTHESIS=432
    RIGHT_PARENTHESIS=433
    LEFT_BRACKET=434
    RIGHT_BRACKET=435
    LEFT_CURLY=436
    RIGHT_CURLY=437
    DOT=438
    COMMA=439
    SEMICOLON=440
    COLON=441
    APOSTROPHE=442
    QUOTE=443
    BACKTICK=444
    AT_SIGN=445
    HASH=446
    DOLLAR=447
    AMPERSAND=448
    BACKSLASH=449
    TILDE=450
    PIPE=451
    UNDERSCORE=452
    LAMBDA_PARENTHESIS=453
    DOUBLE_LEFT_BRACKET=454
    DOUBLE_RIGHT_BRACKET=455
    DOUBLE_LEFT_CURLY=456
    DOUBLE_RIGHT_CURLY=457
    DOUBLE_COMMA=458
    DOUBLE_SEMICOLON=459
    DOUBLE_CARET=460
    XML_CLOSING_TAG=461
    XML_SELFCLOSING_TAG=462
    XML_OPENING_FRAGMENT=463
    XML_CLOSING_FRAGMENT=464
    UnexpectedCharacter=465

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ScriptProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shebangInterpreter(self):
            return self.getTypedRuleContext(NeoBasicParser.ShebangInterpreterContext,0)


        def sourceCodeProgram(self):
            return self.getTypedRuleContext(NeoBasicParser.SourceCodeProgramContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_scriptProgram

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScriptProgram" ):
                listener.enterScriptProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScriptProgram" ):
                listener.exitScriptProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitScriptProgram" ):
                return visitor.visitScriptProgram(self)
            else:
                return visitor.visitChildren(self)




    def scriptProgram(self):

        localctx = NeoBasicParser.ScriptProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_scriptProgram)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 904
            self.shebangInterpreter()
            self.state = 905
            self.sourceCodeProgram()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SourceCodeProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalInstructions(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_sourceCodeProgram

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSourceCodeProgram" ):
                listener.enterSourceCodeProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSourceCodeProgram" ):
                listener.exitSourceCodeProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSourceCodeProgram" ):
                return visitor.visitSourceCodeProgram(self)
            else:
                return visitor.visitChildren(self)




    def sourceCodeProgram(self):

        localctx = NeoBasicParser.SourceCodeProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_sourceCodeProgram)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 907
            self.logicalInstructions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OneLinerProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalInstruction(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_oneLinerProgram

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOneLinerProgram" ):
                listener.enterOneLinerProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOneLinerProgram" ):
                listener.exitOneLinerProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOneLinerProgram" ):
                return visitor.visitOneLinerProgram(self)
            else:
                return visitor.visitChildren(self)




    def oneLinerProgram(self):

        localctx = NeoBasicParser.OneLinerProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_oneLinerProgram)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 909
            self.logicalInstruction()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NeoBasicContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def scriptProgram(self):
            return self.getTypedRuleContext(NeoBasicParser.ScriptProgramContext,0)


        def sourceCodeProgram(self):
            return self.getTypedRuleContext(NeoBasicParser.SourceCodeProgramContext,0)


        def oneLinerProgram(self):
            return self.getTypedRuleContext(NeoBasicParser.OneLinerProgramContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_neoBasic

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNeoBasic" ):
                listener.enterNeoBasic(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNeoBasic" ):
                listener.exitNeoBasic(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNeoBasic" ):
                return visitor.visitNeoBasic(self)
            else:
                return visitor.visitChildren(self)




    def neoBasic(self):

        localctx = NeoBasicParser.NeoBasicContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_neoBasic)
        try:
            self.state = 914
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 911
                self.scriptProgram()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 912
                self.sourceCodeProgram()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 913
                self.oneLinerProgram()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalInstructionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalInstruction(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.LogicalInstructionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_logicalInstructions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalInstructions" ):
                listener.enterLogicalInstructions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalInstructions" ):
                listener.exitLogicalInstructions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalInstructions" ):
                return visitor.visitLogicalInstructions(self)
            else:
                return visitor.visitChildren(self)




    def logicalInstructions(self):

        localctx = NeoBasicParser.LogicalInstructionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_logicalInstructions)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 919 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 916
                    self.logicalInstruction()
                    self.state = 917
                    self.match(NeoBasicParser.EOS)

                else:
                    raise NoViableAltException(self)
                self.state = 921 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,1,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalInstructionSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def logicalInstruction(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.LogicalInstructionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionContext,i)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_logicalInstructionSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalInstructionSuite" ):
                listener.enterLogicalInstructionSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalInstructionSuite" ):
                listener.exitLogicalInstructionSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalInstructionSuite" ):
                return visitor.visitLogicalInstructionSuite(self)
            else:
                return visitor.visitChildren(self)




    def logicalInstructionSuite(self):

        localctx = NeoBasicParser.LogicalInstructionSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_logicalInstructionSuite)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 923
            self.match(NeoBasicParser.EOS)
            self.state = 924
            self.match(NeoBasicParser.INDENT)
            self.state = 925
            self.logicalInstruction()
            self.state = 930
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==423:
                self.state = 926
                self.match(NeoBasicParser.EOS)
                self.state = 927
                self.logicalInstruction()
                self.state = 932
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 933
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalInstructionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def directiveInstructionLiner(self):
            return self.getTypedRuleContext(NeoBasicParser.DirectiveInstructionLinerContext,0)


        def directiveInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.DirectiveInstructionSuiteContext,0)


        def instructionSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.InstructionSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_logicalInstruction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalInstruction" ):
                listener.enterLogicalInstruction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalInstruction" ):
                listener.exitLogicalInstruction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalInstruction" ):
                return visitor.visitLogicalInstruction(self)
            else:
                return visitor.visitChildren(self)




    def logicalInstruction(self):

        localctx = NeoBasicParser.LogicalInstructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_logicalInstruction)
        try:
            self.state = 938
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 935
                self.directiveInstructionLiner()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 936
                self.directiveInstructionSuite()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 937
                self.instructionSentence()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DirectiveInstructionLinerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def directiveSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.DirectiveSentenceContext,0)


        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def logicalInstruction(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_directiveInstructionLiner

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirectiveInstructionLiner" ):
                listener.enterDirectiveInstructionLiner(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirectiveInstructionLiner" ):
                listener.exitDirectiveInstructionLiner(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDirectiveInstructionLiner" ):
                return visitor.visitDirectiveInstructionLiner(self)
            else:
                return visitor.visitChildren(self)




    def directiveInstructionLiner(self):

        localctx = NeoBasicParser.DirectiveInstructionLinerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_directiveInstructionLiner)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 940
            self.directiveSentence()
            self.state = 941
            self.match(NeoBasicParser.EOS)
            self.state = 942
            self.logicalInstruction()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DirectiveInstructionSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def directiveSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.DirectiveSentenceContext,0)


        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_directiveInstructionSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirectiveInstructionSuite" ):
                listener.enterDirectiveInstructionSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirectiveInstructionSuite" ):
                listener.exitDirectiveInstructionSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDirectiveInstructionSuite" ):
                return visitor.visitDirectiveInstructionSuite(self)
            else:
                return visitor.visitChildren(self)




    def directiveInstructionSuite(self):

        localctx = NeoBasicParser.DirectiveInstructionSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_directiveInstructionSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 944
            self.directiveSentence()
            self.state = 945
            self.logicalInstructionSuite()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InstructionSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SONGBIRD(self):
            return self.getToken(NeoBasicParser.SONGBIRD, 0)

        def instructionSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.InstructionSentenceContext,0)


        def RUBBERDUCK(self):
            return self.getToken(NeoBasicParser.RUBBERDUCK, 0)

        def topLevelSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.TopLevelSentenceContext,0)


        def declarationSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationSentenceContext,0)


        def statementSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_instructionSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstructionSentence" ):
                listener.enterInstructionSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstructionSentence" ):
                listener.exitInstructionSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInstructionSentence" ):
                return visitor.visitInstructionSentence(self)
            else:
                return visitor.visitChildren(self)




    def instructionSentence(self):

        localctx = NeoBasicParser.InstructionSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_instructionSentence)
        try:
            self.state = 955
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 947
                self.match(NeoBasicParser.SONGBIRD)
                self.state = 948
                self.instructionSentence()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 949
                self.match(NeoBasicParser.RUBBERDUCK)
                self.state = 950
                self.instructionSentence()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 951
                self.topLevelSentence()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 952
                self.declarationSentence()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 953
                self.statementSentence()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShebangInterpreterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHEBANG(self):
            return self.getToken(NeoBasicParser.SHEBANG, 0)

        def ABSOLUTE_PATH(self):
            return self.getToken(NeoBasicParser.ABSOLUTE_PATH, 0)

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_shebangInterpreter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShebangInterpreter" ):
                listener.enterShebangInterpreter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShebangInterpreter" ):
                listener.exitShebangInterpreter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShebangInterpreter" ):
                return visitor.visitShebangInterpreter(self)
            else:
                return visitor.visitChildren(self)




    def shebangInterpreter(self):

        localctx = NeoBasicParser.ShebangInterpreterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_shebangInterpreter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 957
            self.match(NeoBasicParser.SHEBANG)
            self.state = 958
            self.match(NeoBasicParser.ABSOLUTE_PATH)
            self.state = 960
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 247385886433392) != 0) or ((((_la - 93)) & ~0x3f) == 0 and ((1 << (_la - 93)) & -4128769) != 0) or ((((_la - 157)) & ~0x3f) == 0 and ((1 << (_la - 157)) & -1) != 0) or ((((_la - 221)) & ~0x3f) == 0 and ((1 << (_la - 221)) & -4610560118520676353) != 0) or ((((_la - 285)) & ~0x3f) == 0 and ((1 << (_la - 285)) & 2814750039735871) != 0) or ((((_la - 381)) & ~0x3f) == 0 and ((1 << (_la - 381)) & 47287830447128569) != 0) or ((((_la - 451)) & ~0x3f) == 0 and ((1 << (_la - 451)) & 12295) != 0):
                self.state = 959
                self.expression(0)


            self.state = 962
            self.match(NeoBasicParser.EOS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DirectiveSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def compilerPragmaDirective(self):
            return self.getTypedRuleContext(NeoBasicParser.CompilerPragmaDirectiveContext,0)


        def shellLookupDirective(self):
            return self.getTypedRuleContext(NeoBasicParser.ShellLookupDirectiveContext,0)


        def canaryTestingDirective(self):
            return self.getTypedRuleContext(NeoBasicParser.CanaryTestingDirectiveContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_directiveSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirectiveSentence" ):
                listener.enterDirectiveSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirectiveSentence" ):
                listener.exitDirectiveSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDirectiveSentence" ):
                return visitor.visitDirectiveSentence(self)
            else:
                return visitor.visitChildren(self)




    def directiveSentence(self):

        localctx = NeoBasicParser.DirectiveSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_directiveSentence)
        try:
            self.state = 967
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [419]:
                self.enterOuterAlt(localctx, 1)
                self.state = 964
                self.compilerPragmaDirective()
                pass
            elif token in [420]:
                self.enterOuterAlt(localctx, 2)
                self.state = 965
                self.shellLookupDirective()
                pass
            elif token in [421, 422]:
                self.enterOuterAlt(localctx, 3)
                self.state = 966
                self.canaryTestingDirective()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompilerPragmaDirectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHEBANG(self):
            return self.getToken(NeoBasicParser.SHEBANG, 0)

        def IDENTIFIER(self):
            return self.getToken(NeoBasicParser.IDENTIFIER, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_compilerPragmaDirective

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompilerPragmaDirective" ):
                listener.enterCompilerPragmaDirective(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompilerPragmaDirective" ):
                listener.exitCompilerPragmaDirective(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompilerPragmaDirective" ):
                return visitor.visitCompilerPragmaDirective(self)
            else:
                return visitor.visitChildren(self)




    def compilerPragmaDirective(self):

        localctx = NeoBasicParser.CompilerPragmaDirectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_compilerPragmaDirective)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 969
            self.match(NeoBasicParser.SHEBANG)
            self.state = 970
            self.match(NeoBasicParser.IDENTIFIER)
            self.state = 972
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 247385886433392) != 0) or ((((_la - 93)) & ~0x3f) == 0 and ((1 << (_la - 93)) & -4128769) != 0) or ((((_la - 157)) & ~0x3f) == 0 and ((1 << (_la - 157)) & -1) != 0) or ((((_la - 221)) & ~0x3f) == 0 and ((1 << (_la - 221)) & -4610560118520676353) != 0) or ((((_la - 285)) & ~0x3f) == 0 and ((1 << (_la - 285)) & 2814750039735871) != 0) or ((((_la - 381)) & ~0x3f) == 0 and ((1 << (_la - 381)) & 47287830447128569) != 0) or ((((_la - 451)) & ~0x3f) == 0 and ((1 << (_la - 451)) & 12295) != 0):
                self.state = 971
                self.expressions()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShellLookupDirectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHERLOCK(self):
            return self.getToken(NeoBasicParser.SHERLOCK, 0)

        def lookupStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.LookupStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_shellLookupDirective

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShellLookupDirective" ):
                listener.enterShellLookupDirective(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShellLookupDirective" ):
                listener.exitShellLookupDirective(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShellLookupDirective" ):
                return visitor.visitShellLookupDirective(self)
            else:
                return visitor.visitChildren(self)




    def shellLookupDirective(self):

        localctx = NeoBasicParser.ShellLookupDirectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_shellLookupDirective)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 974
            self.match(NeoBasicParser.SHERLOCK)
            self.state = 975
            self.lookupStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LookupStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_lookupStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLookupStatement" ):
                listener.enterLookupStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLookupStatement" ):
                listener.exitLookupStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLookupStatement" ):
                return visitor.visitLookupStatement(self)
            else:
                return visitor.visitChildren(self)




    def lookupStatement(self):

        localctx = NeoBasicParser.LookupStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_lookupStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 977
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CanaryTestingDirectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def testingLine(self):
            return self.getTypedRuleContext(NeoBasicParser.TestingLineContext,0)


        def testingBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.TestingBlockContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_canaryTestingDirective

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCanaryTestingDirective" ):
                listener.enterCanaryTestingDirective(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCanaryTestingDirective" ):
                listener.exitCanaryTestingDirective(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCanaryTestingDirective" ):
                return visitor.visitCanaryTestingDirective(self)
            else:
                return visitor.visitChildren(self)




    def canaryTestingDirective(self):

        localctx = NeoBasicParser.CanaryTestingDirectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_canaryTestingDirective)
        try:
            self.state = 981
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [421]:
                self.enterOuterAlt(localctx, 1)
                self.state = 979
                self.testingLine()
                pass
            elif token in [422]:
                self.enterOuterAlt(localctx, 2)
                self.state = 980
                self.testingBlock()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TestingLineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WOODSTOCK_LINE(self):
            return self.getToken(NeoBasicParser.WOODSTOCK_LINE, 0)

        def logicalInstruction(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_testingLine

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTestingLine" ):
                listener.enterTestingLine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTestingLine" ):
                listener.exitTestingLine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTestingLine" ):
                return visitor.visitTestingLine(self)
            else:
                return visitor.visitChildren(self)




    def testingLine(self):

        localctx = NeoBasicParser.TestingLineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_testingLine)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 983
            self.match(NeoBasicParser.WOODSTOCK_LINE)
            self.state = 984
            self.logicalInstruction()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TestingBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WOODSTOCK_BLOCK(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.WOODSTOCK_BLOCK)
            else:
                return self.getToken(NeoBasicParser.WOODSTOCK_BLOCK, i)

        def logicalInstructions(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_testingBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTestingBlock" ):
                listener.enterTestingBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTestingBlock" ):
                listener.exitTestingBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTestingBlock" ):
                return visitor.visitTestingBlock(self)
            else:
                return visitor.visitChildren(self)




    def testingBlock(self):

        localctx = NeoBasicParser.TestingBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_testingBlock)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 986
            self.match(NeoBasicParser.WOODSTOCK_BLOCK)
            self.state = 987
            self.logicalInstructions()
            self.state = 988
            self.match(NeoBasicParser.WOODSTOCK_BLOCK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(NeoBasicParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_labelIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelIdentifier" ):
                listener.enterLabelIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelIdentifier" ):
                listener.exitLabelIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabelIdentifier" ):
                return visitor.visitLabelIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def labelIdentifier(self):

        localctx = NeoBasicParser.LabelIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_labelIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 990
            self.match(NeoBasicParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QualifiedIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.IDENTIFIER)
            else:
                return self.getToken(NeoBasicParser.IDENTIFIER, i)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.DOT)
            else:
                return self.getToken(NeoBasicParser.DOT, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_qualifiedIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQualifiedIdentifier" ):
                listener.enterQualifiedIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQualifiedIdentifier" ):
                listener.exitQualifiedIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQualifiedIdentifier" ):
                return visitor.visitQualifiedIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def qualifiedIdentifier(self):

        localctx = NeoBasicParser.QualifiedIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_qualifiedIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 992
            self.match(NeoBasicParser.IDENTIFIER)
            self.state = 997
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 993
                    self.match(NeoBasicParser.DOT)
                    self.state = 994
                    self.match(NeoBasicParser.IDENTIFIER) 
                self.state = 999
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecoratedIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(NeoBasicParser.IDENTIFIER, 0)

        def metadataDecorators(self):
            return self.getTypedRuleContext(NeoBasicParser.MetadataDecoratorsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_decoratedIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecoratedIdentifier" ):
                listener.enterDecoratedIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecoratedIdentifier" ):
                listener.exitDecoratedIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDecoratedIdentifier" ):
                return visitor.visitDecoratedIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def decoratedIdentifier(self):

        localctx = NeoBasicParser.DecoratedIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_decoratedIdentifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1001
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==382 or _la==383:
                self.state = 1000
                self.metadataDecorators()


            self.state = 1003
            self.match(NeoBasicParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecoratedTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def metadataDecorators(self):
            return self.getTypedRuleContext(NeoBasicParser.MetadataDecoratorsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_decoratedType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecoratedType" ):
                listener.enterDecoratedType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecoratedType" ):
                listener.exitDecoratedType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDecoratedType" ):
                return visitor.visitDecoratedType(self)
            else:
                return visitor.visitChildren(self)




    def decoratedType(self):

        localctx = NeoBasicParser.DecoratedTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_decoratedType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1006
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==382 or _la==383:
                self.state = 1005
                self.metadataDecorators()


            self.state = 1008
            self.type_(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypedDecoratedIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def decoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DecoratedIdentifierContext,0)


        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_typedDecoratedIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypedDecoratedIdentifier" ):
                listener.enterTypedDecoratedIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypedDecoratedIdentifier" ):
                listener.exitTypedDecoratedIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypedDecoratedIdentifier" ):
                return visitor.visitTypedDecoratedIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def typedDecoratedIdentifier(self):

        localctx = NeoBasicParser.TypedDecoratedIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_typedDecoratedIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1010
            self.decoratedIdentifier()
            self.state = 1011
            self.type_(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InferredDecoratedIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def decoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DecoratedIdentifierContext,0)


        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_inferredDecoratedIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInferredDecoratedIdentifier" ):
                listener.enterInferredDecoratedIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInferredDecoratedIdentifier" ):
                listener.exitInferredDecoratedIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInferredDecoratedIdentifier" ):
                return visitor.visitInferredDecoratedIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def inferredDecoratedIdentifier(self):

        localctx = NeoBasicParser.InferredDecoratedIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_inferredDecoratedIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1013
            self.decoratedIdentifier()
            self.state = 1015
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.state = 1014
                self.type_(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenericDecoratedIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def decoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DecoratedIdentifierContext,0)


        def genericTypeParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.GenericTypeParametersContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_genericDecoratedIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenericDecoratedIdentifier" ):
                listener.enterGenericDecoratedIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenericDecoratedIdentifier" ):
                listener.exitGenericDecoratedIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenericDecoratedIdentifier" ):
                return visitor.visitGenericDecoratedIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def genericDecoratedIdentifier(self):

        localctx = NeoBasicParser.GenericDecoratedIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_genericDecoratedIdentifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1017
            self.decoratedIdentifier()
            self.state = 1019
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==313:
                self.state = 1018
                self.genericTypeParameters()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def metadataDecorators(self):
            return self.getTypedRuleContext(NeoBasicParser.MetadataDecoratorsContext,0)


        def genericTypeParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.GenericTypeParametersContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_declarationIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclarationIdentifier" ):
                listener.enterDeclarationIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclarationIdentifier" ):
                listener.exitDeclarationIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeclarationIdentifier" ):
                return visitor.visitDeclarationIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def declarationIdentifier(self):

        localctx = NeoBasicParser.DeclarationIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_declarationIdentifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1022
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==382 or _la==383:
                self.state = 1021
                self.metadataDecorators()


            self.state = 1024
            self.qualifiedIdentifier()
            self.state = 1026
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==313:
                self.state = 1025
                self.genericTypeParameters()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifiersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.IDENTIFIER)
            else:
                return self.getToken(NeoBasicParser.IDENTIFIER, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_identifiers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifiers" ):
                listener.enterIdentifiers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifiers" ):
                listener.exitIdentifiers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifiers" ):
                return visitor.visitIdentifiers(self)
            else:
                return visitor.visitChildren(self)




    def identifiers(self):

        localctx = NeoBasicParser.IdentifiersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_identifiers)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1028
            self.match(NeoBasicParser.IDENTIFIER)
            self.state = 1033
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==439:
                self.state = 1029
                self.match(NeoBasicParser.COMMA)
                self.state = 1030
                self.match(NeoBasicParser.IDENTIFIER)
                self.state = 1035
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QualifiedIdentifiersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.QualifiedIdentifierContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_qualifiedIdentifiers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQualifiedIdentifiers" ):
                listener.enterQualifiedIdentifiers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQualifiedIdentifiers" ):
                listener.exitQualifiedIdentifiers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQualifiedIdentifiers" ):
                return visitor.visitQualifiedIdentifiers(self)
            else:
                return visitor.visitChildren(self)




    def qualifiedIdentifiers(self):

        localctx = NeoBasicParser.QualifiedIdentifiersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_qualifiedIdentifiers)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1036
            self.qualifiedIdentifier()
            self.state = 1041
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==439:
                self.state = 1037
                self.match(NeoBasicParser.COMMA)
                self.state = 1038
                self.qualifiedIdentifier()
                self.state = 1043
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecoratedIdentifiersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def decoratedIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.DecoratedIdentifierContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.DecoratedIdentifierContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_decoratedIdentifiers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecoratedIdentifiers" ):
                listener.enterDecoratedIdentifiers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecoratedIdentifiers" ):
                listener.exitDecoratedIdentifiers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDecoratedIdentifiers" ):
                return visitor.visitDecoratedIdentifiers(self)
            else:
                return visitor.visitChildren(self)




    def decoratedIdentifiers(self):

        localctx = NeoBasicParser.DecoratedIdentifiersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_decoratedIdentifiers)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1044
            self.decoratedIdentifier()
            self.state = 1049
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==439:
                self.state = 1045
                self.match(NeoBasicParser.COMMA)
                self.state = 1046
                self.decoratedIdentifier()
                self.state = 1051
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecoratedTypesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def decoratedType(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.DecoratedTypeContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.DecoratedTypeContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_decoratedTypes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecoratedTypes" ):
                listener.enterDecoratedTypes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecoratedTypes" ):
                listener.exitDecoratedTypes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDecoratedTypes" ):
                return visitor.visitDecoratedTypes(self)
            else:
                return visitor.visitChildren(self)




    def decoratedTypes(self):

        localctx = NeoBasicParser.DecoratedTypesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_decoratedTypes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1052
            self.decoratedType()
            self.state = 1057
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==439:
                self.state = 1053
                self.match(NeoBasicParser.COMMA)
                self.state = 1054
                self.decoratedType()
                self.state = 1059
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypedDecoratedIdentifiersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typedDecoratedIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.TypedDecoratedIdentifierContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.TypedDecoratedIdentifierContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_typedDecoratedIdentifiers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypedDecoratedIdentifiers" ):
                listener.enterTypedDecoratedIdentifiers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypedDecoratedIdentifiers" ):
                listener.exitTypedDecoratedIdentifiers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypedDecoratedIdentifiers" ):
                return visitor.visitTypedDecoratedIdentifiers(self)
            else:
                return visitor.visitChildren(self)




    def typedDecoratedIdentifiers(self):

        localctx = NeoBasicParser.TypedDecoratedIdentifiersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_typedDecoratedIdentifiers)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1060
            self.typedDecoratedIdentifier()
            self.state = 1065
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==439:
                self.state = 1061
                self.match(NeoBasicParser.COMMA)
                self.state = 1062
                self.typedDecoratedIdentifier()
                self.state = 1067
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InferredDecoratedIdentifiersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def inferredDecoratedIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.InferredDecoratedIdentifierContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifierContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_inferredDecoratedIdentifiers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInferredDecoratedIdentifiers" ):
                listener.enterInferredDecoratedIdentifiers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInferredDecoratedIdentifiers" ):
                listener.exitInferredDecoratedIdentifiers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInferredDecoratedIdentifiers" ):
                return visitor.visitInferredDecoratedIdentifiers(self)
            else:
                return visitor.visitChildren(self)




    def inferredDecoratedIdentifiers(self):

        localctx = NeoBasicParser.InferredDecoratedIdentifiersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_inferredDecoratedIdentifiers)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1068
            self.inferredDecoratedIdentifier()
            self.state = 1073
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==439:
                self.state = 1069
                self.match(NeoBasicParser.COMMA)
                self.state = 1070
                self.inferredDecoratedIdentifier()
                self.state = 1075
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopLevelSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identificationSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.IdentificationSentenceContext,0)


        def deflagSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.DeflagSentenceContext,0)


        def useSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.UseSentenceContext,0)


        def interfaceSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.InterfaceSentenceContext,0)


        def includeSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.IncludeSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_topLevelSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopLevelSentence" ):
                listener.enterTopLevelSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopLevelSentence" ):
                listener.exitTopLevelSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTopLevelSentence" ):
                return visitor.visitTopLevelSentence(self)
            else:
                return visitor.visitChildren(self)




    def topLevelSentence(self):

        localctx = NeoBasicParser.TopLevelSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_topLevelSentence)
        try:
            self.state = 1081
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1076
                self.identificationSentence()
                pass
            elif token in [7, 8]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1077
                self.deflagSentence()
                pass
            elif token in [9]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1078
                self.useSentence()
                pass
            elif token in [13]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1079
                self.interfaceSentence()
                pass
            elif token in [12]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1080
                self.includeSentence()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentificationSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def appletClause(self):
            return self.getTypedRuleContext(NeoBasicParser.AppletClauseContext,0)


        def moduleClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ModuleClauseContext,0)


        def notabeneClause(self):
            return self.getTypedRuleContext(NeoBasicParser.NotabeneClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_identificationSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentificationSentence" ):
                listener.enterIdentificationSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentificationSentence" ):
                listener.exitIdentificationSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentificationSentence" ):
                return visitor.visitIdentificationSentence(self)
            else:
                return visitor.visitChildren(self)




    def identificationSentence(self):

        localctx = NeoBasicParser.IdentificationSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_identificationSentence)
        try:
            self.state = 1086
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1083
                self.appletClause()
                pass
            elif token in [4]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1084
                self.moduleClause()
                pass
            elif token in [6]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1085
                self.notabeneClause()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AppletClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def APPLET(self):
            return self.getToken(NeoBasicParser.APPLET, 0)

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_appletClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAppletClause" ):
                listener.enterAppletClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAppletClause" ):
                listener.exitAppletClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAppletClause" ):
                return visitor.visitAppletClause(self)
            else:
                return visitor.visitChildren(self)




    def appletClause(self):

        localctx = NeoBasicParser.AppletClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_appletClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1088
            self.match(NeoBasicParser.APPLET)
            self.state = 1090
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==381:
                self.state = 1089
                self.qualifiedIdentifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModuleClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MODULE(self):
            return self.getToken(NeoBasicParser.MODULE, 0)

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_moduleClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModuleClause" ):
                listener.enterModuleClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModuleClause" ):
                listener.exitModuleClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModuleClause" ):
                return visitor.visitModuleClause(self)
            else:
                return visitor.visitChildren(self)




    def moduleClause(self):

        localctx = NeoBasicParser.ModuleClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_moduleClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1092
            self.match(NeoBasicParser.MODULE)
            self.state = 1093
            self.qualifiedIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NotabeneClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOTABENE(self):
            return self.getToken(NeoBasicParser.NOTABENE, 0)

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_notabeneClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNotabeneClause" ):
                listener.enterNotabeneClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNotabeneClause" ):
                listener.exitNotabeneClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNotabeneClause" ):
                return visitor.visitNotabeneClause(self)
            else:
                return visitor.visitChildren(self)




    def notabeneClause(self):

        localctx = NeoBasicParser.NotabeneClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_notabeneClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1095
            self.match(NeoBasicParser.NOTABENE)
            self.state = 1096
            self.qualifiedIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeflagSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defineClause(self):
            return self.getTypedRuleContext(NeoBasicParser.DefineClauseContext,0)


        def undefClause(self):
            return self.getTypedRuleContext(NeoBasicParser.UndefClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_deflagSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeflagSentence" ):
                listener.enterDeflagSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeflagSentence" ):
                listener.exitDeflagSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeflagSentence" ):
                return visitor.visitDeflagSentence(self)
            else:
                return visitor.visitChildren(self)




    def deflagSentence(self):

        localctx = NeoBasicParser.DeflagSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_deflagSentence)
        try:
            self.state = 1100
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1098
                self.defineClause()
                pass
            elif token in [8]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1099
                self.undefClause()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefineClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFINE(self):
            return self.getToken(NeoBasicParser.DEFINE, 0)

        def defineSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.DefineSuiteContext,0)


        def defineDeclare(self):
            return self.getTypedRuleContext(NeoBasicParser.DefineDeclareContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_defineClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefineClause" ):
                listener.enterDefineClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefineClause" ):
                listener.exitDefineClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefineClause" ):
                return visitor.visitDefineClause(self)
            else:
                return visitor.visitChildren(self)




    def defineClause(self):

        localctx = NeoBasicParser.DefineClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_defineClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1102
            self.match(NeoBasicParser.DEFINE)
            self.state = 1105
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [423]:
                self.state = 1103
                self.defineSuite()
                pass
            elif token in [381, 382]:
                self.state = 1104
                self.defineDeclare()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefineSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def defineDeclareBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.DefineDeclareBlockContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_defineSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefineSuite" ):
                listener.enterDefineSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefineSuite" ):
                listener.exitDefineSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefineSuite" ):
                return visitor.visitDefineSuite(self)
            else:
                return visitor.visitChildren(self)




    def defineSuite(self):

        localctx = NeoBasicParser.DefineSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_defineSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1107
            self.match(NeoBasicParser.EOS)
            self.state = 1108
            self.match(NeoBasicParser.INDENT)
            self.state = 1109
            self.defineDeclareBlock()
            self.state = 1110
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefineDeclareBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defineDeclare(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.DefineDeclareContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.DefineDeclareContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_defineDeclareBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefineDeclareBlock" ):
                listener.enterDefineDeclareBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefineDeclareBlock" ):
                listener.exitDefineDeclareBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefineDeclareBlock" ):
                return visitor.visitDefineDeclareBlock(self)
            else:
                return visitor.visitChildren(self)




    def defineDeclareBlock(self):

        localctx = NeoBasicParser.DefineDeclareBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_defineDeclareBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1112
            self.defineDeclare()
            self.state = 1117
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==423:
                self.state = 1113
                self.match(NeoBasicParser.EOS)
                self.state = 1114
                self.defineDeclare()
                self.state = 1119
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefineDeclareContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defineDeclareSingle(self):
            return self.getTypedRuleContext(NeoBasicParser.DefineDeclareSingleContext,0)


        def defineDeclareMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.DefineDeclareMultipleContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_defineDeclare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefineDeclare" ):
                listener.enterDefineDeclare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefineDeclare" ):
                listener.exitDefineDeclare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefineDeclare" ):
                return visitor.visitDefineDeclare(self)
            else:
                return visitor.visitChildren(self)




    def defineDeclare(self):

        localctx = NeoBasicParser.DefineDeclareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_defineDeclare)
        try:
            self.state = 1122
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1120
                self.defineDeclareSingle()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1121
                self.defineDeclareMultiple()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefineDeclareSingleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defAtom(self):
            return self.getTypedRuleContext(NeoBasicParser.DefAtomContext,0)


        def literal(self):
            return self.getTypedRuleContext(NeoBasicParser.LiteralContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_defineDeclareSingle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefineDeclareSingle" ):
                listener.enterDefineDeclareSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefineDeclareSingle" ):
                listener.exitDefineDeclareSingle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefineDeclareSingle" ):
                return visitor.visitDefineDeclareSingle(self)
            else:
                return visitor.visitChildren(self)




    def defineDeclareSingle(self):

        localctx = NeoBasicParser.DefineDeclareSingleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_defineDeclareSingle)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1124
            self.defAtom()
            self.state = 1126
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 247385886433392) != 0) or ((((_la - 106)) & ~0x3f) == 0 and ((1 << (_la - 106)) & -3932671) != 0) or ((((_la - 170)) & ~0x3f) == 0 and ((1 << (_la - 170)) & -1) != 0) or ((((_la - 234)) & ~0x3f) == 0 and ((1 << (_la - 234)) & -1097189321779183633) != 0) or ((((_la - 298)) & ~0x3f) == 0 and ((1 << (_la - 298)) & 343597416959) != 0) or ((((_la - 381)) & ~0x3f) == 0 and ((1 << (_la - 381)) & 47287821890748409) != 0) or ((((_la - 453)) & ~0x3f) == 0 and ((1 << (_la - 453)) & 3073) != 0):
                self.state = 1125
                self.literal()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefineDeclareMultipleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defineDeclareSingle(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.DefineDeclareSingleContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.DefineDeclareSingleContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_defineDeclareMultiple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefineDeclareMultiple" ):
                listener.enterDefineDeclareMultiple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefineDeclareMultiple" ):
                listener.exitDefineDeclareMultiple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefineDeclareMultiple" ):
                return visitor.visitDefineDeclareMultiple(self)
            else:
                return visitor.visitChildren(self)




    def defineDeclareMultiple(self):

        localctx = NeoBasicParser.DefineDeclareMultipleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_defineDeclareMultiple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1128
            self.defineDeclareSingle()
            self.state = 1131 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1129
                self.match(NeoBasicParser.COMMA)
                self.state = 1130
                self.defineDeclareSingle()
                self.state = 1133 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==439):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UndefClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNDEF(self):
            return self.getToken(NeoBasicParser.UNDEF, 0)

        def undefSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.UndefSuiteContext,0)


        def undefDeclare(self):
            return self.getTypedRuleContext(NeoBasicParser.UndefDeclareContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_undefClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUndefClause" ):
                listener.enterUndefClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUndefClause" ):
                listener.exitUndefClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUndefClause" ):
                return visitor.visitUndefClause(self)
            else:
                return visitor.visitChildren(self)




    def undefClause(self):

        localctx = NeoBasicParser.UndefClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_undefClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1135
            self.match(NeoBasicParser.UNDEF)
            self.state = 1138
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [423]:
                self.state = 1136
                self.undefSuite()
                pass
            elif token in [381, 382]:
                self.state = 1137
                self.undefDeclare()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UndefSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def undefDeclareBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.UndefDeclareBlockContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_undefSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUndefSuite" ):
                listener.enterUndefSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUndefSuite" ):
                listener.exitUndefSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUndefSuite" ):
                return visitor.visitUndefSuite(self)
            else:
                return visitor.visitChildren(self)




    def undefSuite(self):

        localctx = NeoBasicParser.UndefSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_undefSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1140
            self.match(NeoBasicParser.EOS)
            self.state = 1141
            self.match(NeoBasicParser.INDENT)
            self.state = 1142
            self.undefDeclareBlock()
            self.state = 1143
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UndefDeclareBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def undefDeclare(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.UndefDeclareContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.UndefDeclareContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_undefDeclareBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUndefDeclareBlock" ):
                listener.enterUndefDeclareBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUndefDeclareBlock" ):
                listener.exitUndefDeclareBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUndefDeclareBlock" ):
                return visitor.visitUndefDeclareBlock(self)
            else:
                return visitor.visitChildren(self)




    def undefDeclareBlock(self):

        localctx = NeoBasicParser.UndefDeclareBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_undefDeclareBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1145
            self.undefDeclare()
            self.state = 1150
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==423:
                self.state = 1146
                self.match(NeoBasicParser.EOS)
                self.state = 1147
                self.undefDeclare()
                self.state = 1152
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UndefDeclareContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defAtoms(self):
            return self.getTypedRuleContext(NeoBasicParser.DefAtomsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_undefDeclare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUndefDeclare" ):
                listener.enterUndefDeclare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUndefDeclare" ):
                listener.exitUndefDeclare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUndefDeclare" ):
                return visitor.visitUndefDeclare(self)
            else:
                return visitor.visitChildren(self)




    def undefDeclare(self):

        localctx = NeoBasicParser.UndefDeclareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_undefDeclare)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1153
            self.defAtoms()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefAtomContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(NeoBasicParser.IDENTIFIER, 0)

        def ATOM_IDENTIFIER(self):
            return self.getToken(NeoBasicParser.ATOM_IDENTIFIER, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_defAtom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefAtom" ):
                listener.enterDefAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefAtom" ):
                listener.exitDefAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefAtom" ):
                return visitor.visitDefAtom(self)
            else:
                return visitor.visitChildren(self)




    def defAtom(self):

        localctx = NeoBasicParser.DefAtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_defAtom)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1155
            _la = self._input.LA(1)
            if not(_la==381 or _la==382):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefAtomsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defAtom(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.DefAtomContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.DefAtomContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_defAtoms

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefAtoms" ):
                listener.enterDefAtoms(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefAtoms" ):
                listener.exitDefAtoms(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefAtoms" ):
                return visitor.visitDefAtoms(self)
            else:
                return visitor.visitChildren(self)




    def defAtoms(self):

        localctx = NeoBasicParser.DefAtomsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_defAtoms)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1157
            self.defAtom()
            self.state = 1162
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==439:
                self.state = 1158
                self.match(NeoBasicParser.COMMA)
                self.state = 1159
                self.defAtom()
                self.state = 1164
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UseSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def useClause(self):
            return self.getTypedRuleContext(NeoBasicParser.UseClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_useSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseSentence" ):
                listener.enterUseSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseSentence" ):
                listener.exitUseSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUseSentence" ):
                return visitor.visitUseSentence(self)
            else:
                return visitor.visitChildren(self)




    def useSentence(self):

        localctx = NeoBasicParser.UseSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_useSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1165
            self.useClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UseClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USE(self):
            return self.getToken(NeoBasicParser.USE, 0)

        def useSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.UseSuiteContext,0)


        def useDeclare(self):
            return self.getTypedRuleContext(NeoBasicParser.UseDeclareContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_useClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseClause" ):
                listener.enterUseClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseClause" ):
                listener.exitUseClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUseClause" ):
                return visitor.visitUseClause(self)
            else:
                return visitor.visitChildren(self)




    def useClause(self):

        localctx = NeoBasicParser.UseClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_useClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1167
            self.match(NeoBasicParser.USE)
            self.state = 1170
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [423]:
                self.state = 1168
                self.useSuite()
                pass
            elif token in [381]:
                self.state = 1169
                self.useDeclare()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UseSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def useDeclareBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.UseDeclareBlockContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_useSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseSuite" ):
                listener.enterUseSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseSuite" ):
                listener.exitUseSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUseSuite" ):
                return visitor.visitUseSuite(self)
            else:
                return visitor.visitChildren(self)




    def useSuite(self):

        localctx = NeoBasicParser.UseSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_useSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1172
            self.match(NeoBasicParser.EOS)
            self.state = 1173
            self.match(NeoBasicParser.INDENT)
            self.state = 1174
            self.useDeclareBlock()
            self.state = 1175
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UseDeclareBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def useDeclare(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.UseDeclareContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.UseDeclareContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_useDeclareBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseDeclareBlock" ):
                listener.enterUseDeclareBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseDeclareBlock" ):
                listener.exitUseDeclareBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUseDeclareBlock" ):
                return visitor.visitUseDeclareBlock(self)
            else:
                return visitor.visitChildren(self)




    def useDeclareBlock(self):

        localctx = NeoBasicParser.UseDeclareBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_useDeclareBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1177
            self.useDeclare()
            self.state = 1182
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==423:
                self.state = 1178
                self.match(NeoBasicParser.EOS)
                self.state = 1179
                self.useDeclare()
                self.state = 1184
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UseDeclareContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def useDeclareSingle(self):
            return self.getTypedRuleContext(NeoBasicParser.UseDeclareSingleContext,0)


        def useDeclareMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.UseDeclareMultipleContext,0)


        def useDeclareAs(self):
            return self.getTypedRuleContext(NeoBasicParser.UseDeclareAsContext,0)


        def useDeclareOf(self):
            return self.getTypedRuleContext(NeoBasicParser.UseDeclareOfContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_useDeclare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseDeclare" ):
                listener.enterUseDeclare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseDeclare" ):
                listener.exitUseDeclare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUseDeclare" ):
                return visitor.visitUseDeclare(self)
            else:
                return visitor.visitChildren(self)




    def useDeclare(self):

        localctx = NeoBasicParser.UseDeclareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_useDeclare)
        try:
            self.state = 1189
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1185
                self.useDeclareSingle()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1186
                self.useDeclareMultiple()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1187
                self.useDeclareAs()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1188
                self.useDeclareOf()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UseDeclareSingleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_useDeclareSingle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseDeclareSingle" ):
                listener.enterUseDeclareSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseDeclareSingle" ):
                listener.exitUseDeclareSingle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUseDeclareSingle" ):
                return visitor.visitUseDeclareSingle(self)
            else:
                return visitor.visitChildren(self)




    def useDeclareSingle(self):

        localctx = NeoBasicParser.UseDeclareSingleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_useDeclareSingle)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1191
            self.qualifiedIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UseDeclareMultipleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def useDeclareSingle(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.UseDeclareSingleContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.UseDeclareSingleContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_useDeclareMultiple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseDeclareMultiple" ):
                listener.enterUseDeclareMultiple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseDeclareMultiple" ):
                listener.exitUseDeclareMultiple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUseDeclareMultiple" ):
                return visitor.visitUseDeclareMultiple(self)
            else:
                return visitor.visitChildren(self)




    def useDeclareMultiple(self):

        localctx = NeoBasicParser.UseDeclareMultipleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_useDeclareMultiple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1193
            self.useDeclareSingle()
            self.state = 1196 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1194
                self.match(NeoBasicParser.COMMA)
                self.state = 1195
                self.useDeclareSingle()
                self.state = 1198 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==439):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UseDeclareAsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def AS(self):
            return self.getToken(NeoBasicParser.AS, 0)

        def IDENTIFIER(self):
            return self.getToken(NeoBasicParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_useDeclareAs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseDeclareAs" ):
                listener.enterUseDeclareAs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseDeclareAs" ):
                listener.exitUseDeclareAs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUseDeclareAs" ):
                return visitor.visitUseDeclareAs(self)
            else:
                return visitor.visitChildren(self)




    def useDeclareAs(self):

        localctx = NeoBasicParser.UseDeclareAsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_useDeclareAs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1200
            self.qualifiedIdentifier()
            self.state = 1201
            self.match(NeoBasicParser.AS)
            self.state = 1202
            self.match(NeoBasicParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UseDeclareOfContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedIdentifiers(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifiersContext,0)


        def OF(self):
            return self.getToken(NeoBasicParser.OF, 0)

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_useDeclareOf

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseDeclareOf" ):
                listener.enterUseDeclareOf(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseDeclareOf" ):
                listener.exitUseDeclareOf(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUseDeclareOf" ):
                return visitor.visitUseDeclareOf(self)
            else:
                return visitor.visitChildren(self)




    def useDeclareOf(self):

        localctx = NeoBasicParser.UseDeclareOfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_useDeclareOf)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1204
            self.qualifiedIdentifiers()
            self.state = 1205
            self.match(NeoBasicParser.OF)
            self.state = 1206
            self.qualifiedIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InterfaceSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def interfaceClause(self):
            return self.getTypedRuleContext(NeoBasicParser.InterfaceClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_interfaceSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterfaceSentence" ):
                listener.enterInterfaceSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterfaceSentence" ):
                listener.exitInterfaceSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterfaceSentence" ):
                return visitor.visitInterfaceSentence(self)
            else:
                return visitor.visitChildren(self)




    def interfaceSentence(self):

        localctx = NeoBasicParser.InterfaceSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_interfaceSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1208
            self.interfaceClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InterfaceClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTERFACE(self):
            return self.getToken(NeoBasicParser.INTERFACE, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def interfaceBody(self):
            return self.getTypedRuleContext(NeoBasicParser.InterfaceBodyContext,0)


        def mixesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.MixesClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_interfaceClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterfaceClause" ):
                listener.enterInterfaceClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterfaceClause" ):
                listener.exitInterfaceClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterfaceClause" ):
                return visitor.visitInterfaceClause(self)
            else:
                return visitor.visitChildren(self)




    def interfaceClause(self):

        localctx = NeoBasicParser.InterfaceClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_interfaceClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1210
            self.match(NeoBasicParser.INTERFACE)
            self.state = 1211
            self.declarationIdentifier()
            self.state = 1213
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==42:
                self.state = 1212
                self.mixesClause()


            self.state = 1215
            self.interfaceBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InterfaceBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_interfaceBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterfaceBody" ):
                listener.enterInterfaceBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterfaceBody" ):
                listener.exitInterfaceBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterfaceBody" ):
                return visitor.visitInterfaceBody(self)
            else:
                return visitor.visitChildren(self)




    def interfaceBody(self):

        localctx = NeoBasicParser.InterfaceBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_interfaceBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1217
            self.logicalInstructionSuite()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def includeClause(self):
            return self.getTypedRuleContext(NeoBasicParser.IncludeClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_includeSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncludeSentence" ):
                listener.enterIncludeSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncludeSentence" ):
                listener.exitIncludeSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncludeSentence" ):
                return visitor.visitIncludeSentence(self)
            else:
                return visitor.visitChildren(self)




    def includeSentence(self):

        localctx = NeoBasicParser.IncludeSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_includeSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1219
            self.includeClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INCLUDE(self):
            return self.getToken(NeoBasicParser.INCLUDE, 0)

        def includeSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.IncludeSuiteContext,0)


        def includeDeclare(self):
            return self.getTypedRuleContext(NeoBasicParser.IncludeDeclareContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_includeClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncludeClause" ):
                listener.enterIncludeClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncludeClause" ):
                listener.exitIncludeClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncludeClause" ):
                return visitor.visitIncludeClause(self)
            else:
                return visitor.visitChildren(self)




    def includeClause(self):

        localctx = NeoBasicParser.IncludeClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_includeClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1221
            self.match(NeoBasicParser.INCLUDE)
            self.state = 1224
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [423]:
                self.state = 1222
                self.includeSuite()
                pass
            elif token in [247, 248, 249, 250, 251, 252, 253, 254, 414, 415]:
                self.state = 1223
                self.includeDeclare()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def includeDeclareBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.IncludeDeclareBlockContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_includeSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncludeSuite" ):
                listener.enterIncludeSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncludeSuite" ):
                listener.exitIncludeSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncludeSuite" ):
                return visitor.visitIncludeSuite(self)
            else:
                return visitor.visitChildren(self)




    def includeSuite(self):

        localctx = NeoBasicParser.IncludeSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_includeSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1226
            self.match(NeoBasicParser.EOS)
            self.state = 1227
            self.match(NeoBasicParser.INDENT)
            self.state = 1228
            self.includeDeclareBlock()
            self.state = 1229
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeDeclareBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def includeDeclare(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.IncludeDeclareContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.IncludeDeclareContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_includeDeclareBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncludeDeclareBlock" ):
                listener.enterIncludeDeclareBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncludeDeclareBlock" ):
                listener.exitIncludeDeclareBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncludeDeclareBlock" ):
                return visitor.visitIncludeDeclareBlock(self)
            else:
                return visitor.visitChildren(self)




    def includeDeclareBlock(self):

        localctx = NeoBasicParser.IncludeDeclareBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_includeDeclareBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1231
            self.includeDeclare()
            self.state = 1236
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==423:
                self.state = 1232
                self.match(NeoBasicParser.EOS)
                self.state = 1233
                self.includeDeclare()
                self.state = 1238
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeDeclareContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def includeDeclareSingle(self):
            return self.getTypedRuleContext(NeoBasicParser.IncludeDeclareSingleContext,0)


        def includeDeclareMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.IncludeDeclareMultipleContext,0)


        def includeDeclareAs(self):
            return self.getTypedRuleContext(NeoBasicParser.IncludeDeclareAsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_includeDeclare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncludeDeclare" ):
                listener.enterIncludeDeclare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncludeDeclare" ):
                listener.exitIncludeDeclare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncludeDeclare" ):
                return visitor.visitIncludeDeclare(self)
            else:
                return visitor.visitChildren(self)




    def includeDeclare(self):

        localctx = NeoBasicParser.IncludeDeclareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_includeDeclare)
        try:
            self.state = 1242
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1239
                self.includeDeclareSingle()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1240
                self.includeDeclareMultiple()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1241
                self.includeDeclareAs()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeDeclareSingleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shellPathLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.ShellPathLiteralContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_includeDeclareSingle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncludeDeclareSingle" ):
                listener.enterIncludeDeclareSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncludeDeclareSingle" ):
                listener.exitIncludeDeclareSingle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncludeDeclareSingle" ):
                return visitor.visitIncludeDeclareSingle(self)
            else:
                return visitor.visitChildren(self)




    def includeDeclareSingle(self):

        localctx = NeoBasicParser.IncludeDeclareSingleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_includeDeclareSingle)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1244
            self.shellPathLiteral()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeDeclareMultipleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def includeDeclareSingle(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.IncludeDeclareSingleContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.IncludeDeclareSingleContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_includeDeclareMultiple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncludeDeclareMultiple" ):
                listener.enterIncludeDeclareMultiple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncludeDeclareMultiple" ):
                listener.exitIncludeDeclareMultiple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncludeDeclareMultiple" ):
                return visitor.visitIncludeDeclareMultiple(self)
            else:
                return visitor.visitChildren(self)




    def includeDeclareMultiple(self):

        localctx = NeoBasicParser.IncludeDeclareMultipleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_includeDeclareMultiple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1246
            self.includeDeclareSingle()
            self.state = 1249 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1247
                self.match(NeoBasicParser.COMMA)
                self.state = 1248
                self.includeDeclareSingle()
                self.state = 1251 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==439):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeDeclareAsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shellPathLiterals(self):
            return self.getTypedRuleContext(NeoBasicParser.ShellPathLiteralsContext,0)


        def AS(self):
            return self.getToken(NeoBasicParser.AS, 0)

        def inferredDecoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_includeDeclareAs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncludeDeclareAs" ):
                listener.enterIncludeDeclareAs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncludeDeclareAs" ):
                listener.exitIncludeDeclareAs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncludeDeclareAs" ):
                return visitor.visitIncludeDeclareAs(self)
            else:
                return visitor.visitChildren(self)




    def includeDeclareAs(self):

        localctx = NeoBasicParser.IncludeDeclareAsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_includeDeclareAs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1253
            self.shellPathLiterals()
            self.state = 1254
            self.match(NeoBasicParser.AS)
            self.state = 1255
            self.inferredDecoratedIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declarationSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationSentenceContext,0)


        def adhocMetadata(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.AdhocMetadataContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.AdhocMetadataContext,i)


        def visibilityLabelSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.VisibilityLabelSuiteContext,0)


        def outerDeclareSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.OuterDeclareSentenceContext,0)


        def innerDeclareSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.InnerDeclareSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_declarationSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclarationSentence" ):
                listener.enterDeclarationSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclarationSentence" ):
                listener.exitDeclarationSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeclarationSentence" ):
                return visitor.visitDeclarationSentence(self)
            else:
                return visitor.visitChildren(self)




    def declarationSentence(self):

        localctx = NeoBasicParser.DeclarationSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_declarationSentence)
        try:
            self.state = 1267
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1258 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 1257
                        self.adhocMetadata()

                    else:
                        raise NoViableAltException(self)
                    self.state = 1260 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,43,self._ctx)

                self.state = 1262
                self.declarationSentence()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1264
                self.visibilityLabelSuite()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1265
                self.outerDeclareSentence()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1266
                self.innerDeclareSentence()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AdhocMetadataContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def metadataDecorators(self):
            return self.getTypedRuleContext(NeoBasicParser.MetadataDecoratorsContext,0)


        def metadataGenerics(self):
            return self.getTypedRuleContext(NeoBasicParser.MetadataGenericsContext,0)


        def visibilityModifier(self):
            return self.getTypedRuleContext(NeoBasicParser.VisibilityModifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_adhocMetadata

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdhocMetadata" ):
                listener.enterAdhocMetadata(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdhocMetadata" ):
                listener.exitAdhocMetadata(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdhocMetadata" ):
                return visitor.visitAdhocMetadata(self)
            else:
                return visitor.visitChildren(self)




    def adhocMetadata(self):

        localctx = NeoBasicParser.AdhocMetadataContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_adhocMetadata)
        try:
            self.state = 1272
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [382, 383]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1269
                self.metadataDecorators()
                pass
            elif token in [304]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1270
                self.metadataGenerics()
                pass
            elif token in [14, 15, 16]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1271
                self.visibilityModifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MetadataDecoratorsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbolDecorators(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.SymbolDecoratorsContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.SymbolDecoratorsContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_metadataDecorators

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetadataDecorators" ):
                listener.enterMetadataDecorators(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetadataDecorators" ):
                listener.exitMetadataDecorators(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetadataDecorators" ):
                return visitor.visitMetadataDecorators(self)
            else:
                return visitor.visitChildren(self)




    def metadataDecorators(self):

        localctx = NeoBasicParser.MetadataDecoratorsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_metadataDecorators)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1274
            self.symbolDecorators()
            self.state = 1281
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,47,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1276
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==423:
                        self.state = 1275
                        self.match(NeoBasicParser.EOS)


                    self.state = 1278
                    self.symbolDecorators() 
                self.state = 1283
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,47,self._ctx)

            self.state = 1285
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==423:
                self.state = 1284
                self.match(NeoBasicParser.EOS)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MetadataGenericsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOUBLE_LEFT_ANGLE(self):
            return self.getToken(NeoBasicParser.DOUBLE_LEFT_ANGLE, 0)

        def typeParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeParametersContext,0)


        def DOUBLE_RIGHT_ANGLE(self):
            return self.getToken(NeoBasicParser.DOUBLE_RIGHT_ANGLE, 0)

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_metadataGenerics

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetadataGenerics" ):
                listener.enterMetadataGenerics(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetadataGenerics" ):
                listener.exitMetadataGenerics(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetadataGenerics" ):
                return visitor.visitMetadataGenerics(self)
            else:
                return visitor.visitChildren(self)




    def metadataGenerics(self):

        localctx = NeoBasicParser.MetadataGenericsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_metadataGenerics)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1287
            self.match(NeoBasicParser.DOUBLE_LEFT_ANGLE)
            self.state = 1288
            self.typeParameters()
            self.state = 1289
            self.match(NeoBasicParser.DOUBLE_RIGHT_ANGLE)
            self.state = 1291
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==423:
                self.state = 1290
                self.match(NeoBasicParser.EOS)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VisibilityModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PUBLIC(self):
            return self.getToken(NeoBasicParser.PUBLIC, 0)

        def PROTECTED(self):
            return self.getToken(NeoBasicParser.PROTECTED, 0)

        def PRIVATE(self):
            return self.getToken(NeoBasicParser.PRIVATE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_visibilityModifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVisibilityModifier" ):
                listener.enterVisibilityModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVisibilityModifier" ):
                listener.exitVisibilityModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVisibilityModifier" ):
                return visitor.visitVisibilityModifier(self)
            else:
                return visitor.visitChildren(self)




    def visibilityModifier(self):

        localctx = NeoBasicParser.VisibilityModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_visibilityModifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1293
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 114688) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VisibilityLabelSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def visibilityModifier(self):
            return self.getTypedRuleContext(NeoBasicParser.VisibilityModifierContext,0)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def declarationSentence(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.DeclarationSentenceContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.DeclarationSentenceContext,i)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_visibilityLabelSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVisibilityLabelSuite" ):
                listener.enterVisibilityLabelSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVisibilityLabelSuite" ):
                listener.exitVisibilityLabelSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVisibilityLabelSuite" ):
                return visitor.visitVisibilityLabelSuite(self)
            else:
                return visitor.visitChildren(self)




    def visibilityLabelSuite(self):

        localctx = NeoBasicParser.VisibilityLabelSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_visibilityLabelSuite)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1295
            self.visibilityModifier()
            self.state = 1296
            self.match(NeoBasicParser.EOS)
            self.state = 1297
            self.match(NeoBasicParser.INDENT)
            self.state = 1298
            self.declarationSentence()
            self.state = 1303
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==423:
                self.state = 1299
                self.match(NeoBasicParser.EOS)
                self.state = 1300
                self.declarationSentence()
                self.state = 1305
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1306
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtendsClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXTENDS(self):
            return self.getToken(NeoBasicParser.EXTENDS, 0)

        def type_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.TypeContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.TypeContext,i)


        def visibilityModifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.VisibilityModifierContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.VisibilityModifierContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_extendsClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtendsClause" ):
                listener.enterExtendsClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtendsClause" ):
                listener.exitExtendsClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExtendsClause" ):
                return visitor.visitExtendsClause(self)
            else:
                return visitor.visitChildren(self)




    def extendsClause(self):

        localctx = NeoBasicParser.ExtendsClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_extendsClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1308
            self.match(NeoBasicParser.EXTENDS)
            self.state = 1310
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 114688) != 0):
                self.state = 1309
                self.visibilityModifier()


            self.state = 1312
            self.type_(0)
            self.state = 1320
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==439:
                self.state = 1313
                self.match(NeoBasicParser.COMMA)
                self.state = 1315
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 114688) != 0):
                    self.state = 1314
                    self.visibilityModifier()


                self.state = 1317
                self.type_(0)
                self.state = 1322
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImplementsClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IMPLEMENTS(self):
            return self.getToken(NeoBasicParser.IMPLEMENTS, 0)

        def types(self):
            return self.getTypedRuleContext(NeoBasicParser.TypesContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_implementsClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImplementsClause" ):
                listener.enterImplementsClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImplementsClause" ):
                listener.exitImplementsClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImplementsClause" ):
                return visitor.visitImplementsClause(self)
            else:
                return visitor.visitChildren(self)




    def implementsClause(self):

        localctx = NeoBasicParser.ImplementsClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_implementsClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1323
            self.match(NeoBasicParser.IMPLEMENTS)
            self.state = 1324
            self.types()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MixesClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MIXES(self):
            return self.getToken(NeoBasicParser.MIXES, 0)

        def types(self):
            return self.getTypedRuleContext(NeoBasicParser.TypesContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_mixesClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMixesClause" ):
                listener.enterMixesClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMixesClause" ):
                listener.exitMixesClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMixesClause" ):
                return visitor.visitMixesClause(self)
            else:
                return visitor.visitChildren(self)




    def mixesClause(self):

        localctx = NeoBasicParser.MixesClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_mixesClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1326
            self.match(NeoBasicParser.MIXES)
            self.state = 1327
            self.types()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RaisesClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOPANIC(self):
            return self.getToken(NeoBasicParser.NOPANIC, 0)

        def RAISES(self):
            return self.getToken(NeoBasicParser.RAISES, 0)

        def types(self):
            return self.getTypedRuleContext(NeoBasicParser.TypesContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_raisesClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRaisesClause" ):
                listener.enterRaisesClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRaisesClause" ):
                listener.exitRaisesClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRaisesClause" ):
                return visitor.visitRaisesClause(self)
            else:
                return visitor.visitChildren(self)




    def raisesClause(self):

        localctx = NeoBasicParser.RaisesClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_raisesClause)
        try:
            self.state = 1332
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [28]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1329
                self.match(NeoBasicParser.NOPANIC)
                pass
            elif token in [27]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1330
                self.match(NeoBasicParser.RAISES)
                self.state = 1331
                self.types()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParenthesizedArgumentsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LEFT_PARENTHESIS, 0)

        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def namedArguments(self):
            return self.getTypedRuleContext(NeoBasicParser.NamedArgumentsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_parenthesizedArguments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenthesizedArguments" ):
                listener.enterParenthesizedArguments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenthesizedArguments" ):
                listener.exitParenthesizedArguments(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenthesizedArguments" ):
                return visitor.visitParenthesizedArguments(self)
            else:
                return visitor.visitChildren(self)




    def parenthesizedArguments(self):

        localctx = NeoBasicParser.ParenthesizedArgumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_parenthesizedArguments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1334
            self.match(NeoBasicParser.LEFT_PARENTHESIS)
            self.state = 1336
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 247385886433392) != 0) or ((((_la - 93)) & ~0x3f) == 0 and ((1 << (_la - 93)) & -4128769) != 0) or ((((_la - 157)) & ~0x3f) == 0 and ((1 << (_la - 157)) & -1) != 0) or ((((_la - 221)) & ~0x3f) == 0 and ((1 << (_la - 221)) & -4610560118520676353) != 0) or ((((_la - 285)) & ~0x3f) == 0 and ((1 << (_la - 285)) & 2814750039735871) != 0) or ((((_la - 381)) & ~0x3f) == 0 and ((1 << (_la - 381)) & 47287830447128569) != 0) or ((((_la - 451)) & ~0x3f) == 0 and ((1 << (_la - 451)) & 12295) != 0):
                self.state = 1335
                self.namedArguments()


            self.state = 1338
            self.match(NeoBasicParser.RIGHT_PARENTHESIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamedArgumentsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def namedArgument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.NamedArgumentContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.NamedArgumentContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_namedArguments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNamedArguments" ):
                listener.enterNamedArguments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNamedArguments" ):
                listener.exitNamedArguments(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNamedArguments" ):
                return visitor.visitNamedArguments(self)
            else:
                return visitor.visitChildren(self)




    def namedArguments(self):

        localctx = NeoBasicParser.NamedArgumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_namedArguments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1340
            self.namedArgument()
            self.state = 1345
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==439:
                self.state = 1341
                self.match(NeoBasicParser.COMMA)
                self.state = 1342
                self.namedArgument()
                self.state = 1347
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamedArgumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def IDENTIFIER(self):
            return self.getToken(NeoBasicParser.IDENTIFIER, 0)

        def EQUAL(self):
            return self.getToken(NeoBasicParser.EQUAL, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_namedArgument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNamedArgument" ):
                listener.enterNamedArgument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNamedArgument" ):
                listener.exitNamedArgument(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNamedArgument" ):
                return visitor.visitNamedArgument(self)
            else:
                return visitor.visitChildren(self)




    def namedArgument(self):

        localctx = NeoBasicParser.NamedArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_namedArgument)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1350
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,57,self._ctx)
            if la_ == 1:
                self.state = 1348
                self.match(NeoBasicParser.IDENTIFIER)
                self.state = 1349
                self.match(NeoBasicParser.EQUAL)


            self.state = 1352
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParenthesizedParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LEFT_PARENTHESIS, 0)

        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def procParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcParametersContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_parenthesizedParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenthesizedParameters" ):
                listener.enterParenthesizedParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenthesizedParameters" ):
                listener.exitParenthesizedParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenthesizedParameters" ):
                return visitor.visitParenthesizedParameters(self)
            else:
                return visitor.visitChildren(self)




    def parenthesizedParameters(self):

        localctx = NeoBasicParser.ParenthesizedParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_parenthesizedParameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1354
            self.match(NeoBasicParser.LEFT_PARENTHESIS)
            self.state = 1356
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 2215641088) != 0) or _la==112 or _la==292 or _la==293 or ((((_la - 381)) & ~0x3f) == 0 and ((1 << (_la - 381)) & 7) != 0) or _la==450:
                self.state = 1355
                self.procParameters()


            self.state = 1358
            self.match(NeoBasicParser.RIGHT_PARENTHESIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def procParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ProcParameterContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ProcParameterContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_procParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcParameters" ):
                listener.enterProcParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcParameters" ):
                listener.exitProcParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcParameters" ):
                return visitor.visitProcParameters(self)
            else:
                return visitor.visitChildren(self)




    def procParameters(self):

        localctx = NeoBasicParser.ProcParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_procParameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1360
            self.procParameter()
            self.state = 1365
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==439:
                self.state = 1361
                self.match(NeoBasicParser.COMMA)
                self.state = 1362
                self.procParameter()
                self.state = 1367
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(NeoBasicParser.IDENTIFIER, 0)

        def modeParameterSpecifier(self):
            return self.getTypedRuleContext(NeoBasicParser.ModeParameterSpecifierContext,0)


        def metadataDecorators(self):
            return self.getTypedRuleContext(NeoBasicParser.MetadataDecoratorsContext,0)


        def prefixParameterName(self):
            return self.getTypedRuleContext(NeoBasicParser.PrefixParameterNameContext,0)


        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def EQUAL(self):
            return self.getToken(NeoBasicParser.EQUAL, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def prefixParameterType(self):
            return self.getTypedRuleContext(NeoBasicParser.PrefixParameterTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_procParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcParameter" ):
                listener.enterProcParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcParameter" ):
                listener.exitProcParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcParameter" ):
                return visitor.visitProcParameter(self)
            else:
                return visitor.visitChildren(self)




    def procParameter(self):

        localctx = NeoBasicParser.ProcParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_procParameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1369
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 2215641088) != 0) or _la==112:
                self.state = 1368
                self.modeParameterSpecifier()


            self.state = 1372
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==382 or _la==383:
                self.state = 1371
                self.metadataDecorators()


            self.state = 1375
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==292 or _la==293 or _la==450:
                self.state = 1374
                self.prefixParameterName()


            self.state = 1377
            self.match(NeoBasicParser.IDENTIFIER)
            self.state = 1382
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 247385886433392) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & -1) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & 16777215) != 0) or ((((_la - 259)) & ~0x3f) == 0 and ((1 << (_la - 259)) & 2147484233) != 0) or _la==334 or _la==381 or _la==434 or _la==441:
                self.state = 1379
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==290 or _la==334 or _la==441:
                    self.state = 1378
                    self.prefixParameterType()


                self.state = 1381
                self.type_(0)


            self.state = 1386
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==353:
                self.state = 1384
                self.match(NeoBasicParser.EQUAL)
                self.state = 1385
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModeParameterSpecifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAR(self):
            return self.getToken(NeoBasicParser.VAR, 0)

        def VAL(self):
            return self.getToken(NeoBasicParser.VAL, 0)

        def IN(self):
            return self.getToken(NeoBasicParser.IN, 0)

        def OUT(self):
            return self.getToken(NeoBasicParser.OUT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_modeParameterSpecifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModeParameterSpecifier" ):
                listener.enterModeParameterSpecifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModeParameterSpecifier" ):
                listener.exitModeParameterSpecifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModeParameterSpecifier" ):
                return visitor.visitModeParameterSpecifier(self)
            else:
                return visitor.visitChildren(self)




    def modeParameterSpecifier(self):

        localctx = NeoBasicParser.ModeParameterSpecifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_modeParameterSpecifier)
        try:
            self.state = 1394
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,66,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1388
                self.match(NeoBasicParser.VAR)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1389
                self.match(NeoBasicParser.VAL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1390
                self.match(NeoBasicParser.IN)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1391
                self.match(NeoBasicParser.IN)
                self.state = 1392
                self.match(NeoBasicParser.OUT)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1393
                self.match(NeoBasicParser.OUT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrefixParameterNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAMED_ARGUMENTS(self):
            return self.getToken(NeoBasicParser.NAMED_ARGUMENTS, 0)

        def NAMED_OPTIONS(self):
            return self.getToken(NeoBasicParser.NAMED_OPTIONS, 0)

        def TILDE(self):
            return self.getToken(NeoBasicParser.TILDE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_prefixParameterName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrefixParameterName" ):
                listener.enterPrefixParameterName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrefixParameterName" ):
                listener.exitPrefixParameterName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrefixParameterName" ):
                return visitor.visitPrefixParameterName(self)
            else:
                return visitor.visitChildren(self)




    def prefixParameterName(self):

        localctx = NeoBasicParser.PrefixParameterNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_prefixParameterName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1396
            _la = self._input.LA(1)
            if not(_la==292 or _la==293 or _la==450):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrefixParameterTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELLIPSIS(self):
            return self.getToken(NeoBasicParser.ELLIPSIS, 0)

        def INTERVAL_INCLUSIVE(self):
            return self.getToken(NeoBasicParser.INTERVAL_INCLUSIVE, 0)

        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_prefixParameterType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrefixParameterType" ):
                listener.enterPrefixParameterType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrefixParameterType" ):
                listener.exitPrefixParameterType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrefixParameterType" ):
                return visitor.visitPrefixParameterType(self)
            else:
                return visitor.visitChildren(self)




    def prefixParameterType(self):

        localctx = NeoBasicParser.PrefixParameterTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_prefixParameterType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1398
            _la = self._input.LA(1)
            if not(_la==290 or _la==334 or _la==441):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcResultTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def types(self):
            return self.getTypedRuleContext(NeoBasicParser.TypesContext,0)


        def LEFT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LEFT_PARENTHESIS, 0)

        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_procResultType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcResultType" ):
                listener.enterProcResultType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcResultType" ):
                listener.exitProcResultType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcResultType" ):
                return visitor.visitProcResultType(self)
            else:
                return visitor.visitChildren(self)




    def procResultType(self):

        localctx = NeoBasicParser.ProcResultTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_procResultType)
        try:
            self.state = 1406
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,67,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1400
                self.type_(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1401
                self.types()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1402
                self.match(NeoBasicParser.LEFT_PARENTHESIS)
                self.state = 1403
                self.types()
                self.state = 1404
                self.match(NeoBasicParser.RIGHT_PARENTHESIS)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def procSemex(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcSemexContext,0)


        def procImplicitReturn(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcImplicitReturnContext,0)


        def procPatternGuards(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcPatternGuardsContext,0)


        def procSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_procBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcBody" ):
                listener.enterProcBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcBody" ):
                listener.exitProcBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcBody" ):
                return visitor.visitProcBody(self)
            else:
                return visitor.visitChildren(self)




    def procBody(self):

        localctx = NeoBasicParser.ProcBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_procBody)
        try:
            self.state = 1412
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,68,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1408
                self.procSemex()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1409
                self.procImplicitReturn()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1410
                self.procPatternGuards()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1411
                self.procSuite()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_procSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcSuite" ):
                listener.enterProcSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcSuite" ):
                listener.exitProcSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcSuite" ):
                return visitor.visitProcSuite(self)
            else:
                return visitor.visitChildren(self)




    def procSuite(self):

        localctx = NeoBasicParser.ProcSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_procSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1414
            self.logicalInstructionSuite()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcSemexContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def procSpecifier(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcSpecifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_procSemex

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcSemex" ):
                listener.enterProcSemex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcSemex" ):
                listener.exitProcSemex(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcSemex" ):
                return visitor.visitProcSemex(self)
            else:
                return visitor.visitChildren(self)




    def procSemex(self):

        localctx = NeoBasicParser.ProcSemexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_procSemex)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1416
            self.match(NeoBasicParser.COLON)
            self.state = 1417
            self.procSpecifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcSpecifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFAULT(self):
            return self.getToken(NeoBasicParser.DEFAULT, 0)

        def DELETE(self):
            return self.getToken(NeoBasicParser.DELETE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_procSpecifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcSpecifier" ):
                listener.enterProcSpecifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcSpecifier" ):
                listener.exitProcSpecifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcSpecifier" ):
                return visitor.visitProcSpecifier(self)
            else:
                return visitor.visitChildren(self)




    def procSpecifier(self):

        localctx = NeoBasicParser.ProcSpecifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_procSpecifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1419
            _la = self._input.LA(1)
            if not(_la==29 or _la==84):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcImplicitReturnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IMPLICIT_RETURN(self):
            return self.getToken(NeoBasicParser.IMPLICIT_RETURN, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_procImplicitReturn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcImplicitReturn" ):
                listener.enterProcImplicitReturn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcImplicitReturn" ):
                listener.exitProcImplicitReturn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcImplicitReturn" ):
                return visitor.visitProcImplicitReturn(self)
            else:
                return visitor.visitChildren(self)




    def procImplicitReturn(self):

        localctx = NeoBasicParser.ProcImplicitReturnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_procImplicitReturn)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1421
            self.match(NeoBasicParser.IMPLICIT_RETURN)
            self.state = 1422
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcPatternGuardsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def guardBranchClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.GuardBranchClauseContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.GuardBranchClauseContext,i)


        def guardElseClause(self):
            return self.getTypedRuleContext(NeoBasicParser.GuardElseClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_procPatternGuards

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcPatternGuards" ):
                listener.enterProcPatternGuards(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcPatternGuards" ):
                listener.exitProcPatternGuards(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcPatternGuards" ):
                return visitor.visitProcPatternGuards(self)
            else:
                return visitor.visitChildren(self)




    def procPatternGuards(self):

        localctx = NeoBasicParser.ProcPatternGuardsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_procPatternGuards)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1425 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1424
                    self.guardBranchClause()

                else:
                    raise NoViableAltException(self)
                self.state = 1427 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,69,self._ctx)

            self.state = 1430
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
            if la_ == 1:
                self.state = 1429
                self.guardElseClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GuardBranchClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def PIPE(self):
            return self.getToken(NeoBasicParser.PIPE, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def IMPLICIT_RETURN(self):
            return self.getToken(NeoBasicParser.IMPLICIT_RETURN, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_guardBranchClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGuardBranchClause" ):
                listener.enterGuardBranchClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGuardBranchClause" ):
                listener.exitGuardBranchClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGuardBranchClause" ):
                return visitor.visitGuardBranchClause(self)
            else:
                return visitor.visitChildren(self)




    def guardBranchClause(self):

        localctx = NeoBasicParser.GuardBranchClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_guardBranchClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1432
            self.match(NeoBasicParser.EOS)
            self.state = 1433
            self.match(NeoBasicParser.PIPE)
            self.state = 1434
            self.expressions()
            self.state = 1435
            self.match(NeoBasicParser.IMPLICIT_RETURN)
            self.state = 1436
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GuardElseClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def PIPE(self):
            return self.getToken(NeoBasicParser.PIPE, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def ELSE(self):
            return self.getToken(NeoBasicParser.ELSE, 0)

        def IMPLICIT_RETURN(self):
            return self.getToken(NeoBasicParser.IMPLICIT_RETURN, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_guardElseClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGuardElseClause" ):
                listener.enterGuardElseClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGuardElseClause" ):
                listener.exitGuardElseClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGuardElseClause" ):
                return visitor.visitGuardElseClause(self)
            else:
                return visitor.visitChildren(self)




    def guardElseClause(self):

        localctx = NeoBasicParser.GuardElseClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_guardElseClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1438
            self.match(NeoBasicParser.EOS)
            self.state = 1439
            self.match(NeoBasicParser.PIPE)
            self.state = 1442
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==51:
                self.state = 1440
                self.match(NeoBasicParser.ELSE)
                self.state = 1441
                self.match(NeoBasicParser.IMPLICIT_RETURN)


            self.state = 1444
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OuterDeclareSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeSentenceContext,0)


        def constSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.ConstSentenceContext,0)


        def letSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.LetSentenceContext,0)


        def varSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.VarSentenceContext,0)


        def castSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.CastSentenceContext,0)


        def factSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.FactSentenceContext,0)


        def macroSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.MacroSentenceContext,0)


        def funcSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.FuncSentenceContext,0)


        def feedSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.FeedSentenceContext,0)


        def subSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.SubSentenceContext,0)


        def operatorSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.OperatorSentenceContext,0)


        def eventSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.EventSentenceContext,0)


        def enumSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.EnumSentenceContext,0)


        def structSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.StructSentenceContext,0)


        def protoSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.ProtoSentenceContext,0)


        def traitSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.TraitSentenceContext,0)


        def classSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.ClassSentenceContext,0)


        def objectSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.ObjectSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_outerDeclareSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOuterDeclareSentence" ):
                listener.enterOuterDeclareSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOuterDeclareSentence" ):
                listener.exitOuterDeclareSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOuterDeclareSentence" ):
                return visitor.visitOuterDeclareSentence(self)
            else:
                return visitor.visitChildren(self)




    def outerDeclareSentence(self):

        localctx = NeoBasicParser.OuterDeclareSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_outerDeclareSentence)
        try:
            self.state = 1464
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [17]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1446
                self.typeSentence()
                pass
            elif token in [18]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1447
                self.constSentence()
                pass
            elif token in [19]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1448
                self.letSentence()
                pass
            elif token in [20]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1449
                self.varSentence()
                pass
            elif token in [21]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1450
                self.castSentence()
                pass
            elif token in [22]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1451
                self.factSentence()
                pass
            elif token in [30]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1452
                self.macroSentence()
                pass
            elif token in [23]:
                self.enterOuterAlt(localctx, 8)
                self.state = 1453
                self.funcSentence()
                pass
            elif token in [24]:
                self.enterOuterAlt(localctx, 9)
                self.state = 1454
                self.feedSentence()
                pass
            elif token in [25]:
                self.enterOuterAlt(localctx, 10)
                self.state = 1455
                self.subSentence()
                pass
            elif token in [32]:
                self.enterOuterAlt(localctx, 11)
                self.state = 1456
                self.operatorSentence()
                pass
            elif token in [33]:
                self.enterOuterAlt(localctx, 12)
                self.state = 1457
                self.eventSentence()
                pass
            elif token in [34]:
                self.enterOuterAlt(localctx, 13)
                self.state = 1458
                self.enumSentence()
                pass
            elif token in [35]:
                self.enterOuterAlt(localctx, 14)
                self.state = 1459
                self.structSentence()
                pass
            elif token in [36]:
                self.enterOuterAlt(localctx, 15)
                self.state = 1460
                self.protoSentence()
                pass
            elif token in [37]:
                self.enterOuterAlt(localctx, 16)
                self.state = 1461
                self.traitSentence()
                pass
            elif token in [38]:
                self.enterOuterAlt(localctx, 17)
                self.state = 1462
                self.classSentence()
                pass
            elif token in [39]:
                self.enterOuterAlt(localctx, 18)
                self.state = 1463
                self.objectSentence()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeClause(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_typeSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeSentence" ):
                listener.enterTypeSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeSentence" ):
                listener.exitTypeSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeSentence" ):
                return visitor.visitTypeSentence(self)
            else:
                return visitor.visitChildren(self)




    def typeSentence(self):

        localctx = NeoBasicParser.TypeSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_typeSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1466
            self.typeClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPE(self):
            return self.getToken(NeoBasicParser.TYPE, 0)

        def typeSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeSuiteContext,0)


        def typeDeclare(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeDeclareContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_typeClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeClause" ):
                listener.enterTypeClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeClause" ):
                listener.exitTypeClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeClause" ):
                return visitor.visitTypeClause(self)
            else:
                return visitor.visitChildren(self)




    def typeClause(self):

        localctx = NeoBasicParser.TypeClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_typeClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1468
            self.match(NeoBasicParser.TYPE)
            self.state = 1471
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [423]:
                self.state = 1469
                self.typeSuite()
                pass
            elif token in [381, 382, 383]:
                self.state = 1470
                self.typeDeclare()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def typeDeclareBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeDeclareBlockContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_typeSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeSuite" ):
                listener.enterTypeSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeSuite" ):
                listener.exitTypeSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeSuite" ):
                return visitor.visitTypeSuite(self)
            else:
                return visitor.visitChildren(self)




    def typeSuite(self):

        localctx = NeoBasicParser.TypeSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_typeSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1473
            self.match(NeoBasicParser.EOS)
            self.state = 1474
            self.match(NeoBasicParser.INDENT)
            self.state = 1475
            self.typeDeclareBlock()
            self.state = 1476
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeDeclareBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeDeclare(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.TypeDeclareContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.TypeDeclareContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_typeDeclareBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeDeclareBlock" ):
                listener.enterTypeDeclareBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeDeclareBlock" ):
                listener.exitTypeDeclareBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeDeclareBlock" ):
                return visitor.visitTypeDeclareBlock(self)
            else:
                return visitor.visitChildren(self)




    def typeDeclareBlock(self):

        localctx = NeoBasicParser.TypeDeclareBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_typeDeclareBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1478
            self.typeDeclare()
            self.state = 1483
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==423:
                self.state = 1479
                self.match(NeoBasicParser.EOS)
                self.state = 1480
                self.typeDeclare()
                self.state = 1485
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeDeclareContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeDeclareSingle(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeDeclareSingleContext,0)


        def typeDeclareSubrange(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeDeclareSubrangeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_typeDeclare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeDeclare" ):
                listener.enterTypeDeclare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeDeclare" ):
                listener.exitTypeDeclare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeDeclare" ):
                return visitor.visitTypeDeclare(self)
            else:
                return visitor.visitChildren(self)




    def typeDeclare(self):

        localctx = NeoBasicParser.TypeDeclareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_typeDeclare)
        try:
            self.state = 1488
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,75,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1486
                self.typeDeclareSingle()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1487
                self.typeDeclareSubrange()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeDeclareSingleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def genericDecoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.GenericDecoratedIdentifierContext,0)


        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def IS(self):
            return self.getToken(NeoBasicParser.IS, 0)

        def ANCESTOROF(self):
            return self.getToken(NeoBasicParser.ANCESTOROF, 0)

        def EXTENDS(self):
            return self.getToken(NeoBasicParser.EXTENDS, 0)

        def IMPLEMENTS(self):
            return self.getToken(NeoBasicParser.IMPLEMENTS, 0)

        def MIXES(self):
            return self.getToken(NeoBasicParser.MIXES, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_typeDeclareSingle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeDeclareSingle" ):
                listener.enterTypeDeclareSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeDeclareSingle" ):
                listener.exitTypeDeclareSingle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeDeclareSingle" ):
                return visitor.visitTypeDeclareSingle(self)
            else:
                return visitor.visitChildren(self)




    def typeDeclareSingle(self):

        localctx = NeoBasicParser.TypeDeclareSingleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_typeDeclareSingle)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1490
            self.genericDecoratedIdentifier()
            self.state = 1491
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 7696581394432) != 0) or _la==110 or _la==111):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1492
            self.type_(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeDeclareSubrangeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def genericDecoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.GenericDecoratedIdentifierContext,0)


        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def rangeLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.RangeLiteralContext,0)


        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_typeDeclareSubrange

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeDeclareSubrange" ):
                listener.enterTypeDeclareSubrange(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeDeclareSubrange" ):
                listener.exitTypeDeclareSubrange(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeDeclareSubrange" ):
                return visitor.visitTypeDeclareSubrange(self)
            else:
                return visitor.visitChildren(self)




    def typeDeclareSubrange(self):

        localctx = NeoBasicParser.TypeDeclareSubrangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_typeDeclareSubrange)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1494
            self.genericDecoratedIdentifier()
            self.state = 1496
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 247385886433392) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & -1) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & 16777215) != 0) or ((((_la - 259)) & ~0x3f) == 0 and ((1 << (_la - 259)) & 585) != 0) or _la==381 or _la==434:
                self.state = 1495
                self.type_(0)


            self.state = 1498
            self.match(NeoBasicParser.COLON)
            self.state = 1499
            self.rangeLiteral()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ConstClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_constSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstSentence" ):
                listener.enterConstSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstSentence" ):
                listener.exitConstSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstSentence" ):
                return visitor.visitConstSentence(self)
            else:
                return visitor.visitChildren(self)




    def constSentence(self):

        localctx = NeoBasicParser.ConstSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_constSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1501
            self.constClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONST(self):
            return self.getToken(NeoBasicParser.CONST, 0)

        def constSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.ConstSuiteContext,0)


        def constDeclare(self):
            return self.getTypedRuleContext(NeoBasicParser.ConstDeclareContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_constClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstClause" ):
                listener.enterConstClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstClause" ):
                listener.exitConstClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstClause" ):
                return visitor.visitConstClause(self)
            else:
                return visitor.visitChildren(self)




    def constClause(self):

        localctx = NeoBasicParser.ConstClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_constClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1503
            self.match(NeoBasicParser.CONST)
            self.state = 1506
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [423]:
                self.state = 1504
                self.constSuite()
                pass
            elif token in [381, 382, 383, 432]:
                self.state = 1505
                self.constDeclare()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def constDeclareBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.ConstDeclareBlockContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_constSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstSuite" ):
                listener.enterConstSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstSuite" ):
                listener.exitConstSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstSuite" ):
                return visitor.visitConstSuite(self)
            else:
                return visitor.visitChildren(self)




    def constSuite(self):

        localctx = NeoBasicParser.ConstSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_constSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1508
            self.match(NeoBasicParser.EOS)
            self.state = 1509
            self.match(NeoBasicParser.INDENT)
            self.state = 1510
            self.constDeclareBlock()
            self.state = 1511
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstDeclareBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constDeclare(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ConstDeclareContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ConstDeclareContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_constDeclareBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstDeclareBlock" ):
                listener.enterConstDeclareBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstDeclareBlock" ):
                listener.exitConstDeclareBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstDeclareBlock" ):
                return visitor.visitConstDeclareBlock(self)
            else:
                return visitor.visitChildren(self)




    def constDeclareBlock(self):

        localctx = NeoBasicParser.ConstDeclareBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_constDeclareBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1513
            self.constDeclare()
            self.state = 1518
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==423:
                self.state = 1514
                self.match(NeoBasicParser.EOS)
                self.state = 1515
                self.constDeclare()
                self.state = 1520
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstDeclareContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constDeclareSingle(self):
            return self.getTypedRuleContext(NeoBasicParser.ConstDeclareSingleContext,0)


        def constDeclareMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.ConstDeclareMultipleContext,0)


        def constDeclareParallel(self):
            return self.getTypedRuleContext(NeoBasicParser.ConstDeclareParallelContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_constDeclare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstDeclare" ):
                listener.enterConstDeclare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstDeclare" ):
                listener.exitConstDeclare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstDeclare" ):
                return visitor.visitConstDeclare(self)
            else:
                return visitor.visitChildren(self)




    def constDeclare(self):

        localctx = NeoBasicParser.ConstDeclareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_constDeclare)
        try:
            self.state = 1524
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,79,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1521
                self.constDeclareSingle()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1522
                self.constDeclareMultiple()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1523
                self.constDeclareParallel()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstDeclareSingleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def inferredDecoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifierContext,0)


        def singleAssignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.SingleAssignmentOperatorContext,0)


        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_constDeclareSingle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstDeclareSingle" ):
                listener.enterConstDeclareSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstDeclareSingle" ):
                listener.exitConstDeclareSingle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstDeclareSingle" ):
                return visitor.visitConstDeclareSingle(self)
            else:
                return visitor.visitChildren(self)




    def constDeclareSingle(self):

        localctx = NeoBasicParser.ConstDeclareSingleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 222, self.RULE_constDeclareSingle)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1526
            self.inferredDecoratedIdentifier()
            self.state = 1527
            self.singleAssignmentOperator()
            self.state = 1528
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstDeclareMultipleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constDeclareSingle(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ConstDeclareSingleContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ConstDeclareSingleContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def INDENT(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.INDENT)
            else:
                return self.getToken(NeoBasicParser.INDENT, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_constDeclareMultiple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstDeclareMultiple" ):
                listener.enterConstDeclareMultiple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstDeclareMultiple" ):
                listener.exitConstDeclareMultiple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstDeclareMultiple" ):
                return visitor.visitConstDeclareMultiple(self)
            else:
                return visitor.visitChildren(self)




    def constDeclareMultiple(self):

        localctx = NeoBasicParser.ConstDeclareMultipleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_constDeclareMultiple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1530
            self.constDeclareSingle()
            self.state = 1535 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1531
                self.match(NeoBasicParser.COMMA)
                self.state = 1532
                self.constDeclareSingle()
                self.state = 1533
                self.match(NeoBasicParser.INDENT)
                self.state = 1537 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==439):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstDeclareParallelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LEFT_PARENTHESIS, 0)

        def inferredDecoratedIdentifiers(self):
            return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifiersContext,0)


        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def unpackingAssignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnpackingAssignmentOperatorContext,0)


        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_constDeclareParallel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstDeclareParallel" ):
                listener.enterConstDeclareParallel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstDeclareParallel" ):
                listener.exitConstDeclareParallel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstDeclareParallel" ):
                return visitor.visitConstDeclareParallel(self)
            else:
                return visitor.visitChildren(self)




    def constDeclareParallel(self):

        localctx = NeoBasicParser.ConstDeclareParallelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_constDeclareParallel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1539
            self.match(NeoBasicParser.LEFT_PARENTHESIS)
            self.state = 1540
            self.inferredDecoratedIdentifiers()
            self.state = 1541
            self.match(NeoBasicParser.RIGHT_PARENTHESIS)
            self.state = 1542
            self.unpackingAssignmentOperator()
            self.state = 1543
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LetSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def letClause(self):
            return self.getTypedRuleContext(NeoBasicParser.LetClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_letSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLetSentence" ):
                listener.enterLetSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLetSentence" ):
                listener.exitLetSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLetSentence" ):
                return visitor.visitLetSentence(self)
            else:
                return visitor.visitChildren(self)




    def letSentence(self):

        localctx = NeoBasicParser.LetSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_letSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1545
            self.letClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LetClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LET(self):
            return self.getToken(NeoBasicParser.LET, 0)

        def letSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LetSuiteContext,0)


        def letDeclare(self):
            return self.getTypedRuleContext(NeoBasicParser.LetDeclareContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_letClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLetClause" ):
                listener.enterLetClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLetClause" ):
                listener.exitLetClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLetClause" ):
                return visitor.visitLetClause(self)
            else:
                return visitor.visitChildren(self)




    def letClause(self):

        localctx = NeoBasicParser.LetClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_letClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1547
            self.match(NeoBasicParser.LET)
            self.state = 1550
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [423]:
                self.state = 1548
                self.letSuite()
                pass
            elif token in [381, 382, 383, 432]:
                self.state = 1549
                self.letDeclare()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LetSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def letDeclareBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.LetDeclareBlockContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_letSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLetSuite" ):
                listener.enterLetSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLetSuite" ):
                listener.exitLetSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLetSuite" ):
                return visitor.visitLetSuite(self)
            else:
                return visitor.visitChildren(self)




    def letSuite(self):

        localctx = NeoBasicParser.LetSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_letSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1552
            self.match(NeoBasicParser.EOS)
            self.state = 1553
            self.match(NeoBasicParser.INDENT)
            self.state = 1554
            self.letDeclareBlock()
            self.state = 1555
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LetDeclareBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def letDeclare(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.LetDeclareContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.LetDeclareContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_letDeclareBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLetDeclareBlock" ):
                listener.enterLetDeclareBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLetDeclareBlock" ):
                listener.exitLetDeclareBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLetDeclareBlock" ):
                return visitor.visitLetDeclareBlock(self)
            else:
                return visitor.visitChildren(self)




    def letDeclareBlock(self):

        localctx = NeoBasicParser.LetDeclareBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_letDeclareBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1557
            self.letDeclare()
            self.state = 1562
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==423:
                self.state = 1558
                self.match(NeoBasicParser.EOS)
                self.state = 1559
                self.letDeclare()
                self.state = 1564
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LetDeclareContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def letDeclareSingle(self):
            return self.getTypedRuleContext(NeoBasicParser.LetDeclareSingleContext,0)


        def letDeclareMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.LetDeclareMultipleContext,0)


        def letDeclareParallel(self):
            return self.getTypedRuleContext(NeoBasicParser.LetDeclareParallelContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_letDeclare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLetDeclare" ):
                listener.enterLetDeclare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLetDeclare" ):
                listener.exitLetDeclare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLetDeclare" ):
                return visitor.visitLetDeclare(self)
            else:
                return visitor.visitChildren(self)




    def letDeclare(self):

        localctx = NeoBasicParser.LetDeclareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_letDeclare)
        try:
            self.state = 1568
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1565
                self.letDeclareSingle()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1566
                self.letDeclareMultiple()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1567
                self.letDeclareParallel()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LetDeclareSingleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def inferredDecoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifierContext,0)


        def singleAssignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.SingleAssignmentOperatorContext,0)


        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_letDeclareSingle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLetDeclareSingle" ):
                listener.enterLetDeclareSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLetDeclareSingle" ):
                listener.exitLetDeclareSingle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLetDeclareSingle" ):
                return visitor.visitLetDeclareSingle(self)
            else:
                return visitor.visitChildren(self)




    def letDeclareSingle(self):

        localctx = NeoBasicParser.LetDeclareSingleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_letDeclareSingle)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1570
            self.inferredDecoratedIdentifier()
            self.state = 1574
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 353)) & ~0x3f) == 0 and ((1 << (_la - 353)) & 63) != 0):
                self.state = 1571
                self.singleAssignmentOperator()
                self.state = 1572
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LetDeclareMultipleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def letDeclareSingle(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.LetDeclareSingleContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.LetDeclareSingleContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_letDeclareMultiple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLetDeclareMultiple" ):
                listener.enterLetDeclareMultiple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLetDeclareMultiple" ):
                listener.exitLetDeclareMultiple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLetDeclareMultiple" ):
                return visitor.visitLetDeclareMultiple(self)
            else:
                return visitor.visitChildren(self)




    def letDeclareMultiple(self):

        localctx = NeoBasicParser.LetDeclareMultipleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_letDeclareMultiple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1576
            self.letDeclareSingle()
            self.state = 1579 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1577
                self.match(NeoBasicParser.COMMA)
                self.state = 1578
                self.letDeclareSingle()
                self.state = 1581 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==439):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LetDeclareParallelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LEFT_PARENTHESIS, 0)

        def inferredDecoratedIdentifiers(self):
            return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifiersContext,0)


        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def unpackingAssignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnpackingAssignmentOperatorContext,0)


        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_letDeclareParallel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLetDeclareParallel" ):
                listener.enterLetDeclareParallel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLetDeclareParallel" ):
                listener.exitLetDeclareParallel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLetDeclareParallel" ):
                return visitor.visitLetDeclareParallel(self)
            else:
                return visitor.visitChildren(self)




    def letDeclareParallel(self):

        localctx = NeoBasicParser.LetDeclareParallelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 242, self.RULE_letDeclareParallel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1583
            self.match(NeoBasicParser.LEFT_PARENTHESIS)
            self.state = 1584
            self.inferredDecoratedIdentifiers()
            self.state = 1585
            self.match(NeoBasicParser.RIGHT_PARENTHESIS)
            self.state = 1586
            self.unpackingAssignmentOperator()
            self.state = 1587
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varClause(self):
            return self.getTypedRuleContext(NeoBasicParser.VarClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_varSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarSentence" ):
                listener.enterVarSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarSentence" ):
                listener.exitVarSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarSentence" ):
                return visitor.visitVarSentence(self)
            else:
                return visitor.visitChildren(self)




    def varSentence(self):

        localctx = NeoBasicParser.VarSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 244, self.RULE_varSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1589
            self.varClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAR(self):
            return self.getToken(NeoBasicParser.VAR, 0)

        def varSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.VarSuiteContext,0)


        def varDeclare(self):
            return self.getTypedRuleContext(NeoBasicParser.VarDeclareContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_varClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarClause" ):
                listener.enterVarClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarClause" ):
                listener.exitVarClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarClause" ):
                return visitor.visitVarClause(self)
            else:
                return visitor.visitChildren(self)




    def varClause(self):

        localctx = NeoBasicParser.VarClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 246, self.RULE_varClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1591
            self.match(NeoBasicParser.VAR)
            self.state = 1594
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [423]:
                self.state = 1592
                self.varSuite()
                pass
            elif token in [381, 382, 383, 432]:
                self.state = 1593
                self.varDeclare()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def varDeclareBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.VarDeclareBlockContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_varSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarSuite" ):
                listener.enterVarSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarSuite" ):
                listener.exitVarSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarSuite" ):
                return visitor.visitVarSuite(self)
            else:
                return visitor.visitChildren(self)




    def varSuite(self):

        localctx = NeoBasicParser.VarSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 248, self.RULE_varSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1596
            self.match(NeoBasicParser.EOS)
            self.state = 1597
            self.match(NeoBasicParser.INDENT)
            self.state = 1598
            self.varDeclareBlock()
            self.state = 1599
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarDeclareBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varDeclare(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.VarDeclareContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.VarDeclareContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_varDeclareBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarDeclareBlock" ):
                listener.enterVarDeclareBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarDeclareBlock" ):
                listener.exitVarDeclareBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarDeclareBlock" ):
                return visitor.visitVarDeclareBlock(self)
            else:
                return visitor.visitChildren(self)




    def varDeclareBlock(self):

        localctx = NeoBasicParser.VarDeclareBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 250, self.RULE_varDeclareBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1601
            self.varDeclare()
            self.state = 1606
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==423:
                self.state = 1602
                self.match(NeoBasicParser.EOS)
                self.state = 1603
                self.varDeclare()
                self.state = 1608
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarDeclareContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varDeclareSingle(self):
            return self.getTypedRuleContext(NeoBasicParser.VarDeclareSingleContext,0)


        def varDeclareMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.VarDeclareMultipleContext,0)


        def varDeclareParallel(self):
            return self.getTypedRuleContext(NeoBasicParser.VarDeclareParallelContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_varDeclare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarDeclare" ):
                listener.enterVarDeclare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarDeclare" ):
                listener.exitVarDeclare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarDeclare" ):
                return visitor.visitVarDeclare(self)
            else:
                return visitor.visitChildren(self)




    def varDeclare(self):

        localctx = NeoBasicParser.VarDeclareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 252, self.RULE_varDeclare)
        try:
            self.state = 1612
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,88,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1609
                self.varDeclareSingle()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1610
                self.varDeclareMultiple()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1611
                self.varDeclareParallel()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarDeclareSingleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def inferredDecoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifierContext,0)


        def singleAssignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.SingleAssignmentOperatorContext,0)


        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_varDeclareSingle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarDeclareSingle" ):
                listener.enterVarDeclareSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarDeclareSingle" ):
                listener.exitVarDeclareSingle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarDeclareSingle" ):
                return visitor.visitVarDeclareSingle(self)
            else:
                return visitor.visitChildren(self)




    def varDeclareSingle(self):

        localctx = NeoBasicParser.VarDeclareSingleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 254, self.RULE_varDeclareSingle)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1614
            self.inferredDecoratedIdentifier()
            self.state = 1618
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 353)) & ~0x3f) == 0 and ((1 << (_la - 353)) & 63) != 0):
                self.state = 1615
                self.singleAssignmentOperator()
                self.state = 1616
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarDeclareMultipleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varDeclareSingle(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.VarDeclareSingleContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.VarDeclareSingleContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_varDeclareMultiple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarDeclareMultiple" ):
                listener.enterVarDeclareMultiple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarDeclareMultiple" ):
                listener.exitVarDeclareMultiple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarDeclareMultiple" ):
                return visitor.visitVarDeclareMultiple(self)
            else:
                return visitor.visitChildren(self)




    def varDeclareMultiple(self):

        localctx = NeoBasicParser.VarDeclareMultipleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 256, self.RULE_varDeclareMultiple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1620
            self.varDeclareSingle()
            self.state = 1623 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1621
                self.match(NeoBasicParser.COMMA)
                self.state = 1622
                self.varDeclareSingle()
                self.state = 1625 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==439):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarDeclareParallelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LEFT_PARENTHESIS, 0)

        def inferredDecoratedIdentifiers(self):
            return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifiersContext,0)


        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def unpackingAssignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnpackingAssignmentOperatorContext,0)


        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_varDeclareParallel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarDeclareParallel" ):
                listener.enterVarDeclareParallel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarDeclareParallel" ):
                listener.exitVarDeclareParallel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarDeclareParallel" ):
                return visitor.visitVarDeclareParallel(self)
            else:
                return visitor.visitChildren(self)




    def varDeclareParallel(self):

        localctx = NeoBasicParser.VarDeclareParallelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 258, self.RULE_varDeclareParallel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1627
            self.match(NeoBasicParser.LEFT_PARENTHESIS)
            self.state = 1628
            self.inferredDecoratedIdentifiers()
            self.state = 1629
            self.match(NeoBasicParser.RIGHT_PARENTHESIS)
            self.state = 1630
            self.unpackingAssignmentOperator()
            self.state = 1631
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CastSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def castClause(self):
            return self.getTypedRuleContext(NeoBasicParser.CastClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_castSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCastSentence" ):
                listener.enterCastSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCastSentence" ):
                listener.exitCastSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCastSentence" ):
                return visitor.visitCastSentence(self)
            else:
                return visitor.visitChildren(self)




    def castSentence(self):

        localctx = NeoBasicParser.CastSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 260, self.RULE_castSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1633
            self.castClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CastClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CAST(self):
            return self.getToken(NeoBasicParser.CAST, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def parenthesizedParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParametersContext,0)


        def procResultType(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcResultTypeContext,0)


        def raisesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.RaisesClauseContext,0)


        def procBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcBodyContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_castClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCastClause" ):
                listener.enterCastClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCastClause" ):
                listener.exitCastClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCastClause" ):
                return visitor.visitCastClause(self)
            else:
                return visitor.visitChildren(self)




    def castClause(self):

        localctx = NeoBasicParser.CastClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 262, self.RULE_castClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1635
            self.match(NeoBasicParser.CAST)
            self.state = 1636
            self.declarationIdentifier()
            self.state = 1637
            self.parenthesizedParameters()
            self.state = 1638
            self.procResultType()
            self.state = 1640
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==27 or _la==28:
                self.state = 1639
                self.raisesClause()


            self.state = 1643
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,92,self._ctx)
            if la_ == 1:
                self.state = 1642
                self.procBody()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FactSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def factClause(self):
            return self.getTypedRuleContext(NeoBasicParser.FactClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_factSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactSentence" ):
                listener.enterFactSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactSentence" ):
                listener.exitFactSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactSentence" ):
                return visitor.visitFactSentence(self)
            else:
                return visitor.visitChildren(self)




    def factSentence(self):

        localctx = NeoBasicParser.FactSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 264, self.RULE_factSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1645
            self.factClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FactClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FACT(self):
            return self.getToken(NeoBasicParser.FACT, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def parenthesizedParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParametersContext,0)


        def procBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcBodyContext,0)


        def raisesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.RaisesClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_factClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactClause" ):
                listener.enterFactClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactClause" ):
                listener.exitFactClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactClause" ):
                return visitor.visitFactClause(self)
            else:
                return visitor.visitChildren(self)




    def factClause(self):

        localctx = NeoBasicParser.FactClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 266, self.RULE_factClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1647
            self.match(NeoBasicParser.FACT)
            self.state = 1648
            self.declarationIdentifier()
            self.state = 1649
            self.parenthesizedParameters()
            self.state = 1651
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==27 or _la==28:
                self.state = 1650
                self.raisesClause()


            self.state = 1653
            self.procBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MacroSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def macroClause(self):
            return self.getTypedRuleContext(NeoBasicParser.MacroClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_macroSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMacroSentence" ):
                listener.enterMacroSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMacroSentence" ):
                listener.exitMacroSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMacroSentence" ):
                return visitor.visitMacroSentence(self)
            else:
                return visitor.visitChildren(self)




    def macroSentence(self):

        localctx = NeoBasicParser.MacroSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 268, self.RULE_macroSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1655
            self.macroClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MacroClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MACRO(self):
            return self.getToken(NeoBasicParser.MACRO, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def parenthesizedParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParametersContext,0)


        def procBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcBodyContext,0)


        def mixesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.MixesClauseContext,0)


        def raisesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.RaisesClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_macroClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMacroClause" ):
                listener.enterMacroClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMacroClause" ):
                listener.exitMacroClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMacroClause" ):
                return visitor.visitMacroClause(self)
            else:
                return visitor.visitChildren(self)




    def macroClause(self):

        localctx = NeoBasicParser.MacroClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 270, self.RULE_macroClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1657
            self.match(NeoBasicParser.MACRO)
            self.state = 1658
            self.declarationIdentifier()
            self.state = 1659
            self.parenthesizedParameters()
            self.state = 1661
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==42:
                self.state = 1660
                self.mixesClause()


            self.state = 1664
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==27 or _la==28:
                self.state = 1663
                self.raisesClause()


            self.state = 1666
            self.procBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def funcClause(self):
            return self.getTypedRuleContext(NeoBasicParser.FuncClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_funcSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncSentence" ):
                listener.enterFuncSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncSentence" ):
                listener.exitFuncSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncSentence" ):
                return visitor.visitFuncSentence(self)
            else:
                return visitor.visitChildren(self)




    def funcSentence(self):

        localctx = NeoBasicParser.FuncSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 272, self.RULE_funcSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1668
            self.funcClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FUNC(self):
            return self.getToken(NeoBasicParser.FUNC, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def parenthesizedParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParametersContext,0)


        def procResultType(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcResultTypeContext,0)


        def raisesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.RaisesClauseContext,0)


        def procBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcBodyContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_funcClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncClause" ):
                listener.enterFuncClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncClause" ):
                listener.exitFuncClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncClause" ):
                return visitor.visitFuncClause(self)
            else:
                return visitor.visitChildren(self)




    def funcClause(self):

        localctx = NeoBasicParser.FuncClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 274, self.RULE_funcClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1670
            self.match(NeoBasicParser.FUNC)
            self.state = 1671
            self.declarationIdentifier()
            self.state = 1672
            self.parenthesizedParameters()
            self.state = 1673
            self.procResultType()
            self.state = 1675
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==27 or _la==28:
                self.state = 1674
                self.raisesClause()


            self.state = 1678
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,97,self._ctx)
            if la_ == 1:
                self.state = 1677
                self.procBody()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeedSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def feedClause(self):
            return self.getTypedRuleContext(NeoBasicParser.FeedClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_feedSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeedSentence" ):
                listener.enterFeedSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeedSentence" ):
                listener.exitFeedSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeedSentence" ):
                return visitor.visitFeedSentence(self)
            else:
                return visitor.visitChildren(self)




    def feedSentence(self):

        localctx = NeoBasicParser.FeedSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 276, self.RULE_feedSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1680
            self.feedClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeedClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FEED(self):
            return self.getToken(NeoBasicParser.FEED, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def parenthesizedParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParametersContext,0)


        def procResultType(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcResultTypeContext,0)


        def raisesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.RaisesClauseContext,0)


        def procBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcBodyContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_feedClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeedClause" ):
                listener.enterFeedClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeedClause" ):
                listener.exitFeedClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeedClause" ):
                return visitor.visitFeedClause(self)
            else:
                return visitor.visitChildren(self)




    def feedClause(self):

        localctx = NeoBasicParser.FeedClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 278, self.RULE_feedClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1682
            self.match(NeoBasicParser.FEED)
            self.state = 1683
            self.declarationIdentifier()
            self.state = 1684
            self.parenthesizedParameters()
            self.state = 1685
            self.procResultType()
            self.state = 1687
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==27 or _la==28:
                self.state = 1686
                self.raisesClause()


            self.state = 1690
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,99,self._ctx)
            if la_ == 1:
                self.state = 1689
                self.procBody()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subClause(self):
            return self.getTypedRuleContext(NeoBasicParser.SubClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_subSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubSentence" ):
                listener.enterSubSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubSentence" ):
                listener.exitSubSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubSentence" ):
                return visitor.visitSubSentence(self)
            else:
                return visitor.visitChildren(self)




    def subSentence(self):

        localctx = NeoBasicParser.SubSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 280, self.RULE_subSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1692
            self.subClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUB(self):
            return self.getToken(NeoBasicParser.SUB, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def parenthesizedParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParametersContext,0)


        def raisesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.RaisesClauseContext,0)


        def procBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcBodyContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_subClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubClause" ):
                listener.enterSubClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubClause" ):
                listener.exitSubClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubClause" ):
                return visitor.visitSubClause(self)
            else:
                return visitor.visitChildren(self)




    def subClause(self):

        localctx = NeoBasicParser.SubClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 282, self.RULE_subClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1694
            self.match(NeoBasicParser.SUB)
            self.state = 1695
            self.declarationIdentifier()
            self.state = 1696
            self.parenthesizedParameters()
            self.state = 1698
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==27 or _la==28:
                self.state = 1697
                self.raisesClause()


            self.state = 1701
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,101,self._ctx)
            if la_ == 1:
                self.state = 1700
                self.procBody()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperatorSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operatorClause(self):
            return self.getTypedRuleContext(NeoBasicParser.OperatorClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_operatorSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperatorSentence" ):
                listener.enterOperatorSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperatorSentence" ):
                listener.exitOperatorSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperatorSentence" ):
                return visitor.visitOperatorSentence(self)
            else:
                return visitor.visitChildren(self)




    def operatorSentence(self):

        localctx = NeoBasicParser.OperatorSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 284, self.RULE_operatorSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1703
            self.operatorClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperatorClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPERATOR(self):
            return self.getToken(NeoBasicParser.OPERATOR, 0)

        def operatorIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.OperatorIdentifierContext,0)


        def parenthesizedParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParametersContext,0)


        def procResultType(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcResultTypeContext,0)


        def raisesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.RaisesClauseContext,0)


        def procBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcBodyContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_operatorClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperatorClause" ):
                listener.enterOperatorClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperatorClause" ):
                listener.exitOperatorClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperatorClause" ):
                return visitor.visitOperatorClause(self)
            else:
                return visitor.visitChildren(self)




    def operatorClause(self):

        localctx = NeoBasicParser.OperatorClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 286, self.RULE_operatorClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1705
            self.match(NeoBasicParser.OPERATOR)
            self.state = 1706
            self.operatorIdentifier()
            self.state = 1707
            self.parenthesizedParameters()
            self.state = 1708
            self.procResultType()
            self.state = 1710
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==27 or _la==28:
                self.state = 1709
                self.raisesClause()


            self.state = 1713
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,103,self._ctx)
            if la_ == 1:
                self.state = 1712
                self.procBody()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperatorIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def declarationOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationOperatorContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_operatorIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperatorIdentifier" ):
                listener.enterOperatorIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperatorIdentifier" ):
                listener.exitOperatorIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperatorIdentifier" ):
                return visitor.visitOperatorIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def operatorIdentifier(self):

        localctx = NeoBasicParser.OperatorIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 288, self.RULE_operatorIdentifier)
        try:
            self.state = 1717
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,104,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1715
                self.declarationIdentifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1716
                self.declarationOperator()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def overloadableOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.OverloadableOperatorContext,0)


        def metadataDecorators(self):
            return self.getTypedRuleContext(NeoBasicParser.MetadataDecoratorsContext,0)


        def genericTypeParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.GenericTypeParametersContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_declarationOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclarationOperator" ):
                listener.enterDeclarationOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclarationOperator" ):
                listener.exitDeclarationOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeclarationOperator" ):
                return visitor.visitDeclarationOperator(self)
            else:
                return visitor.visitChildren(self)




    def declarationOperator(self):

        localctx = NeoBasicParser.DeclarationOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 290, self.RULE_declarationOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1720
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==382 or _la==383:
                self.state = 1719
                self.metadataDecorators()


            self.state = 1722
            self.overloadableOperator()
            self.state = 1724
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==313:
                self.state = 1723
                self.genericTypeParameters()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EventSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def eventClause(self):
            return self.getTypedRuleContext(NeoBasicParser.EventClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_eventSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEventSentence" ):
                listener.enterEventSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEventSentence" ):
                listener.exitEventSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEventSentence" ):
                return visitor.visitEventSentence(self)
            else:
                return visitor.visitChildren(self)




    def eventSentence(self):

        localctx = NeoBasicParser.EventSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 292, self.RULE_eventSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1726
            self.eventClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EventClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EVENT(self):
            return self.getToken(NeoBasicParser.EVENT, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def bracketedParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.BracketedParametersContext,0)


        def procResultType(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcResultTypeContext,0)


        def raisesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.RaisesClauseContext,0)


        def procBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcBodyContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_eventClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEventClause" ):
                listener.enterEventClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEventClause" ):
                listener.exitEventClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEventClause" ):
                return visitor.visitEventClause(self)
            else:
                return visitor.visitChildren(self)




    def eventClause(self):

        localctx = NeoBasicParser.EventClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 294, self.RULE_eventClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1728
            self.match(NeoBasicParser.EVENT)
            self.state = 1729
            self.declarationIdentifier()
            self.state = 1730
            self.bracketedParameters()
            self.state = 1731
            self.procResultType()
            self.state = 1733
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==27 or _la==28:
                self.state = 1732
                self.raisesClause()


            self.state = 1736
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,108,self._ctx)
            if la_ == 1:
                self.state = 1735
                self.procBody()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BracketedParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_BRACKET(self):
            return self.getToken(NeoBasicParser.LEFT_BRACKET, 0)

        def RIGHT_BRACKET(self):
            return self.getToken(NeoBasicParser.RIGHT_BRACKET, 0)

        def procParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcParametersContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_bracketedParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBracketedParameters" ):
                listener.enterBracketedParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBracketedParameters" ):
                listener.exitBracketedParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBracketedParameters" ):
                return visitor.visitBracketedParameters(self)
            else:
                return visitor.visitChildren(self)




    def bracketedParameters(self):

        localctx = NeoBasicParser.BracketedParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 296, self.RULE_bracketedParameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1738
            self.match(NeoBasicParser.LEFT_BRACKET)
            self.state = 1740
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 2215641088) != 0) or _la==112 or _la==292 or _la==293 or ((((_la - 381)) & ~0x3f) == 0 and ((1 << (_la - 381)) & 7) != 0) or _la==450:
                self.state = 1739
                self.procParameters()


            self.state = 1742
            self.match(NeoBasicParser.RIGHT_BRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enumClause(self):
            return self.getTypedRuleContext(NeoBasicParser.EnumClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_enumSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumSentence" ):
                listener.enterEnumSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumSentence" ):
                listener.exitEnumSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumSentence" ):
                return visitor.visitEnumSentence(self)
            else:
                return visitor.visitChildren(self)




    def enumSentence(self):

        localctx = NeoBasicParser.EnumSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 298, self.RULE_enumSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1744
            self.enumClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENUM(self):
            return self.getToken(NeoBasicParser.ENUM, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def enumBody(self):
            return self.getTypedRuleContext(NeoBasicParser.EnumBodyContext,0)


        def parenthesizedParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParametersContext,0)


        def enumType(self):
            return self.getTypedRuleContext(NeoBasicParser.EnumTypeContext,0)


        def mixesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.MixesClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_enumClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumClause" ):
                listener.enterEnumClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumClause" ):
                listener.exitEnumClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumClause" ):
                return visitor.visitEnumClause(self)
            else:
                return visitor.visitChildren(self)




    def enumClause(self):

        localctx = NeoBasicParser.EnumClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 300, self.RULE_enumClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1746
            self.match(NeoBasicParser.ENUM)
            self.state = 1747
            self.declarationIdentifier()
            self.state = 1749
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==432:
                self.state = 1748
                self.parenthesizedParameters()


            self.state = 1752
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 247385886433392) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & -1) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & 16777215) != 0) or ((((_la - 259)) & ~0x3f) == 0 and ((1 << (_la - 259)) & 585) != 0) or _la==381 or _la==434:
                self.state = 1751
                self.enumType()


            self.state = 1755
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==42:
                self.state = 1754
                self.mixesClause()


            self.state = 1757
            self.enumBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_enumType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumType" ):
                listener.enterEnumType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumType" ):
                listener.exitEnumType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumType" ):
                return visitor.visitEnumType(self)
            else:
                return visitor.visitChildren(self)




    def enumType(self):

        localctx = NeoBasicParser.EnumTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 302, self.RULE_enumType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1759
            self.type_(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enumSemex(self):
            return self.getTypedRuleContext(NeoBasicParser.EnumSemexContext,0)


        def enumSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.EnumSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_enumBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumBody" ):
                listener.enterEnumBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumBody" ):
                listener.exitEnumBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumBody" ):
                return visitor.visitEnumBody(self)
            else:
                return visitor.visitChildren(self)




    def enumBody(self):

        localctx = NeoBasicParser.EnumBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 304, self.RULE_enumBody)
        try:
            self.state = 1763
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [441]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1761
                self.enumSemex()
                pass
            elif token in [423]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1762
                self.enumSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumSemexContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def enumFieldMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.EnumFieldMultipleContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_enumSemex

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumSemex" ):
                listener.enterEnumSemex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumSemex" ):
                listener.exitEnumSemex(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumSemex" ):
                return visitor.visitEnumSemex(self)
            else:
                return visitor.visitChildren(self)




    def enumSemex(self):

        localctx = NeoBasicParser.EnumSemexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 306, self.RULE_enumSemex)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1765
            self.match(NeoBasicParser.COLON)
            self.state = 1766
            self.enumFieldMultiple()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def enumMembersBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.EnumMembersBlockContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_enumSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumSuite" ):
                listener.enterEnumSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumSuite" ):
                listener.exitEnumSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumSuite" ):
                return visitor.visitEnumSuite(self)
            else:
                return visitor.visitChildren(self)




    def enumSuite(self):

        localctx = NeoBasicParser.EnumSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 308, self.RULE_enumSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1768
            self.match(NeoBasicParser.EOS)
            self.state = 1769
            self.match(NeoBasicParser.INDENT)
            self.state = 1770
            self.enumMembersBlock()
            self.state = 1771
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumMembersBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enumMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.EnumMemberContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.EnumMemberContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_enumMembersBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumMembersBlock" ):
                listener.enterEnumMembersBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumMembersBlock" ):
                listener.exitEnumMembersBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumMembersBlock" ):
                return visitor.visitEnumMembersBlock(self)
            else:
                return visitor.visitChildren(self)




    def enumMembersBlock(self):

        localctx = NeoBasicParser.EnumMembersBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 310, self.RULE_enumMembersBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1773
            self.enumMember()
            self.state = 1778
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==423:
                self.state = 1774
                self.match(NeoBasicParser.EOS)
                self.state = 1775
                self.enumMember()
                self.state = 1780
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalInstruction(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionContext,0)


        def enumFieldSingle(self):
            return self.getTypedRuleContext(NeoBasicParser.EnumFieldSingleContext,0)


        def enumFieldMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.EnumFieldMultipleContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_enumMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumMember" ):
                listener.enterEnumMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumMember" ):
                listener.exitEnumMember(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumMember" ):
                return visitor.visitEnumMember(self)
            else:
                return visitor.visitChildren(self)




    def enumMember(self):

        localctx = NeoBasicParser.EnumMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 312, self.RULE_enumMember)
        try:
            self.state = 1784
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,115,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1781
                self.logicalInstruction()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1782
                self.enumFieldSingle()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1783
                self.enumFieldMultiple()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumFieldSingleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def decoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DecoratedIdentifierContext,0)


        def parenthesizedArguments(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedArgumentsContext,0)


        def EQUAL(self):
            return self.getToken(NeoBasicParser.EQUAL, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_enumFieldSingle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumFieldSingle" ):
                listener.enterEnumFieldSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumFieldSingle" ):
                listener.exitEnumFieldSingle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumFieldSingle" ):
                return visitor.visitEnumFieldSingle(self)
            else:
                return visitor.visitChildren(self)




    def enumFieldSingle(self):

        localctx = NeoBasicParser.EnumFieldSingleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 314, self.RULE_enumFieldSingle)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1786
            self.decoratedIdentifier()
            self.state = 1788
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==432:
                self.state = 1787
                self.parenthesizedArguments()


            self.state = 1792
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==353:
                self.state = 1790
                self.match(NeoBasicParser.EQUAL)
                self.state = 1791
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumFieldMultipleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enumFieldSingle(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.EnumFieldSingleContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.EnumFieldSingleContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_enumFieldMultiple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumFieldMultiple" ):
                listener.enterEnumFieldMultiple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumFieldMultiple" ):
                listener.exitEnumFieldMultiple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumFieldMultiple" ):
                return visitor.visitEnumFieldMultiple(self)
            else:
                return visitor.visitChildren(self)




    def enumFieldMultiple(self):

        localctx = NeoBasicParser.EnumFieldMultipleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 316, self.RULE_enumFieldMultiple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1794
            self.enumFieldSingle()
            self.state = 1799
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==439:
                self.state = 1795
                self.match(NeoBasicParser.COMMA)
                self.state = 1796
                self.enumFieldSingle()
                self.state = 1801
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def structClause(self):
            return self.getTypedRuleContext(NeoBasicParser.StructClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_structSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructSentence" ):
                listener.enterStructSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructSentence" ):
                listener.exitStructSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructSentence" ):
                return visitor.visitStructSentence(self)
            else:
                return visitor.visitChildren(self)




    def structSentence(self):

        localctx = NeoBasicParser.StructSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 318, self.RULE_structSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1802
            self.structClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRUCT(self):
            return self.getToken(NeoBasicParser.STRUCT, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def structBody(self):
            return self.getTypedRuleContext(NeoBasicParser.StructBodyContext,0)


        def mixesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.MixesClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_structClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructClause" ):
                listener.enterStructClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructClause" ):
                listener.exitStructClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructClause" ):
                return visitor.visitStructClause(self)
            else:
                return visitor.visitChildren(self)




    def structClause(self):

        localctx = NeoBasicParser.StructClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 320, self.RULE_structClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1804
            self.match(NeoBasicParser.STRUCT)
            self.state = 1805
            self.declarationIdentifier()
            self.state = 1807
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==42:
                self.state = 1806
                self.mixesClause()


            self.state = 1809
            self.structBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def structSemex(self):
            return self.getTypedRuleContext(NeoBasicParser.StructSemexContext,0)


        def structSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.StructSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_structBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructBody" ):
                listener.enterStructBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructBody" ):
                listener.exitStructBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructBody" ):
                return visitor.visitStructBody(self)
            else:
                return visitor.visitChildren(self)




    def structBody(self):

        localctx = NeoBasicParser.StructBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 322, self.RULE_structBody)
        try:
            self.state = 1813
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [441]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1811
                self.structSemex()
                pass
            elif token in [423]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1812
                self.structSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructSemexContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def structFieldMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.StructFieldMultipleContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_structSemex

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructSemex" ):
                listener.enterStructSemex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructSemex" ):
                listener.exitStructSemex(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructSemex" ):
                return visitor.visitStructSemex(self)
            else:
                return visitor.visitChildren(self)




    def structSemex(self):

        localctx = NeoBasicParser.StructSemexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 324, self.RULE_structSemex)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1815
            self.match(NeoBasicParser.COLON)
            self.state = 1816
            self.structFieldMultiple()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def structMembersBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.StructMembersBlockContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_structSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructSuite" ):
                listener.enterStructSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructSuite" ):
                listener.exitStructSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructSuite" ):
                return visitor.visitStructSuite(self)
            else:
                return visitor.visitChildren(self)




    def structSuite(self):

        localctx = NeoBasicParser.StructSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 326, self.RULE_structSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1818
            self.match(NeoBasicParser.EOS)
            self.state = 1819
            self.match(NeoBasicParser.INDENT)
            self.state = 1820
            self.structMembersBlock()
            self.state = 1821
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructMembersBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def structMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.StructMemberContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.StructMemberContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_structMembersBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructMembersBlock" ):
                listener.enterStructMembersBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructMembersBlock" ):
                listener.exitStructMembersBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructMembersBlock" ):
                return visitor.visitStructMembersBlock(self)
            else:
                return visitor.visitChildren(self)




    def structMembersBlock(self):

        localctx = NeoBasicParser.StructMembersBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 328, self.RULE_structMembersBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1823
            self.structMember()
            self.state = 1828
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==423:
                self.state = 1824
                self.match(NeoBasicParser.EOS)
                self.state = 1825
                self.structMember()
                self.state = 1830
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalInstruction(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionContext,0)


        def structFieldSingle(self):
            return self.getTypedRuleContext(NeoBasicParser.StructFieldSingleContext,0)


        def structFieldMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.StructFieldMultipleContext,0)


        def structMemberEmbedded(self):
            return self.getTypedRuleContext(NeoBasicParser.StructMemberEmbeddedContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_structMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructMember" ):
                listener.enterStructMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructMember" ):
                listener.exitStructMember(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructMember" ):
                return visitor.visitStructMember(self)
            else:
                return visitor.visitChildren(self)




    def structMember(self):

        localctx = NeoBasicParser.StructMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 330, self.RULE_structMember)
        try:
            self.state = 1835
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,122,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1831
                self.logicalInstruction()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1832
                self.structFieldSingle()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1833
                self.structFieldMultiple()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1834
                self.structMemberEmbedded()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructFieldSingleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def inferredDecoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifierContext,0)


        def attributeTag(self):
            return self.getTypedRuleContext(NeoBasicParser.AttributeTagContext,0)


        def EQUAL(self):
            return self.getToken(NeoBasicParser.EQUAL, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_structFieldSingle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructFieldSingle" ):
                listener.enterStructFieldSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructFieldSingle" ):
                listener.exitStructFieldSingle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructFieldSingle" ):
                return visitor.visitStructFieldSingle(self)
            else:
                return visitor.visitChildren(self)




    def structFieldSingle(self):

        localctx = NeoBasicParser.StructFieldSingleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 332, self.RULE_structFieldSingle)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1837
            self.inferredDecoratedIdentifier()
            self.state = 1839
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 395)) & ~0x3f) == 0 and ((1 << (_la - 395)) & 21) != 0):
                self.state = 1838
                self.attributeTag()


            self.state = 1843
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==353:
                self.state = 1841
                self.match(NeoBasicParser.EQUAL)
                self.state = 1842
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttributeTagContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stringLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.StringLiteralContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_attributeTag

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttributeTag" ):
                listener.enterAttributeTag(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttributeTag" ):
                listener.exitAttributeTag(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttributeTag" ):
                return visitor.visitAttributeTag(self)
            else:
                return visitor.visitChildren(self)




    def attributeTag(self):

        localctx = NeoBasicParser.AttributeTagContext(self, self._ctx, self.state)
        self.enterRule(localctx, 334, self.RULE_attributeTag)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1845
            self.stringLiteral()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructFieldMultipleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def structFieldSingle(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.StructFieldSingleContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.StructFieldSingleContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_structFieldMultiple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructFieldMultiple" ):
                listener.enterStructFieldMultiple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructFieldMultiple" ):
                listener.exitStructFieldMultiple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructFieldMultiple" ):
                return visitor.visitStructFieldMultiple(self)
            else:
                return visitor.visitChildren(self)




    def structFieldMultiple(self):

        localctx = NeoBasicParser.StructFieldMultipleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 336, self.RULE_structFieldMultiple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1847
            self.structFieldSingle()
            self.state = 1850 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1848
                self.match(NeoBasicParser.COMMA)
                self.state = 1849
                self.structFieldSingle()
                self.state = 1852 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==439):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructMemberEmbeddedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def decoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DecoratedIdentifierContext,0)


        def STRUCT(self):
            return self.getToken(NeoBasicParser.STRUCT, 0)

        def structSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.StructSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_structMemberEmbedded

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructMemberEmbedded" ):
                listener.enterStructMemberEmbedded(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructMemberEmbedded" ):
                listener.exitStructMemberEmbedded(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructMemberEmbedded" ):
                return visitor.visitStructMemberEmbedded(self)
            else:
                return visitor.visitChildren(self)




    def structMemberEmbedded(self):

        localctx = NeoBasicParser.StructMemberEmbeddedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 338, self.RULE_structMemberEmbedded)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1854
            self.decoratedIdentifier()
            self.state = 1855
            self.match(NeoBasicParser.STRUCT)
            self.state = 1856
            self.structSuite()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProtoSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def protoClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ProtoClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_protoSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProtoSentence" ):
                listener.enterProtoSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProtoSentence" ):
                listener.exitProtoSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProtoSentence" ):
                return visitor.visitProtoSentence(self)
            else:
                return visitor.visitChildren(self)




    def protoSentence(self):

        localctx = NeoBasicParser.ProtoSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 340, self.RULE_protoSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1858
            self.protoClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProtoClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROTO(self):
            return self.getToken(NeoBasicParser.PROTO, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def protoBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProtoBodyContext,0)


        def extendsClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ExtendsClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_protoClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProtoClause" ):
                listener.enterProtoClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProtoClause" ):
                listener.exitProtoClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProtoClause" ):
                return visitor.visitProtoClause(self)
            else:
                return visitor.visitChildren(self)




    def protoClause(self):

        localctx = NeoBasicParser.ProtoClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 342, self.RULE_protoClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1860
            self.match(NeoBasicParser.PROTO)
            self.state = 1861
            self.declarationIdentifier()
            self.state = 1863
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==40:
                self.state = 1862
                self.extendsClause()


            self.state = 1865
            self.protoBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProtoBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_protoBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProtoBody" ):
                listener.enterProtoBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProtoBody" ):
                listener.exitProtoBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProtoBody" ):
                return visitor.visitProtoBody(self)
            else:
                return visitor.visitChildren(self)




    def protoBody(self):

        localctx = NeoBasicParser.ProtoBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 344, self.RULE_protoBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1867
            self.logicalInstructionSuite()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraitSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def traitClause(self):
            return self.getTypedRuleContext(NeoBasicParser.TraitClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_traitSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraitSentence" ):
                listener.enterTraitSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraitSentence" ):
                listener.exitTraitSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraitSentence" ):
                return visitor.visitTraitSentence(self)
            else:
                return visitor.visitChildren(self)




    def traitSentence(self):

        localctx = NeoBasicParser.TraitSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 346, self.RULE_traitSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1869
            self.traitClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraitClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRAIT(self):
            return self.getToken(NeoBasicParser.TRAIT, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def traitBody(self):
            return self.getTypedRuleContext(NeoBasicParser.TraitBodyContext,0)


        def implementsClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ImplementsClauseContext,0)


        def mixesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.MixesClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_traitClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraitClause" ):
                listener.enterTraitClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraitClause" ):
                listener.exitTraitClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraitClause" ):
                return visitor.visitTraitClause(self)
            else:
                return visitor.visitChildren(self)




    def traitClause(self):

        localctx = NeoBasicParser.TraitClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 348, self.RULE_traitClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1871
            self.match(NeoBasicParser.TRAIT)
            self.state = 1872
            self.declarationIdentifier()
            self.state = 1874
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==41:
                self.state = 1873
                self.implementsClause()


            self.state = 1877
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==42:
                self.state = 1876
                self.mixesClause()


            self.state = 1879
            self.traitBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraitBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_traitBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraitBody" ):
                listener.enterTraitBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraitBody" ):
                listener.exitTraitBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraitBody" ):
                return visitor.visitTraitBody(self)
            else:
                return visitor.visitChildren(self)




    def traitBody(self):

        localctx = NeoBasicParser.TraitBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 350, self.RULE_traitBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1881
            self.logicalInstructionSuite()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ClassClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_classSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassSentence" ):
                listener.enterClassSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassSentence" ):
                listener.exitClassSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassSentence" ):
                return visitor.visitClassSentence(self)
            else:
                return visitor.visitChildren(self)




    def classSentence(self):

        localctx = NeoBasicParser.ClassSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 352, self.RULE_classSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1883
            self.classClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CLASS(self):
            return self.getToken(NeoBasicParser.CLASS, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def classBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ClassBodyContext,0)


        def extendsClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ExtendsClauseContext,0)


        def implementsClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ImplementsClauseContext,0)


        def mixesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.MixesClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_classClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassClause" ):
                listener.enterClassClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassClause" ):
                listener.exitClassClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassClause" ):
                return visitor.visitClassClause(self)
            else:
                return visitor.visitChildren(self)




    def classClause(self):

        localctx = NeoBasicParser.ClassClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 354, self.RULE_classClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1885
            self.match(NeoBasicParser.CLASS)
            self.state = 1886
            self.declarationIdentifier()
            self.state = 1888
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==40:
                self.state = 1887
                self.extendsClause()


            self.state = 1891
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==41:
                self.state = 1890
                self.implementsClause()


            self.state = 1894
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==42:
                self.state = 1893
                self.mixesClause()


            self.state = 1896
            self.classBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classSemex(self):
            return self.getTypedRuleContext(NeoBasicParser.ClassSemexContext,0)


        def classSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.ClassSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_classBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassBody" ):
                listener.enterClassBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassBody" ):
                listener.exitClassBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassBody" ):
                return visitor.visitClassBody(self)
            else:
                return visitor.visitChildren(self)




    def classBody(self):

        localctx = NeoBasicParser.ClassBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 356, self.RULE_classBody)
        try:
            self.state = 1900
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [441]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1898
                self.classSemex()
                pass
            elif token in [423]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1899
                self.classSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassSemexContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def classFieldMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.ClassFieldMultipleContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_classSemex

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassSemex" ):
                listener.enterClassSemex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassSemex" ):
                listener.exitClassSemex(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassSemex" ):
                return visitor.visitClassSemex(self)
            else:
                return visitor.visitChildren(self)




    def classSemex(self):

        localctx = NeoBasicParser.ClassSemexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 358, self.RULE_classSemex)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1902
            self.match(NeoBasicParser.COLON)
            self.state = 1903
            self.classFieldMultiple()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassFieldMultipleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classFieldSimple(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ClassFieldSimpleContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ClassFieldSimpleContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_classFieldMultiple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassFieldMultiple" ):
                listener.enterClassFieldMultiple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassFieldMultiple" ):
                listener.exitClassFieldMultiple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassFieldMultiple" ):
                return visitor.visitClassFieldMultiple(self)
            else:
                return visitor.visitChildren(self)




    def classFieldMultiple(self):

        localctx = NeoBasicParser.ClassFieldMultipleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 360, self.RULE_classFieldMultiple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1905
            self.classFieldSimple()
            self.state = 1910
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==439:
                self.state = 1906
                self.match(NeoBasicParser.COMMA)
                self.state = 1907
                self.classFieldSimple()
                self.state = 1912
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassFieldSimpleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def inferredDecoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifierContext,0)


        def attributeTag(self):
            return self.getTypedRuleContext(NeoBasicParser.AttributeTagContext,0)


        def EQUAL(self):
            return self.getToken(NeoBasicParser.EQUAL, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_classFieldSimple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassFieldSimple" ):
                listener.enterClassFieldSimple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassFieldSimple" ):
                listener.exitClassFieldSimple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassFieldSimple" ):
                return visitor.visitClassFieldSimple(self)
            else:
                return visitor.visitChildren(self)




    def classFieldSimple(self):

        localctx = NeoBasicParser.ClassFieldSimpleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 362, self.RULE_classFieldSimple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1913
            self.inferredDecoratedIdentifier()
            self.state = 1915
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 395)) & ~0x3f) == 0 and ((1 << (_la - 395)) & 21) != 0):
                self.state = 1914
                self.attributeTag()


            self.state = 1919
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==353:
                self.state = 1917
                self.match(NeoBasicParser.EQUAL)
                self.state = 1918
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_classSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassSuite" ):
                listener.enterClassSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassSuite" ):
                listener.exitClassSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassSuite" ):
                return visitor.visitClassSuite(self)
            else:
                return visitor.visitChildren(self)




    def classSuite(self):

        localctx = NeoBasicParser.ClassSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 364, self.RULE_classSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1921
            self.logicalInstructionSuite()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def objectClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ObjectClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_objectSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectSentence" ):
                listener.enterObjectSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectSentence" ):
                listener.exitObjectSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectSentence" ):
                return visitor.visitObjectSentence(self)
            else:
                return visitor.visitChildren(self)




    def objectSentence(self):

        localctx = NeoBasicParser.ObjectSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 366, self.RULE_objectSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1923
            self.objectClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OBJECT(self):
            return self.getToken(NeoBasicParser.OBJECT, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def objectBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ObjectBodyContext,0)


        def extendsClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ExtendsClauseContext,0)


        def implementsClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ImplementsClauseContext,0)


        def mixesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.MixesClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_objectClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectClause" ):
                listener.enterObjectClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectClause" ):
                listener.exitObjectClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectClause" ):
                return visitor.visitObjectClause(self)
            else:
                return visitor.visitChildren(self)




    def objectClause(self):

        localctx = NeoBasicParser.ObjectClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 368, self.RULE_objectClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1925
            self.match(NeoBasicParser.OBJECT)
            self.state = 1926
            self.declarationIdentifier()
            self.state = 1928
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==40:
                self.state = 1927
                self.extendsClause()


            self.state = 1931
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==41:
                self.state = 1930
                self.implementsClause()


            self.state = 1934
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==42:
                self.state = 1933
                self.mixesClause()


            self.state = 1936
            self.objectBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_objectBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectBody" ):
                listener.enterObjectBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectBody" ):
                listener.exitObjectBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectBody" ):
                return visitor.visitObjectBody(self)
            else:
                return visitor.visitChildren(self)




    def objectBody(self):

        localctx = NeoBasicParser.ObjectBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 370, self.RULE_objectBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1938
            self.logicalInstructionSuite()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InnerDeclareSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constructSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.ConstructSentenceContext,0)


        def destructSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.DestructSentenceContext,0)


        def propertySentence(self):
            return self.getTypedRuleContext(NeoBasicParser.PropertySentenceContext,0)


        def propertyAccessorSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.PropertyAccessorSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_innerDeclareSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInnerDeclareSentence" ):
                listener.enterInnerDeclareSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInnerDeclareSentence" ):
                listener.exitInnerDeclareSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInnerDeclareSentence" ):
                return visitor.visitInnerDeclareSentence(self)
            else:
                return visitor.visitChildren(self)




    def innerDeclareSentence(self):

        localctx = NeoBasicParser.InnerDeclareSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 372, self.RULE_innerDeclareSentence)
        try:
            self.state = 1944
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [43]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1940
                self.constructSentence()
                pass
            elif token in [44]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1941
                self.destructSentence()
                pass
            elif token in [45]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1942
                self.propertySentence()
                pass
            elif token in [46, 47]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1943
                self.propertyAccessorSentence()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstructSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constructClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ConstructClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_constructSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstructSentence" ):
                listener.enterConstructSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstructSentence" ):
                listener.exitConstructSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstructSentence" ):
                return visitor.visitConstructSentence(self)
            else:
                return visitor.visitChildren(self)




    def constructSentence(self):

        localctx = NeoBasicParser.ConstructSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 374, self.RULE_constructSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1946
            self.constructClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstructClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONSTRUCT(self):
            return self.getToken(NeoBasicParser.CONSTRUCT, 0)

        def parenthesizedParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParametersContext,0)


        def procBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcBodyContext,0)


        def classInitializer(self):
            return self.getTypedRuleContext(NeoBasicParser.ClassInitializerContext,0)


        def raisesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.RaisesClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_constructClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstructClause" ):
                listener.enterConstructClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstructClause" ):
                listener.exitConstructClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstructClause" ):
                return visitor.visitConstructClause(self)
            else:
                return visitor.visitChildren(self)




    def constructClause(self):

        localctx = NeoBasicParser.ConstructClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 376, self.RULE_constructClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1948
            self.match(NeoBasicParser.CONSTRUCT)
            self.state = 1949
            self.parenthesizedParameters()
            self.state = 1951
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==436:
                self.state = 1950
                self.classInitializer()


            self.state = 1954
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==27 or _la==28:
                self.state = 1953
                self.raisesClause()


            self.state = 1956
            self.procBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassInitializerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_CURLY(self):
            return self.getToken(NeoBasicParser.LEFT_CURLY, 0)

        def classInitializingMembers(self):
            return self.getTypedRuleContext(NeoBasicParser.ClassInitializingMembersContext,0)


        def RIGHT_CURLY(self):
            return self.getToken(NeoBasicParser.RIGHT_CURLY, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_classInitializer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassInitializer" ):
                listener.enterClassInitializer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassInitializer" ):
                listener.exitClassInitializer(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassInitializer" ):
                return visitor.visitClassInitializer(self)
            else:
                return visitor.visitChildren(self)




    def classInitializer(self):

        localctx = NeoBasicParser.ClassInitializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 378, self.RULE_classInitializer)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1958
            self.match(NeoBasicParser.LEFT_CURLY)
            self.state = 1959
            self.classInitializingMembers()
            self.state = 1960
            self.match(NeoBasicParser.RIGHT_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassInitializingMembersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classInitializingMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ClassInitializingMemberContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ClassInitializingMemberContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_classInitializingMembers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassInitializingMembers" ):
                listener.enterClassInitializingMembers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassInitializingMembers" ):
                listener.exitClassInitializingMembers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassInitializingMembers" ):
                return visitor.visitClassInitializingMembers(self)
            else:
                return visitor.visitChildren(self)




    def classInitializingMembers(self):

        localctx = NeoBasicParser.ClassInitializingMembersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 380, self.RULE_classInitializingMembers)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1962
            self.classInitializingMember()
            self.state = 1967
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==439:
                self.state = 1963
                self.match(NeoBasicParser.COMMA)
                self.state = 1964
                self.classInitializingMember()
                self.state = 1969
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassInitializingMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_classInitializingMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassInitializingMember" ):
                listener.enterClassInitializingMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassInitializingMember" ):
                listener.exitClassInitializingMember(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassInitializingMember" ):
                return visitor.visitClassInitializingMember(self)
            else:
                return visitor.visitChildren(self)




    def classInitializingMember(self):

        localctx = NeoBasicParser.ClassInitializingMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 382, self.RULE_classInitializingMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1973
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,143,self._ctx)
            if la_ == 1:
                self.state = 1970
                self.qualifiedIdentifier()
                self.state = 1971
                self.match(NeoBasicParser.COLON)


            self.state = 1975
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DestructSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def destructClause(self):
            return self.getTypedRuleContext(NeoBasicParser.DestructClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_destructSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDestructSentence" ):
                listener.enterDestructSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDestructSentence" ):
                listener.exitDestructSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDestructSentence" ):
                return visitor.visitDestructSentence(self)
            else:
                return visitor.visitChildren(self)




    def destructSentence(self):

        localctx = NeoBasicParser.DestructSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 384, self.RULE_destructSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1977
            self.destructClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DestructClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DESTRUCT(self):
            return self.getToken(NeoBasicParser.DESTRUCT, 0)

        def procBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcBodyContext,0)


        def parenthesizedParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParametersContext,0)


        def raisesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.RaisesClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_destructClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDestructClause" ):
                listener.enterDestructClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDestructClause" ):
                listener.exitDestructClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDestructClause" ):
                return visitor.visitDestructClause(self)
            else:
                return visitor.visitChildren(self)




    def destructClause(self):

        localctx = NeoBasicParser.DestructClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 386, self.RULE_destructClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1979
            self.match(NeoBasicParser.DESTRUCT)
            self.state = 1981
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==432:
                self.state = 1980
                self.parenthesizedParameters()


            self.state = 1984
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==27 or _la==28:
                self.state = 1983
                self.raisesClause()


            self.state = 1986
            self.procBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertySentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def propertyClause(self):
            return self.getTypedRuleContext(NeoBasicParser.PropertyClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_propertySentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertySentence" ):
                listener.enterPropertySentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertySentence" ):
                listener.exitPropertySentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropertySentence" ):
                return visitor.visitPropertySentence(self)
            else:
                return visitor.visitChildren(self)




    def propertySentence(self):

        localctx = NeoBasicParser.PropertySentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 388, self.RULE_propertySentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1988
            self.propertyClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertyClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROPERTY(self):
            return self.getToken(NeoBasicParser.PROPERTY, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def propertyBody(self):
            return self.getTypedRuleContext(NeoBasicParser.PropertyBodyContext,0)


        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def attributeTag(self):
            return self.getTypedRuleContext(NeoBasicParser.AttributeTagContext,0)


        def EQUAL(self):
            return self.getToken(NeoBasicParser.EQUAL, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_propertyClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyClause" ):
                listener.enterPropertyClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyClause" ):
                listener.exitPropertyClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropertyClause" ):
                return visitor.visitPropertyClause(self)
            else:
                return visitor.visitChildren(self)




    def propertyClause(self):

        localctx = NeoBasicParser.PropertyClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 390, self.RULE_propertyClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1990
            self.match(NeoBasicParser.PROPERTY)
            self.state = 1991
            self.declarationIdentifier()
            self.state = 1993
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 247385886433392) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & -1) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & 16777215) != 0) or ((((_la - 259)) & ~0x3f) == 0 and ((1 << (_la - 259)) & 585) != 0) or _la==381 or _la==434:
                self.state = 1992
                self.type_(0)


            self.state = 1996
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 395)) & ~0x3f) == 0 and ((1 << (_la - 395)) & 21) != 0):
                self.state = 1995
                self.attributeTag()


            self.state = 2000
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==353:
                self.state = 1998
                self.match(NeoBasicParser.EQUAL)
                self.state = 1999
                self.expression(0)


            self.state = 2002
            self.propertyBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertyBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_propertyBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyBody" ):
                listener.enterPropertyBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyBody" ):
                listener.exitPropertyBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropertyBody" ):
                return visitor.visitPropertyBody(self)
            else:
                return visitor.visitChildren(self)




    def propertyBody(self):

        localctx = NeoBasicParser.PropertyBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 392, self.RULE_propertyBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2004
            self.logicalInstructionSuite()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertyAccessorSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def propertyGetterClause(self):
            return self.getTypedRuleContext(NeoBasicParser.PropertyGetterClauseContext,0)


        def propertySetterClause(self):
            return self.getTypedRuleContext(NeoBasicParser.PropertySetterClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_propertyAccessorSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyAccessorSentence" ):
                listener.enterPropertyAccessorSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyAccessorSentence" ):
                listener.exitPropertyAccessorSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropertyAccessorSentence" ):
                return visitor.visitPropertyAccessorSentence(self)
            else:
                return visitor.visitChildren(self)




    def propertyAccessorSentence(self):

        localctx = NeoBasicParser.PropertyAccessorSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 394, self.RULE_propertyAccessorSentence)
        try:
            self.state = 2008
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [46]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2006
                self.propertyGetterClause()
                pass
            elif token in [47]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2007
                self.propertySetterClause()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertyGetterClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GETTER(self):
            return self.getToken(NeoBasicParser.GETTER, 0)

        def procBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcBodyContext,0)


        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def parenthesizedParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParametersContext,0)


        def raisesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.RaisesClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_propertyGetterClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyGetterClause" ):
                listener.enterPropertyGetterClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyGetterClause" ):
                listener.exitPropertyGetterClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropertyGetterClause" ):
                return visitor.visitPropertyGetterClause(self)
            else:
                return visitor.visitChildren(self)




    def propertyGetterClause(self):

        localctx = NeoBasicParser.PropertyGetterClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 396, self.RULE_propertyGetterClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2010
            self.match(NeoBasicParser.GETTER)
            self.state = 2012
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 381)) & ~0x3f) == 0 and ((1 << (_la - 381)) & 7) != 0):
                self.state = 2011
                self.declarationIdentifier()


            self.state = 2015
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==432:
                self.state = 2014
                self.parenthesizedParameters()


            self.state = 2018
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==27 or _la==28:
                self.state = 2017
                self.raisesClause()


            self.state = 2020
            self.procBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertySetterClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SETTER(self):
            return self.getToken(NeoBasicParser.SETTER, 0)

        def procBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcBodyContext,0)


        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def parenthesizedParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParametersContext,0)


        def raisesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.RaisesClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_propertySetterClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertySetterClause" ):
                listener.enterPropertySetterClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertySetterClause" ):
                listener.exitPropertySetterClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropertySetterClause" ):
                return visitor.visitPropertySetterClause(self)
            else:
                return visitor.visitChildren(self)




    def propertySetterClause(self):

        localctx = NeoBasicParser.PropertySetterClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 398, self.RULE_propertySetterClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2022
            self.match(NeoBasicParser.SETTER)
            self.state = 2024
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 381)) & ~0x3f) == 0 and ((1 << (_la - 381)) & 7) != 0):
                self.state = 2023
                self.declarationIdentifier()


            self.state = 2027
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==432:
                self.state = 2026
                self.parenthesizedParameters()


            self.state = 2030
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==27 or _la==28:
                self.state = 2029
                self.raisesClause()


            self.state = 2032
            self.procBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def labelIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.LabelIdentifierContext,0)


        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def statementSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementSentenceContext,0)


        def simpleStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.SimpleStatementContext,0)


        def compoundStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.CompoundStatementContext,0)


        def testingStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.TestingStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_statementSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatementSentence" ):
                listener.enterStatementSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatementSentence" ):
                listener.exitStatementSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatementSentence" ):
                return visitor.visitStatementSentence(self)
            else:
                return visitor.visitChildren(self)




    def statementSentence(self):

        localctx = NeoBasicParser.StatementSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 400, self.RULE_statementSentence)
        try:
            self.state = 2044
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,156,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2034
                self.labelIdentifier()
                self.state = 2035
                self.match(NeoBasicParser.COLON)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2037
                self.labelIdentifier()
                self.state = 2038
                self.match(NeoBasicParser.COLON)
                self.state = 2039
                self.statementSentence()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2041
                self.simpleStatement(0)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2042
                self.compoundStatement()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2043
                self.testingStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def statementBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementBlockContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_statementSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatementSuite" ):
                listener.enterStatementSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatementSuite" ):
                listener.exitStatementSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatementSuite" ):
                return visitor.visitStatementSuite(self)
            else:
                return visitor.visitChildren(self)




    def statementSuite(self):

        localctx = NeoBasicParser.StatementSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 402, self.RULE_statementSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2046
            self.match(NeoBasicParser.EOS)
            self.state = 2047
            self.match(NeoBasicParser.INDENT)
            self.state = 2048
            self.statementBlock()
            self.state = 2049
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statementSentence(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.StatementSentenceContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.StatementSentenceContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_statementBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatementBlock" ):
                listener.enterStatementBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatementBlock" ):
                listener.exitStatementBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatementBlock" ):
                return visitor.visitStatementBlock(self)
            else:
                return visitor.visitChildren(self)




    def statementBlock(self):

        localctx = NeoBasicParser.StatementBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 404, self.RULE_statementBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2051
            self.statementSentence()
            self.state = 2056
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==423:
                self.state = 2052
                self.match(NeoBasicParser.EOS)
                self.state = 2053
                self.statementSentence()
                self.state = 2058
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClauseStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IMPLICIT_RETURN(self):
            return self.getToken(NeoBasicParser.IMPLICIT_RETURN, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def DO(self):
            return self.getToken(NeoBasicParser.DO, 0)

        def simpleStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.SimpleStatementContext,0)


        def statementSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_clauseStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClauseStatement" ):
                listener.enterClauseStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClauseStatement" ):
                listener.exitClauseStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClauseStatement" ):
                return visitor.visitClauseStatement(self)
            else:
                return visitor.visitChildren(self)




    def clauseStatement(self):

        localctx = NeoBasicParser.ClauseStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 406, self.RULE_clauseStatement)
        try:
            self.state = 2064
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [340]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2059
                self.match(NeoBasicParser.IMPLICIT_RETURN)
                self.state = 2060
                self.expression(0)
                pass
            elif token in [62]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2061
                self.match(NeoBasicParser.DO)
                self.state = 2062
                self.simpleStatement(0)
                pass
            elif token in [423]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2063
                self.statementSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignmentStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.AssignmentStatementContext,0)


        def consoleStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ConsoleStatementContext,0)


        def deterministicStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.DeterministicStatementContext,0)


        def nondeterministicStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.NondeterministicStatementContext,0)


        def expressionStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionStatementContext,0)


        def emptyStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.EmptyStatementContext,0)


        def simpleStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.SimpleStatementContext,0)


        def executionFlowOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.ExecutionFlowOperatorContext,0)


        def statementSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementSentenceContext,0)


        def OTHERWISE(self):
            return self.getToken(NeoBasicParser.OTHERWISE, 0)

        def UNLESS(self):
            return self.getToken(NeoBasicParser.UNLESS, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def TILL(self):
            return self.getToken(NeoBasicParser.TILL, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_simpleStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleStatement" ):
                listener.enterSimpleStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleStatement" ):
                listener.exitSimpleStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleStatement" ):
                return visitor.visitSimpleStatement(self)
            else:
                return visitor.visitChildren(self)



    def simpleStatement(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = NeoBasicParser.SimpleStatementContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 408
        self.enterRecursionRule(localctx, 408, self.RULE_simpleStatement, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2073
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,159,self._ctx)
            if la_ == 1:
                self.state = 2067
                self.assignmentStatement()
                pass

            elif la_ == 2:
                self.state = 2068
                self.consoleStatement()
                pass

            elif la_ == 3:
                self.state = 2069
                self.deterministicStatement()
                pass

            elif la_ == 4:
                self.state = 2070
                self.nondeterministicStatement()
                pass

            elif la_ == 5:
                self.state = 2071
                self.expressionStatement()
                pass

            elif la_ == 6:
                self.state = 2072
                self.emptyStatement()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 2090
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,161,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 2088
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,160,self._ctx)
                    if la_ == 1:
                        localctx = NeoBasicParser.SimpleStatementContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_simpleStatement)
                        self.state = 2075
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 2076
                        self.executionFlowOperator()
                        self.state = 2077
                        self.statementSentence()
                        pass

                    elif la_ == 2:
                        localctx = NeoBasicParser.SimpleStatementContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_simpleStatement)
                        self.state = 2079
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 2080
                        self.match(NeoBasicParser.OTHERWISE)
                        self.state = 2081
                        self.statementSentence()
                        pass

                    elif la_ == 3:
                        localctx = NeoBasicParser.SimpleStatementContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_simpleStatement)
                        self.state = 2082
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 2083
                        self.match(NeoBasicParser.UNLESS)
                        self.state = 2084
                        self.expression(0)
                        pass

                    elif la_ == 4:
                        localctx = NeoBasicParser.SimpleStatementContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_simpleStatement)
                        self.state = 2085
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 2086
                        self.match(NeoBasicParser.TILL)
                        self.state = 2087
                        self.expression(0)
                        pass

             
                self.state = 2092
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,161,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ExpressionStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_expressionStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionStatement" ):
                listener.enterExpressionStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionStatement" ):
                listener.exitExpressionStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressionStatement" ):
                return visitor.visitExpressionStatement(self)
            else:
                return visitor.visitChildren(self)




    def expressionStatement(self):

        localctx = NeoBasicParser.ExpressionStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 410, self.RULE_expressionStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2093
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EmptyStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELLIPSIS(self):
            return self.getToken(NeoBasicParser.ELLIPSIS, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_emptyStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEmptyStatement" ):
                listener.enterEmptyStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEmptyStatement" ):
                listener.exitEmptyStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEmptyStatement" ):
                return visitor.visitEmptyStatement(self)
            else:
                return visitor.visitChildren(self)




    def emptyStatement(self):

        localctx = NeoBasicParser.EmptyStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 412, self.RULE_emptyStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2095
            self.match(NeoBasicParser.ELLIPSIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LET(self):
            return self.getToken(NeoBasicParser.LET, 0)

        def assignmentStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.AssignmentStatementContext,0)


        def assignmentSingle(self):
            return self.getTypedRuleContext(NeoBasicParser.AssignmentSingleContext,0)


        def assignmentMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.AssignmentMultipleContext,0)


        def assignmentParallel(self):
            return self.getTypedRuleContext(NeoBasicParser.AssignmentParallelContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_assignmentStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentStatement" ):
                listener.enterAssignmentStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentStatement" ):
                listener.exitAssignmentStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignmentStatement" ):
                return visitor.visitAssignmentStatement(self)
            else:
                return visitor.visitChildren(self)




    def assignmentStatement(self):

        localctx = NeoBasicParser.AssignmentStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 414, self.RULE_assignmentStatement)
        try:
            self.state = 2102
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,162,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2097
                self.match(NeoBasicParser.LET)
                self.state = 2098
                self.assignmentStatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2099
                self.assignmentSingle()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2100
                self.assignmentMultiple()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2101
                self.assignmentParallel()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentSingleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primaryExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.PrimaryExpressionContext,0)


        def singleAssignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.SingleAssignmentOperatorContext,0)


        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_assignmentSingle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentSingle" ):
                listener.enterAssignmentSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentSingle" ):
                listener.exitAssignmentSingle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignmentSingle" ):
                return visitor.visitAssignmentSingle(self)
            else:
                return visitor.visitChildren(self)




    def assignmentSingle(self):

        localctx = NeoBasicParser.AssignmentSingleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 416, self.RULE_assignmentSingle)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2104
            self.primaryExpression(0)
            self.state = 2105
            self.singleAssignmentOperator()
            self.state = 2106
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentMultipleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignmentSingle(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.AssignmentSingleContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.AssignmentSingleContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_assignmentMultiple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentMultiple" ):
                listener.enterAssignmentMultiple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentMultiple" ):
                listener.exitAssignmentMultiple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignmentMultiple" ):
                return visitor.visitAssignmentMultiple(self)
            else:
                return visitor.visitChildren(self)




    def assignmentMultiple(self):

        localctx = NeoBasicParser.AssignmentMultipleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 418, self.RULE_assignmentMultiple)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2108
            self.assignmentSingle()
            self.state = 2111 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 2109
                    self.match(NeoBasicParser.COMMA)
                    self.state = 2110
                    self.assignmentSingle()

                else:
                    raise NoViableAltException(self)
                self.state = 2113 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,163,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentParallelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primaryExpressions(self):
            return self.getTypedRuleContext(NeoBasicParser.PrimaryExpressionsContext,0)


        def unpackingAssignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnpackingAssignmentOperatorContext,0)


        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_assignmentParallel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentParallel" ):
                listener.enterAssignmentParallel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentParallel" ):
                listener.exitAssignmentParallel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignmentParallel" ):
                return visitor.visitAssignmentParallel(self)
            else:
                return visitor.visitChildren(self)




    def assignmentParallel(self):

        localctx = NeoBasicParser.AssignmentParallelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 420, self.RULE_assignmentParallel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2115
            self.primaryExpressions()
            self.state = 2116
            self.unpackingAssignmentOperator()
            self.state = 2117
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConsoleStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atClause(self):
            return self.getTypedRuleContext(NeoBasicParser.AtClauseContext,0)


        def consoleStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ConsoleStatementContext,0)


        def echoCommand(self):
            return self.getTypedRuleContext(NeoBasicParser.EchoCommandContext,0)


        def scanCommand(self):
            return self.getTypedRuleContext(NeoBasicParser.ScanCommandContext,0)


        def alertCommand(self):
            return self.getTypedRuleContext(NeoBasicParser.AlertCommandContext,0)


        def entryCommand(self):
            return self.getTypedRuleContext(NeoBasicParser.EntryCommandContext,0)


        def playCommand(self):
            return self.getTypedRuleContext(NeoBasicParser.PlayCommandContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_consoleStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConsoleStatement" ):
                listener.enterConsoleStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConsoleStatement" ):
                listener.exitConsoleStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConsoleStatement" ):
                return visitor.visitConsoleStatement(self)
            else:
                return visitor.visitChildren(self)




    def consoleStatement(self):

        localctx = NeoBasicParser.ConsoleStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 422, self.RULE_consoleStatement)
        try:
            self.state = 2127
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [87]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2119
                self.atClause()
                self.state = 2120
                self.consoleStatement()
                pass
            elif token in [89]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2122
                self.echoCommand()
                pass
            elif token in [88]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2123
                self.scanCommand()
                pass
            elif token in [90]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2124
                self.alertCommand()
                pass
            elif token in [91]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2125
                self.entryCommand()
                pass
            elif token in [92]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2126
                self.playCommand()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AtClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AT(self):
            return self.getToken(NeoBasicParser.AT, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_atClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtClause" ):
                listener.enterAtClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtClause" ):
                listener.exitAtClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtClause" ):
                return visitor.visitAtClause(self)
            else:
                return visitor.visitChildren(self)




    def atClause(self):

        localctx = NeoBasicParser.AtClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 424, self.RULE_atClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2129
            self.match(NeoBasicParser.AT)
            self.state = 2130
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EchoCommandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ECHO(self):
            return self.getToken(NeoBasicParser.ECHO, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def COMMA(self):
            return self.getToken(NeoBasicParser.COMMA, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_echoCommand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEchoCommand" ):
                listener.enterEchoCommand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEchoCommand" ):
                listener.exitEchoCommand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEchoCommand" ):
                return visitor.visitEchoCommand(self)
            else:
                return visitor.visitChildren(self)




    def echoCommand(self):

        localctx = NeoBasicParser.EchoCommandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 426, self.RULE_echoCommand)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2132
            self.match(NeoBasicParser.ECHO)
            self.state = 2134
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,165,self._ctx)
            if la_ == 1:
                self.state = 2133
                self.expressions()


            self.state = 2137
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,166,self._ctx)
            if la_ == 1:
                self.state = 2136
                self.match(NeoBasicParser.COMMA)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScanCommandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SCAN(self):
            return self.getToken(NeoBasicParser.SCAN, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def COMMA(self):
            return self.getToken(NeoBasicParser.COMMA, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_scanCommand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScanCommand" ):
                listener.enterScanCommand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScanCommand" ):
                listener.exitScanCommand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitScanCommand" ):
                return visitor.visitScanCommand(self)
            else:
                return visitor.visitChildren(self)




    def scanCommand(self):

        localctx = NeoBasicParser.ScanCommandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 428, self.RULE_scanCommand)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2139
            self.match(NeoBasicParser.SCAN)
            self.state = 2141
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,167,self._ctx)
            if la_ == 1:
                self.state = 2140
                self.expressions()


            self.state = 2144
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,168,self._ctx)
            if la_ == 1:
                self.state = 2143
                self.match(NeoBasicParser.COMMA)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlertCommandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALERT(self):
            return self.getToken(NeoBasicParser.ALERT, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_alertCommand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlertCommand" ):
                listener.enterAlertCommand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlertCommand" ):
                listener.exitAlertCommand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlertCommand" ):
                return visitor.visitAlertCommand(self)
            else:
                return visitor.visitChildren(self)




    def alertCommand(self):

        localctx = NeoBasicParser.AlertCommandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 430, self.RULE_alertCommand)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2146
            self.match(NeoBasicParser.ALERT)
            self.state = 2148
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,169,self._ctx)
            if la_ == 1:
                self.state = 2147
                self.expressions()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EntryCommandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENTRY(self):
            return self.getToken(NeoBasicParser.ENTRY, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_entryCommand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntryCommand" ):
                listener.enterEntryCommand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntryCommand" ):
                listener.exitEntryCommand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEntryCommand" ):
                return visitor.visitEntryCommand(self)
            else:
                return visitor.visitChildren(self)




    def entryCommand(self):

        localctx = NeoBasicParser.EntryCommandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 432, self.RULE_entryCommand)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2150
            self.match(NeoBasicParser.ENTRY)
            self.state = 2152
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,170,self._ctx)
            if la_ == 1:
                self.state = 2151
                self.expressions()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PlayCommandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLAY(self):
            return self.getToken(NeoBasicParser.PLAY, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_playCommand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlayCommand" ):
                listener.enterPlayCommand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlayCommand" ):
                listener.exitPlayCommand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPlayCommand" ):
                return visitor.visitPlayCommand(self)
            else:
                return visitor.visitChildren(self)




    def playCommand(self):

        localctx = NeoBasicParser.PlayCommandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 434, self.RULE_playCommand)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2154
            self.match(NeoBasicParser.PLAY)
            self.state = 2155
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeterministicStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def continueSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.ContinueSentenceContext,0)


        def breakSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.BreakSentenceContext,0)


        def fallthroughSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.FallthroughSentenceContext,0)


        def deferSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.DeferSentenceContext,0)


        def returnSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.ReturnSentenceContext,0)


        def yieldSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.YieldSentenceContext,0)


        def raiseSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.RaiseSentenceContext,0)


        def panicSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.PanicSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_deterministicStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeterministicStatement" ):
                listener.enterDeterministicStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeterministicStatement" ):
                listener.exitDeterministicStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeterministicStatement" ):
                return visitor.visitDeterministicStatement(self)
            else:
                return visitor.visitChildren(self)




    def deterministicStatement(self):

        localctx = NeoBasicParser.DeterministicStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 436, self.RULE_deterministicStatement)
        try:
            self.state = 2165
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [71]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2157
                self.continueSentence()
                pass
            elif token in [72]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2158
                self.breakSentence()
                pass
            elif token in [54]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2159
                self.fallthroughSentence()
                pass
            elif token in [60]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2160
                self.deferSentence()
                pass
            elif token in [73]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2161
                self.returnSentence()
                pass
            elif token in [74]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2162
                self.yieldSentence()
                pass
            elif token in [75]:
                self.enterOuterAlt(localctx, 7)
                self.state = 2163
                self.raiseSentence()
                pass
            elif token in [76]:
                self.enterOuterAlt(localctx, 8)
                self.state = 2164
                self.panicSentence()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContinueSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONTINUE(self):
            return self.getToken(NeoBasicParser.CONTINUE, 0)

        def labelIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.LabelIdentifierContext,0)


        def INTEGER_LIT(self):
            return self.getToken(NeoBasicParser.INTEGER_LIT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_continueSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContinueSentence" ):
                listener.enterContinueSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContinueSentence" ):
                listener.exitContinueSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitContinueSentence" ):
                return visitor.visitContinueSentence(self)
            else:
                return visitor.visitChildren(self)




    def continueSentence(self):

        localctx = NeoBasicParser.ContinueSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 438, self.RULE_continueSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2167
            self.match(NeoBasicParser.CONTINUE)
            self.state = 2170
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,172,self._ctx)
            if la_ == 1:
                self.state = 2168
                self.labelIdentifier()

            elif la_ == 2:
                self.state = 2169
                self.match(NeoBasicParser.INTEGER_LIT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BreakSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BREAK(self):
            return self.getToken(NeoBasicParser.BREAK, 0)

        def labelIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.LabelIdentifierContext,0)


        def INTEGER_LIT(self):
            return self.getToken(NeoBasicParser.INTEGER_LIT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_breakSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBreakSentence" ):
                listener.enterBreakSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBreakSentence" ):
                listener.exitBreakSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBreakSentence" ):
                return visitor.visitBreakSentence(self)
            else:
                return visitor.visitChildren(self)




    def breakSentence(self):

        localctx = NeoBasicParser.BreakSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 440, self.RULE_breakSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2172
            self.match(NeoBasicParser.BREAK)
            self.state = 2175
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,173,self._ctx)
            if la_ == 1:
                self.state = 2173
                self.labelIdentifier()

            elif la_ == 2:
                self.state = 2174
                self.match(NeoBasicParser.INTEGER_LIT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FallthroughSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FALLTHROUGH(self):
            return self.getToken(NeoBasicParser.FALLTHROUGH, 0)

        def labelIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.LabelIdentifierContext,0)


        def INTEGER_LIT(self):
            return self.getToken(NeoBasicParser.INTEGER_LIT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_fallthroughSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFallthroughSentence" ):
                listener.enterFallthroughSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFallthroughSentence" ):
                listener.exitFallthroughSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFallthroughSentence" ):
                return visitor.visitFallthroughSentence(self)
            else:
                return visitor.visitChildren(self)




    def fallthroughSentence(self):

        localctx = NeoBasicParser.FallthroughSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 442, self.RULE_fallthroughSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2177
            self.match(NeoBasicParser.FALLTHROUGH)
            self.state = 2180
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,174,self._ctx)
            if la_ == 1:
                self.state = 2178
                self.labelIdentifier()

            elif la_ == 2:
                self.state = 2179
                self.match(NeoBasicParser.INTEGER_LIT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeferSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFER(self):
            return self.getToken(NeoBasicParser.DEFER, 0)

        def statementSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_deferSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeferSentence" ):
                listener.enterDeferSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeferSentence" ):
                listener.exitDeferSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeferSentence" ):
                return visitor.visitDeferSentence(self)
            else:
                return visitor.visitChildren(self)




    def deferSentence(self):

        localctx = NeoBasicParser.DeferSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 444, self.RULE_deferSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2182
            self.match(NeoBasicParser.DEFER)
            self.state = 2183
            self.statementSentence()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(NeoBasicParser.RETURN, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_returnSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnSentence" ):
                listener.enterReturnSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnSentence" ):
                listener.exitReturnSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnSentence" ):
                return visitor.visitReturnSentence(self)
            else:
                return visitor.visitChildren(self)




    def returnSentence(self):

        localctx = NeoBasicParser.ReturnSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 446, self.RULE_returnSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2185
            self.match(NeoBasicParser.RETURN)
            self.state = 2187
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,175,self._ctx)
            if la_ == 1:
                self.state = 2186
                self.expressions()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YieldSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def YIELD(self):
            return self.getToken(NeoBasicParser.YIELD, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_yieldSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterYieldSentence" ):
                listener.enterYieldSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitYieldSentence" ):
                listener.exitYieldSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYieldSentence" ):
                return visitor.visitYieldSentence(self)
            else:
                return visitor.visitChildren(self)




    def yieldSentence(self):

        localctx = NeoBasicParser.YieldSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 448, self.RULE_yieldSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2189
            self.match(NeoBasicParser.YIELD)
            self.state = 2190
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RaiseSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RAISE(self):
            return self.getToken(NeoBasicParser.RAISE, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_raiseSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRaiseSentence" ):
                listener.enterRaiseSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRaiseSentence" ):
                listener.exitRaiseSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRaiseSentence" ):
                return visitor.visitRaiseSentence(self)
            else:
                return visitor.visitChildren(self)




    def raiseSentence(self):

        localctx = NeoBasicParser.RaiseSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 450, self.RULE_raiseSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2192
            self.match(NeoBasicParser.RAISE)
            self.state = 2193
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PanicSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PANIC(self):
            return self.getToken(NeoBasicParser.PANIC, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_panicSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPanicSentence" ):
                listener.enterPanicSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPanicSentence" ):
                listener.exitPanicSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPanicSentence" ):
                return visitor.visitPanicSentence(self)
            else:
                return visitor.visitChildren(self)




    def panicSentence(self):

        localctx = NeoBasicParser.PanicSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 452, self.RULE_panicSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2195
            self.match(NeoBasicParser.PANIC)
            self.state = 2196
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NondeterministicStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ifThenSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.IfThenSentenceContext,0)


        def goSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.GoSentenceContext,0)


        def awaitSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.AwaitSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_nondeterministicStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNondeterministicStatement" ):
                listener.enterNondeterministicStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNondeterministicStatement" ):
                listener.exitNondeterministicStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNondeterministicStatement" ):
                return visitor.visitNondeterministicStatement(self)
            else:
                return visitor.visitChildren(self)




    def nondeterministicStatement(self):

        localctx = NeoBasicParser.NondeterministicStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 454, self.RULE_nondeterministicStatement)
        try:
            self.state = 2201
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [48]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2198
                self.ifThenSentence()
                pass
            elif token in [77]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2199
                self.goSentence()
                pass
            elif token in [81]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2200
                self.awaitSentence()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfThenSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(NeoBasicParser.IF, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def THEN(self):
            return self.getToken(NeoBasicParser.THEN, 0)

        def statementSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_ifThenSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfThenSentence" ):
                listener.enterIfThenSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfThenSentence" ):
                listener.exitIfThenSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfThenSentence" ):
                return visitor.visitIfThenSentence(self)
            else:
                return visitor.visitChildren(self)




    def ifThenSentence(self):

        localctx = NeoBasicParser.IfThenSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 456, self.RULE_ifThenSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2203
            self.match(NeoBasicParser.IF)
            self.state = 2204
            self.expression(0)
            self.state = 2205
            self.match(NeoBasicParser.THEN)
            self.state = 2206
            self.statementSentence()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GoSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GO(self):
            return self.getToken(NeoBasicParser.GO, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def INTO(self):
            return self.getToken(NeoBasicParser.INTO, 0)

        def primaryExpressions(self):
            return self.getTypedRuleContext(NeoBasicParser.PrimaryExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_goSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGoSentence" ):
                listener.enterGoSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGoSentence" ):
                listener.exitGoSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGoSentence" ):
                return visitor.visitGoSentence(self)
            else:
                return visitor.visitChildren(self)




    def goSentence(self):

        localctx = NeoBasicParser.GoSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 458, self.RULE_goSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2208
            self.match(NeoBasicParser.GO)
            self.state = 2209
            self.expression(0)
            self.state = 2212
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,177,self._ctx)
            if la_ == 1:
                self.state = 2210
                self.match(NeoBasicParser.INTO)
                self.state = 2211
                self.primaryExpressions()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AwaitSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AWAIT(self):
            return self.getToken(NeoBasicParser.AWAIT, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_awaitSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAwaitSentence" ):
                listener.enterAwaitSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAwaitSentence" ):
                listener.exitAwaitSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAwaitSentence" ):
                return visitor.visitAwaitSentence(self)
            else:
                return visitor.visitChildren(self)




    def awaitSentence(self):

        localctx = NeoBasicParser.AwaitSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 460, self.RULE_awaitSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2214
            self.match(NeoBasicParser.AWAIT)
            self.state = 2215
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompoundStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def conditionalStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ConditionalStatementContext,0)


        def iterationStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.IterationStatementContext,0)


        def controlFlowStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ControlFlowStatementContext,0)


        def concurrencyStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ConcurrencyStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_compoundStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompoundStatement" ):
                listener.enterCompoundStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompoundStatement" ):
                listener.exitCompoundStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompoundStatement" ):
                return visitor.visitCompoundStatement(self)
            else:
                return visitor.visitChildren(self)




    def compoundStatement(self):

        localctx = NeoBasicParser.CompoundStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 462, self.RULE_compoundStatement)
        try:
            self.state = 2221
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [48, 52, 55, 82]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2217
                self.conditionalStatement()
                pass
            elif token in [63]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2218
                self.iterationStatement()
                pass
            elif token in [61, 85]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2219
                self.controlFlowStatement()
                pass
            elif token in [79]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2220
                self.concurrencyStatement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionalStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ifSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.IfSentenceContext,0)


        def matchSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.MatchSentenceContext,0)


        def trySentence(self):
            return self.getTypedRuleContext(NeoBasicParser.TrySentenceContext,0)


        def switchSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.SwitchSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_conditionalStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditionalStatement" ):
                listener.enterConditionalStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditionalStatement" ):
                listener.exitConditionalStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConditionalStatement" ):
                return visitor.visitConditionalStatement(self)
            else:
                return visitor.visitChildren(self)




    def conditionalStatement(self):

        localctx = NeoBasicParser.ConditionalStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 464, self.RULE_conditionalStatement)
        try:
            self.state = 2227
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [48]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2223
                self.ifSentence()
                pass
            elif token in [52]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2224
                self.matchSentence()
                pass
            elif token in [55]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2225
                self.trySentence()
                pass
            elif token in [82]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2226
                self.switchSentence()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IterationStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loopSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.LoopSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_iterationStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIterationStatement" ):
                listener.enterIterationStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIterationStatement" ):
                listener.exitIterationStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIterationStatement" ):
                return visitor.visitIterationStatement(self)
            else:
                return visitor.visitChildren(self)




    def iterationStatement(self):

        localctx = NeoBasicParser.IterationStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 466, self.RULE_iterationStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2229
            self.loopSentence()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ControlFlowStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def beginSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.BeginSentenceContext,0)


        def withSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.WithSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_controlFlowStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterControlFlowStatement" ):
                listener.enterControlFlowStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitControlFlowStatement" ):
                listener.exitControlFlowStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitControlFlowStatement" ):
                return visitor.visitControlFlowStatement(self)
            else:
                return visitor.visitChildren(self)




    def controlFlowStatement(self):

        localctx = NeoBasicParser.ControlFlowStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 468, self.RULE_controlFlowStatement)
        try:
            self.state = 2233
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [85]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2231
                self.beginSentence()
                pass
            elif token in [61]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2232
                self.withSentence()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConcurrencyStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def gosubSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.GosubSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_concurrencyStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConcurrencyStatement" ):
                listener.enterConcurrencyStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConcurrencyStatement" ):
                listener.exitConcurrencyStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConcurrencyStatement" ):
                return visitor.visitConcurrencyStatement(self)
            else:
                return visitor.visitChildren(self)




    def concurrencyStatement(self):

        localctx = NeoBasicParser.ConcurrencyStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 470, self.RULE_concurrencyStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2235
            self.gosubSentence()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ifClause(self):
            return self.getTypedRuleContext(NeoBasicParser.IfClauseContext,0)


        def elifClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ElifClauseContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ElifClauseContext,i)


        def elseClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ElseClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_ifSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfSentence" ):
                listener.enterIfSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfSentence" ):
                listener.exitIfSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfSentence" ):
                return visitor.visitIfSentence(self)
            else:
                return visitor.visitChildren(self)




    def ifSentence(self):

        localctx = NeoBasicParser.IfSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 472, self.RULE_ifSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2237
            self.ifClause()
            self.state = 2241
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,181,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2238
                    self.elifClause() 
                self.state = 2243
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,181,self._ctx)

            self.state = 2245
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,182,self._ctx)
            if la_ == 1:
                self.state = 2244
                self.elseClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(NeoBasicParser.IF, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_ifClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfClause" ):
                listener.enterIfClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfClause" ):
                listener.exitIfClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfClause" ):
                return visitor.visitIfClause(self)
            else:
                return visitor.visitChildren(self)




    def ifClause(self):

        localctx = NeoBasicParser.IfClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 474, self.RULE_ifClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2247
            self.match(NeoBasicParser.IF)
            self.state = 2248
            self.expression(0)
            self.state = 2249
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElifClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def ELIF(self):
            return self.getToken(NeoBasicParser.ELIF, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_elifClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElifClause" ):
                listener.enterElifClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElifClause" ):
                listener.exitElifClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElifClause" ):
                return visitor.visitElifClause(self)
            else:
                return visitor.visitChildren(self)




    def elifClause(self):

        localctx = NeoBasicParser.ElifClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 476, self.RULE_elifClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2251
            self.match(NeoBasicParser.EOS)
            self.state = 2252
            self.match(NeoBasicParser.ELIF)
            self.state = 2253
            self.expression(0)
            self.state = 2254
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElseClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def ELSE(self):
            return self.getToken(NeoBasicParser.ELSE, 0)

        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_elseClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElseClause" ):
                listener.enterElseClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElseClause" ):
                listener.exitElseClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElseClause" ):
                return visitor.visitElseClause(self)
            else:
                return visitor.visitChildren(self)




    def elseClause(self):

        localctx = NeoBasicParser.ElseClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 478, self.RULE_elseClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2256
            self.match(NeoBasicParser.EOS)
            self.state = 2257
            self.match(NeoBasicParser.ELSE)
            self.state = 2258
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatchSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def matchClause(self):
            return self.getTypedRuleContext(NeoBasicParser.MatchClauseContext,0)


        def caseClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.CaseClauseContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.CaseClauseContext,i)


        def elseClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ElseClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_matchSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatchSentence" ):
                listener.enterMatchSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatchSentence" ):
                listener.exitMatchSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatchSentence" ):
                return visitor.visitMatchSentence(self)
            else:
                return visitor.visitChildren(self)




    def matchSentence(self):

        localctx = NeoBasicParser.MatchSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 480, self.RULE_matchSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2260
            self.matchClause()
            self.state = 2262 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 2261
                    self.caseClause()

                else:
                    raise NoViableAltException(self)
                self.state = 2264 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,183,self._ctx)

            self.state = 2267
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,184,self._ctx)
            if la_ == 1:
                self.state = 2266
                self.elseClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatchClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MATCH(self):
            return self.getToken(NeoBasicParser.MATCH, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_matchClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatchClause" ):
                listener.enterMatchClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatchClause" ):
                listener.exitMatchClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatchClause" ):
                return visitor.visitMatchClause(self)
            else:
                return visitor.visitChildren(self)




    def matchClause(self):

        localctx = NeoBasicParser.MatchClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 482, self.RULE_matchClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2269
            self.match(NeoBasicParser.MATCH)
            self.state = 2271
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 247385886433392) != 0) or ((((_la - 93)) & ~0x3f) == 0 and ((1 << (_la - 93)) & -4128769) != 0) or ((((_la - 157)) & ~0x3f) == 0 and ((1 << (_la - 157)) & -1) != 0) or ((((_la - 221)) & ~0x3f) == 0 and ((1 << (_la - 221)) & -4610560118520676353) != 0) or ((((_la - 285)) & ~0x3f) == 0 and ((1 << (_la - 285)) & 2814750039735871) != 0) or ((((_la - 381)) & ~0x3f) == 0 and ((1 << (_la - 381)) & 47287830447128569) != 0) or ((((_la - 451)) & ~0x3f) == 0 and ((1 << (_la - 451)) & 12295) != 0):
                self.state = 2270
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def CASE(self):
            return self.getToken(NeoBasicParser.CASE, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_caseClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseClause" ):
                listener.enterCaseClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseClause" ):
                listener.exitCaseClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaseClause" ):
                return visitor.visitCaseClause(self)
            else:
                return visitor.visitChildren(self)




    def caseClause(self):

        localctx = NeoBasicParser.CaseClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 484, self.RULE_caseClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2273
            self.match(NeoBasicParser.EOS)
            self.state = 2274
            self.match(NeoBasicParser.CASE)
            self.state = 2275
            self.expressions()
            self.state = 2276
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TrySentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tryClause(self):
            return self.getTypedRuleContext(NeoBasicParser.TryClauseContext,0)


        def catchClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.CatchClauseContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.CatchClauseContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_trySentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrySentence" ):
                listener.enterTrySentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrySentence" ):
                listener.exitTrySentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrySentence" ):
                return visitor.visitTrySentence(self)
            else:
                return visitor.visitChildren(self)




    def trySentence(self):

        localctx = NeoBasicParser.TrySentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 486, self.RULE_trySentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2278
            self.tryClause()
            self.state = 2282
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,186,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2279
                    self.catchClause() 
                self.state = 2284
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,186,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TryClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRY(self):
            return self.getToken(NeoBasicParser.TRY, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_tryClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTryClause" ):
                listener.enterTryClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTryClause" ):
                listener.exitTryClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTryClause" ):
                return visitor.visitTryClause(self)
            else:
                return visitor.visitChildren(self)




    def tryClause(self):

        localctx = NeoBasicParser.TryClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 488, self.RULE_tryClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2285
            self.match(NeoBasicParser.TRY)
            self.state = 2286
            self.expressions()
            self.state = 2288
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,187,self._ctx)
            if la_ == 1:
                self.state = 2287
                self.clauseStatement()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CatchClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def CATCH(self):
            return self.getToken(NeoBasicParser.CATCH, 0)

        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def inferredDecoratedIdentifiers(self):
            return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifiersContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_catchClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCatchClause" ):
                listener.enterCatchClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCatchClause" ):
                listener.exitCatchClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCatchClause" ):
                return visitor.visitCatchClause(self)
            else:
                return visitor.visitChildren(self)




    def catchClause(self):

        localctx = NeoBasicParser.CatchClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 490, self.RULE_catchClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2290
            self.match(NeoBasicParser.EOS)
            self.state = 2291
            self.match(NeoBasicParser.CATCH)
            self.state = 2293
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 381)) & ~0x3f) == 0 and ((1 << (_la - 381)) & 7) != 0):
                self.state = 2292
                self.inferredDecoratedIdentifiers()


            self.state = 2295
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SwitchSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def switchClause(self):
            return self.getTypedRuleContext(NeoBasicParser.SwitchClauseContext,0)


        def whenClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.WhenClauseContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.WhenClauseContext,i)


        def defaultClause(self):
            return self.getTypedRuleContext(NeoBasicParser.DefaultClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_switchSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSwitchSentence" ):
                listener.enterSwitchSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSwitchSentence" ):
                listener.exitSwitchSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSwitchSentence" ):
                return visitor.visitSwitchSentence(self)
            else:
                return visitor.visitChildren(self)




    def switchSentence(self):

        localctx = NeoBasicParser.SwitchSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 492, self.RULE_switchSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2297
            self.switchClause()
            self.state = 2299 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 2298
                    self.whenClause()

                else:
                    raise NoViableAltException(self)
                self.state = 2301 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,189,self._ctx)

            self.state = 2304
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,190,self._ctx)
            if la_ == 1:
                self.state = 2303
                self.defaultClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SwitchClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SWITCH(self):
            return self.getToken(NeoBasicParser.SWITCH, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_switchClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSwitchClause" ):
                listener.enterSwitchClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSwitchClause" ):
                listener.exitSwitchClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSwitchClause" ):
                return visitor.visitSwitchClause(self)
            else:
                return visitor.visitChildren(self)




    def switchClause(self):

        localctx = NeoBasicParser.SwitchClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 494, self.RULE_switchClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2306
            self.match(NeoBasicParser.SWITCH)
            self.state = 2307
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhenClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def WHEN(self):
            return self.getToken(NeoBasicParser.WHEN, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_whenClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhenClause" ):
                listener.enterWhenClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhenClause" ):
                listener.exitWhenClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhenClause" ):
                return visitor.visitWhenClause(self)
            else:
                return visitor.visitChildren(self)




    def whenClause(self):

        localctx = NeoBasicParser.WhenClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 496, self.RULE_whenClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2309
            self.match(NeoBasicParser.EOS)
            self.state = 2310
            self.match(NeoBasicParser.WHEN)
            self.state = 2311
            self.expressions()
            self.state = 2312
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def DEFAULT(self):
            return self.getToken(NeoBasicParser.DEFAULT, 0)

        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_defaultClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefaultClause" ):
                listener.enterDefaultClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefaultClause" ):
                listener.exitDefaultClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefaultClause" ):
                return visitor.visitDefaultClause(self)
            else:
                return visitor.visitChildren(self)




    def defaultClause(self):

        localctx = NeoBasicParser.DefaultClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 498, self.RULE_defaultClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2314
            self.match(NeoBasicParser.EOS)
            self.state = 2315
            self.match(NeoBasicParser.DEFAULT)
            self.state = 2316
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loopClause(self):
            return self.getTypedRuleContext(NeoBasicParser.LoopClauseContext,0)


        def thenClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ThenClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_loopSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopSentence" ):
                listener.enterLoopSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopSentence" ):
                listener.exitLoopSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopSentence" ):
                return visitor.visitLoopSentence(self)
            else:
                return visitor.visitChildren(self)




    def loopSentence(self):

        localctx = NeoBasicParser.LoopSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 500, self.RULE_loopSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2318
            self.loopClause()
            self.state = 2320
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,191,self._ctx)
            if la_ == 1:
                self.state = 2319
                self.thenClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOOP(self):
            return self.getToken(NeoBasicParser.LOOP, 0)

        def loopBody(self):
            return self.getTypedRuleContext(NeoBasicParser.LoopBodyContext,0)


        def varDeclare(self):
            return self.getTypedRuleContext(NeoBasicParser.VarDeclareContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_loopClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopClause" ):
                listener.enterLoopClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopClause" ):
                listener.exitLoopClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopClause" ):
                return visitor.visitLoopClause(self)
            else:
                return visitor.visitChildren(self)




    def loopClause(self):

        localctx = NeoBasicParser.LoopClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 502, self.RULE_loopClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2322
            self.match(NeoBasicParser.LOOP)
            self.state = 2324
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,192,self._ctx)
            if la_ == 1:
                self.state = 2323
                self.varDeclare()


            self.state = 2326
            self.loopBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loopNoCheck(self):
            return self.getTypedRuleContext(NeoBasicParser.LoopNoCheckContext,0)


        def loopCheckFirst(self):
            return self.getTypedRuleContext(NeoBasicParser.LoopCheckFirstContext,0)


        def loopCheckLast(self):
            return self.getTypedRuleContext(NeoBasicParser.LoopCheckLastContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_loopBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopBody" ):
                listener.enterLoopBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopBody" ):
                listener.exitLoopBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopBody" ):
                return visitor.visitLoopBody(self)
            else:
                return visitor.visitChildren(self)




    def loopBody(self):

        localctx = NeoBasicParser.LoopBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 504, self.RULE_loopBody)
        try:
            self.state = 2331
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,193,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2328
                self.loopNoCheck()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2329
                self.loopCheckFirst()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2330
                self.loopCheckLast()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopNoCheckContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def uptoClause(self):
            return self.getTypedRuleContext(NeoBasicParser.UptoClauseContext,0)


        def nextClause(self):
            return self.getTypedRuleContext(NeoBasicParser.NextClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_loopNoCheck

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopNoCheck" ):
                listener.enterLoopNoCheck(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopNoCheck" ):
                listener.exitLoopNoCheck(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopNoCheck" ):
                return visitor.visitLoopNoCheck(self)
            else:
                return visitor.visitChildren(self)




    def loopNoCheck(self):

        localctx = NeoBasicParser.LoopNoCheckContext(self, self._ctx, self.state)
        self.enterRule(localctx, 506, self.RULE_loopNoCheck)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2334
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==69:
                self.state = 2333
                self.uptoClause()


            self.state = 2337
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==70:
                self.state = 2336
                self.nextClause()


            self.state = 2339
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopCheckFirstContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pretestClause(self):
            return self.getTypedRuleContext(NeoBasicParser.PretestClauseContext,0)


        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def uptoClause(self):
            return self.getTypedRuleContext(NeoBasicParser.UptoClauseContext,0)


        def nextClause(self):
            return self.getTypedRuleContext(NeoBasicParser.NextClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_loopCheckFirst

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopCheckFirst" ):
                listener.enterLoopCheckFirst(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopCheckFirst" ):
                listener.exitLoopCheckFirst(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopCheckFirst" ):
                return visitor.visitLoopCheckFirst(self)
            else:
                return visitor.visitChildren(self)




    def loopCheckFirst(self):

        localctx = NeoBasicParser.LoopCheckFirstContext(self, self._ctx, self.state)
        self.enterRule(localctx, 508, self.RULE_loopCheckFirst)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2341
            self.pretestClause()
            self.state = 2343
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==69:
                self.state = 2342
                self.uptoClause()


            self.state = 2346
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==70:
                self.state = 2345
                self.nextClause()


            self.state = 2348
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopCheckLastContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statementSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementSuiteContext,0)


        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def posttestClause(self):
            return self.getTypedRuleContext(NeoBasicParser.PosttestClauseContext,0)


        def uptoClause(self):
            return self.getTypedRuleContext(NeoBasicParser.UptoClauseContext,0)


        def nextClause(self):
            return self.getTypedRuleContext(NeoBasicParser.NextClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_loopCheckLast

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopCheckLast" ):
                listener.enterLoopCheckLast(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopCheckLast" ):
                listener.exitLoopCheckLast(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopCheckLast" ):
                return visitor.visitLoopCheckLast(self)
            else:
                return visitor.visitChildren(self)




    def loopCheckLast(self):

        localctx = NeoBasicParser.LoopCheckLastContext(self, self._ctx, self.state)
        self.enterRule(localctx, 510, self.RULE_loopCheckLast)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2350
            self.statementSuite()
            self.state = 2351
            self.match(NeoBasicParser.EOS)
            self.state = 2352
            self.posttestClause()
            self.state = 2354
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,198,self._ctx)
            if la_ == 1:
                self.state = 2353
                self.uptoClause()


            self.state = 2357
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,199,self._ctx)
            if la_ == 1:
                self.state = 2356
                self.nextClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NextClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEXT(self):
            return self.getToken(NeoBasicParser.NEXT, 0)

        def simpleStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.SimpleStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_nextClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNextClause" ):
                listener.enterNextClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNextClause" ):
                listener.exitNextClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNextClause" ):
                return visitor.visitNextClause(self)
            else:
                return visitor.visitChildren(self)




    def nextClause(self):

        localctx = NeoBasicParser.NextClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 512, self.RULE_nextClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2359
            self.match(NeoBasicParser.NEXT)
            self.state = 2360
            self.simpleStatement(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UptoClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UPTO(self):
            return self.getToken(NeoBasicParser.UPTO, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_uptoClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUptoClause" ):
                listener.enterUptoClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUptoClause" ):
                listener.exitUptoClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUptoClause" ):
                return visitor.visitUptoClause(self)
            else:
                return visitor.visitChildren(self)




    def uptoClause(self):

        localctx = NeoBasicParser.UptoClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 514, self.RULE_uptoClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2362
            self.match(NeoBasicParser.UPTO)
            self.state = 2363
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PretestClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loopEachClause(self):
            return self.getTypedRuleContext(NeoBasicParser.LoopEachClauseContext,0)


        def loopWhileClause(self):
            return self.getTypedRuleContext(NeoBasicParser.LoopWhileClauseContext,0)


        def loopUntilClause(self):
            return self.getTypedRuleContext(NeoBasicParser.LoopUntilClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_pretestClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPretestClause" ):
                listener.enterPretestClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPretestClause" ):
                listener.exitPretestClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPretestClause" ):
                return visitor.visitPretestClause(self)
            else:
                return visitor.visitChildren(self)




    def pretestClause(self):

        localctx = NeoBasicParser.PretestClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 516, self.RULE_pretestClause)
        try:
            self.state = 2368
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [381]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2365
                self.loopEachClause()
                pass
            elif token in [67]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2366
                self.loopWhileClause()
                pass
            elif token in [68]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2367
                self.loopUntilClause()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PosttestClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loopWhileClause(self):
            return self.getTypedRuleContext(NeoBasicParser.LoopWhileClauseContext,0)


        def loopUntilClause(self):
            return self.getTypedRuleContext(NeoBasicParser.LoopUntilClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_posttestClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPosttestClause" ):
                listener.enterPosttestClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPosttestClause" ):
                listener.exitPosttestClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPosttestClause" ):
                return visitor.visitPosttestClause(self)
            else:
                return visitor.visitChildren(self)




    def posttestClause(self):

        localctx = NeoBasicParser.PosttestClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 518, self.RULE_posttestClause)
        try:
            self.state = 2372
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [67]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2370
                self.loopWhileClause()
                pass
            elif token in [68]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2371
                self.loopUntilClause()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopEachClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifiers(self):
            return self.getTypedRuleContext(NeoBasicParser.IdentifiersContext,0)


        def EACH(self):
            return self.getToken(NeoBasicParser.EACH, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def STEP(self):
            return self.getToken(NeoBasicParser.STEP, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_loopEachClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopEachClause" ):
                listener.enterLoopEachClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopEachClause" ):
                listener.exitLoopEachClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopEachClause" ):
                return visitor.visitLoopEachClause(self)
            else:
                return visitor.visitChildren(self)




    def loopEachClause(self):

        localctx = NeoBasicParser.LoopEachClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 520, self.RULE_loopEachClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2374
            self.identifiers()
            self.state = 2375
            self.match(NeoBasicParser.EACH)
            self.state = 2376
            self.expressions()
            self.state = 2379
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==66:
                self.state = 2377
                self.match(NeoBasicParser.STEP)
                self.state = 2378
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopWhileClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(NeoBasicParser.WHILE, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_loopWhileClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopWhileClause" ):
                listener.enterLoopWhileClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopWhileClause" ):
                listener.exitLoopWhileClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopWhileClause" ):
                return visitor.visitLoopWhileClause(self)
            else:
                return visitor.visitChildren(self)




    def loopWhileClause(self):

        localctx = NeoBasicParser.LoopWhileClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 522, self.RULE_loopWhileClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2381
            self.match(NeoBasicParser.WHILE)
            self.state = 2382
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopUntilClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNTIL(self):
            return self.getToken(NeoBasicParser.UNTIL, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_loopUntilClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopUntilClause" ):
                listener.enterLoopUntilClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopUntilClause" ):
                listener.exitLoopUntilClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopUntilClause" ):
                return visitor.visitLoopUntilClause(self)
            else:
                return visitor.visitChildren(self)




    def loopUntilClause(self):

        localctx = NeoBasicParser.LoopUntilClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 524, self.RULE_loopUntilClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2384
            self.match(NeoBasicParser.UNTIL)
            self.state = 2385
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ThenClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def THEN(self):
            return self.getToken(NeoBasicParser.THEN, 0)

        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_thenClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThenClause" ):
                listener.enterThenClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThenClause" ):
                listener.exitThenClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThenClause" ):
                return visitor.visitThenClause(self)
            else:
                return visitor.visitChildren(self)




    def thenClause(self):

        localctx = NeoBasicParser.ThenClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 526, self.RULE_thenClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2387
            self.match(NeoBasicParser.EOS)
            self.state = 2388
            self.match(NeoBasicParser.THEN)
            self.state = 2389
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeginSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def beginClause(self):
            return self.getTypedRuleContext(NeoBasicParser.BeginClauseContext,0)


        def endClause(self):
            return self.getTypedRuleContext(NeoBasicParser.EndClauseContext,0)


        def catchClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.CatchClauseContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.CatchClauseContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_beginSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeginSentence" ):
                listener.enterBeginSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeginSentence" ):
                listener.exitBeginSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeginSentence" ):
                return visitor.visitBeginSentence(self)
            else:
                return visitor.visitChildren(self)




    def beginSentence(self):

        localctx = NeoBasicParser.BeginSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 528, self.RULE_beginSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2391
            self.beginClause()
            self.state = 2395
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,203,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2392
                    self.catchClause() 
                self.state = 2397
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,203,self._ctx)

            self.state = 2398
            self.endClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeginClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BEGIN(self):
            return self.getToken(NeoBasicParser.BEGIN, 0)

        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_beginClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeginClause" ):
                listener.enterBeginClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeginClause" ):
                listener.exitBeginClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeginClause" ):
                return visitor.visitBeginClause(self)
            else:
                return visitor.visitChildren(self)




    def beginClause(self):

        localctx = NeoBasicParser.BeginClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 530, self.RULE_beginClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2400
            self.match(NeoBasicParser.BEGIN)
            self.state = 2401
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EndClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def END(self):
            return self.getToken(NeoBasicParser.END, 0)

        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_endClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndClause" ):
                listener.enterEndClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndClause" ):
                listener.exitEndClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndClause" ):
                return visitor.visitEndClause(self)
            else:
                return visitor.visitChildren(self)




    def endClause(self):

        localctx = NeoBasicParser.EndClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 532, self.RULE_endClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2403
            self.match(NeoBasicParser.EOS)
            self.state = 2404
            self.match(NeoBasicParser.END)
            self.state = 2405
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WithSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def withClause(self):
            return self.getTypedRuleContext(NeoBasicParser.WithClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_withSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWithSentence" ):
                listener.enterWithSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWithSentence" ):
                listener.exitWithSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWithSentence" ):
                return visitor.visitWithSentence(self)
            else:
                return visitor.visitChildren(self)




    def withSentence(self):

        localctx = NeoBasicParser.WithSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 534, self.RULE_withSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2407
            self.withClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WithClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH(self):
            return self.getToken(NeoBasicParser.WITH, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_withClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWithClause" ):
                listener.enterWithClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWithClause" ):
                listener.exitWithClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWithClause" ):
                return visitor.visitWithClause(self)
            else:
                return visitor.visitChildren(self)




    def withClause(self):

        localctx = NeoBasicParser.WithClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 536, self.RULE_withClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2409
            self.match(NeoBasicParser.WITH)
            self.state = 2410
            self.expressions()
            self.state = 2412
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,204,self._ctx)
            if la_ == 1:
                self.state = 2411
                self.clauseStatement()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GosubSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def gosubClause(self):
            return self.getTypedRuleContext(NeoBasicParser.GosubClauseContext,0)


        def forkClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ForkClauseContext,0)


        def forEachClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ForEachClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_gosubSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGosubSentence" ):
                listener.enterGosubSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGosubSentence" ):
                listener.exitGosubSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGosubSentence" ):
                return visitor.visitGosubSentence(self)
            else:
                return visitor.visitChildren(self)




    def gosubSentence(self):

        localctx = NeoBasicParser.GosubSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 538, self.RULE_gosubSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2414
            self.gosubClause()
            self.state = 2416
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,205,self._ctx)
            if la_ == 1:
                self.state = 2415
                self.forkClause()


            self.state = 2419
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,206,self._ctx)
            if la_ == 1:
                self.state = 2418
                self.forEachClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GosubClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GOSUB(self):
            return self.getToken(NeoBasicParser.GOSUB, 0)

        def statementSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementSuiteContext,0)


        def decoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DecoratedIdentifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_gosubClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGosubClause" ):
                listener.enterGosubClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGosubClause" ):
                listener.exitGosubClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGosubClause" ):
                return visitor.visitGosubClause(self)
            else:
                return visitor.visitChildren(self)




    def gosubClause(self):

        localctx = NeoBasicParser.GosubClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 540, self.RULE_gosubClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2421
            self.match(NeoBasicParser.GOSUB)
            self.state = 2423
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 381)) & ~0x3f) == 0 and ((1 << (_la - 381)) & 7) != 0):
                self.state = 2422
                self.decoratedIdentifier()


            self.state = 2425
            self.statementSuite()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForkClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FORK(self):
            return self.getToken(NeoBasicParser.FORK, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_forkClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForkClause" ):
                listener.enterForkClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForkClause" ):
                listener.exitForkClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForkClause" ):
                return visitor.visitForkClause(self)
            else:
                return visitor.visitChildren(self)




    def forkClause(self):

        localctx = NeoBasicParser.ForkClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 542, self.RULE_forkClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2427
            self.match(NeoBasicParser.FORK)
            self.state = 2428
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForEachClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(NeoBasicParser.FOR, 0)

        def identifiers(self):
            return self.getTypedRuleContext(NeoBasicParser.IdentifiersContext,0)


        def EACH(self):
            return self.getToken(NeoBasicParser.EACH, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def STEP(self):
            return self.getToken(NeoBasicParser.STEP, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_forEachClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForEachClause" ):
                listener.enterForEachClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForEachClause" ):
                listener.exitForEachClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForEachClause" ):
                return visitor.visitForEachClause(self)
            else:
                return visitor.visitChildren(self)




    def forEachClause(self):

        localctx = NeoBasicParser.ForEachClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 544, self.RULE_forEachClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2430
            self.match(NeoBasicParser.FOR)
            self.state = 2431
            self.identifiers()
            self.state = 2432
            self.match(NeoBasicParser.EACH)
            self.state = 2433
            self.expressions()
            self.state = 2436
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,208,self._ctx)
            if la_ == 1:
                self.state = 2434
                self.match(NeoBasicParser.STEP)
                self.state = 2435
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TestingStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simpleTestStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.SimpleTestStatementContext,0)


        def compoundTestStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.CompoundTestStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_testingStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTestingStatement" ):
                listener.enterTestingStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTestingStatement" ):
                listener.exitTestingStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTestingStatement" ):
                return visitor.visitTestingStatement(self)
            else:
                return visitor.visitChildren(self)




    def testingStatement(self):

        localctx = NeoBasicParser.TestingStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 546, self.RULE_testingStatement)
        try:
            self.state = 2440
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [271]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2438
                self.simpleTestStatement()
                pass
            elif token in [272]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2439
                self.compoundTestStatement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleTestStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assertTestStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.AssertTestStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_simpleTestStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleTestStatement" ):
                listener.enterSimpleTestStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleTestStatement" ):
                listener.exitSimpleTestStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleTestStatement" ):
                return visitor.visitSimpleTestStatement(self)
            else:
                return visitor.visitChildren(self)




    def simpleTestStatement(self):

        localctx = NeoBasicParser.SimpleTestStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 548, self.RULE_simpleTestStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2442
            self.assertTestStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompoundTestStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unitTestStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.UnitTestStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_compoundTestStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompoundTestStatement" ):
                listener.enterCompoundTestStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompoundTestStatement" ):
                listener.exitCompoundTestStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompoundTestStatement" ):
                return visitor.visitCompoundTestStatement(self)
            else:
                return visitor.visitChildren(self)




    def compoundTestStatement(self):

        localctx = NeoBasicParser.CompoundTestStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 550, self.RULE_compoundTestStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2444
            self.unitTestStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssertTestStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assertClause(self):
            return self.getTypedRuleContext(NeoBasicParser.AssertClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_assertTestStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssertTestStatement" ):
                listener.enterAssertTestStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssertTestStatement" ):
                listener.exitAssertTestStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssertTestStatement" ):
                return visitor.visitAssertTestStatement(self)
            else:
                return visitor.visitChildren(self)




    def assertTestStatement(self):

        localctx = NeoBasicParser.AssertTestStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 552, self.RULE_assertTestStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2446
            self.assertClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssertClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASSERT(self):
            return self.getToken(NeoBasicParser.ASSERT, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,i)


        def EXCLAMATION(self):
            return self.getToken(NeoBasicParser.EXCLAMATION, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_assertClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssertClause" ):
                listener.enterAssertClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssertClause" ):
                listener.exitAssertClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssertClause" ):
                return visitor.visitAssertClause(self)
            else:
                return visitor.visitChildren(self)




    def assertClause(self):

        localctx = NeoBasicParser.AssertClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 554, self.RULE_assertClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2448
            self.match(NeoBasicParser.ASSERT)
            self.state = 2449
            self.expression(0)
            self.state = 2453
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,210,self._ctx)
            if la_ == 1:
                self.state = 2450
                self.match(NeoBasicParser.EXCLAMATION)

            elif la_ == 2:
                self.state = 2451
                self.match(NeoBasicParser.EXCLAMATION)
                self.state = 2452
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnitTestStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unitClause(self):
            return self.getTypedRuleContext(NeoBasicParser.UnitClauseContext,0)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def fromClause(self):
            return self.getTypedRuleContext(NeoBasicParser.FromClauseContext,0)


        def onceClause(self):
            return self.getTypedRuleContext(NeoBasicParser.OnceClauseContext,0)


        def dataClause(self):
            return self.getTypedRuleContext(NeoBasicParser.DataClauseContext,0)


        def callClause(self):
            return self.getTypedRuleContext(NeoBasicParser.CallClauseContext,0)


        def hideClause(self):
            return self.getTypedRuleContext(NeoBasicParser.HideClauseContext,0)


        def showClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ShowClauseContext,0)


        def stayClause(self):
            return self.getTypedRuleContext(NeoBasicParser.StayClauseContext,0)


        def passClause(self):
            return self.getTypedRuleContext(NeoBasicParser.PassClauseContext,0)


        def pastClause(self):
            return self.getTypedRuleContext(NeoBasicParser.PastClauseContext,0)


        def failClause(self):
            return self.getTypedRuleContext(NeoBasicParser.FailClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_unitTestStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnitTestStatement" ):
                listener.enterUnitTestStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnitTestStatement" ):
                listener.exitUnitTestStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnitTestStatement" ):
                return visitor.visitUnitTestStatement(self)
            else:
                return visitor.visitChildren(self)




    def unitTestStatement(self):

        localctx = NeoBasicParser.UnitTestStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 556, self.RULE_unitTestStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2455
            self.unitClause()
            self.state = 2458
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,211,self._ctx)
            if la_ == 1:
                self.state = 2456
                self.match(NeoBasicParser.EOS)
                self.state = 2457
                self.fromClause()


            self.state = 2462
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,212,self._ctx)
            if la_ == 1:
                self.state = 2460
                self.match(NeoBasicParser.EOS)
                self.state = 2461
                self.onceClause()


            self.state = 2466
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,213,self._ctx)
            if la_ == 1:
                self.state = 2464
                self.match(NeoBasicParser.EOS)
                self.state = 2465
                self.dataClause()


            self.state = 2470
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,214,self._ctx)
            if la_ == 1:
                self.state = 2468
                self.match(NeoBasicParser.EOS)
                self.state = 2469
                self.callClause()


            self.state = 2474
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,215,self._ctx)
            if la_ == 1:
                self.state = 2472
                self.match(NeoBasicParser.EOS)
                self.state = 2473
                self.hideClause()


            self.state = 2478
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,216,self._ctx)
            if la_ == 1:
                self.state = 2476
                self.match(NeoBasicParser.EOS)
                self.state = 2477
                self.showClause()


            self.state = 2482
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,217,self._ctx)
            if la_ == 1:
                self.state = 2480
                self.match(NeoBasicParser.EOS)
                self.state = 2481
                self.stayClause()


            self.state = 2486
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,218,self._ctx)
            if la_ == 1:
                self.state = 2484
                self.match(NeoBasicParser.EOS)
                self.state = 2485
                self.passClause()


            self.state = 2490
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,219,self._ctx)
            if la_ == 1:
                self.state = 2488
                self.match(NeoBasicParser.EOS)
                self.state = 2489
                self.pastClause()


            self.state = 2494
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,220,self._ctx)
            if la_ == 1:
                self.state = 2492
                self.match(NeoBasicParser.EOS)
                self.state = 2493
                self.failClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnitClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNIT(self):
            return self.getToken(NeoBasicParser.UNIT, 0)

        def sequenceLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.SequenceLiteralContext,0)


        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_unitClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnitClause" ):
                listener.enterUnitClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnitClause" ):
                listener.exitUnitClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnitClause" ):
                return visitor.visitUnitClause(self)
            else:
                return visitor.visitChildren(self)




    def unitClause(self):

        localctx = NeoBasicParser.UnitClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 558, self.RULE_unitClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2496
            self.match(NeoBasicParser.UNIT)
            self.state = 2498
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,221,self._ctx)
            if la_ == 1:
                self.state = 2497
                self.sequenceLiteral()


            self.state = 2501
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,222,self._ctx)
            if la_ == 1:
                self.state = 2500
                self.logicalInstructionSuite()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FromClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FROM(self):
            return self.getToken(NeoBasicParser.FROM, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_fromClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFromClause" ):
                listener.enterFromClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFromClause" ):
                listener.exitFromClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFromClause" ):
                return visitor.visitFromClause(self)
            else:
                return visitor.visitChildren(self)




    def fromClause(self):

        localctx = NeoBasicParser.FromClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 560, self.RULE_fromClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2503
            self.match(NeoBasicParser.FROM)
            self.state = 2506
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 13, 17, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 45, 46, 47, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 283, 284, 285, 286, 287, 288, 289, 290, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 313, 334, 336, 381, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 432, 434, 436, 451, 452, 453, 463, 464]:
                self.state = 2504
                self.expressions()
                pass
            elif token in [423]:
                self.state = 2505
                self.logicalInstructionSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnceClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ONCE(self):
            return self.getToken(NeoBasicParser.ONCE, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_onceClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnceClause" ):
                listener.enterOnceClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnceClause" ):
                listener.exitOnceClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnceClause" ):
                return visitor.visitOnceClause(self)
            else:
                return visitor.visitChildren(self)




    def onceClause(self):

        localctx = NeoBasicParser.OnceClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 562, self.RULE_onceClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2508
            self.match(NeoBasicParser.ONCE)
            self.state = 2511
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 13, 17, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 45, 46, 47, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 283, 284, 285, 286, 287, 288, 289, 290, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 313, 334, 336, 381, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 432, 434, 436, 451, 452, 453, 463, 464]:
                self.state = 2509
                self.expressions()
                pass
            elif token in [423]:
                self.state = 2510
                self.logicalInstructionSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATA(self):
            return self.getToken(NeoBasicParser.DATA, 0)

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def dataTable(self):
            return self.getTypedRuleContext(NeoBasicParser.DataTableContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_dataClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataClause" ):
                listener.enterDataClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataClause" ):
                listener.exitDataClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataClause" ):
                return visitor.visitDataClause(self)
            else:
                return visitor.visitChildren(self)




    def dataClause(self):

        localctx = NeoBasicParser.DataClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 564, self.RULE_dataClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2513
            self.match(NeoBasicParser.DATA)
            self.state = 2514
            self.match(NeoBasicParser.EOS)
            self.state = 2515
            self.match(NeoBasicParser.INDENT)
            self.state = 2516
            self.dataTable()
            self.state = 2517
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataTableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dataRow(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.DataRowContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.DataRowContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_dataTable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataTable" ):
                listener.enterDataTable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataTable" ):
                listener.exitDataTable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataTable" ):
                return visitor.visitDataTable(self)
            else:
                return visitor.visitChildren(self)




    def dataTable(self):

        localctx = NeoBasicParser.DataTableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 566, self.RULE_dataTable)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2519
            self.dataRow()
            self.state = 2524
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==423:
                self.state = 2520
                self.match(NeoBasicParser.EOS)
                self.state = 2521
                self.dataRow()
                self.state = 2526
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataRowContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,i)


        def PIPE(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.PIPE)
            else:
                return self.getToken(NeoBasicParser.PIPE, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_dataRow

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataRow" ):
                listener.enterDataRow(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataRow" ):
                listener.exitDataRow(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataRow" ):
                return visitor.visitDataRow(self)
            else:
                return visitor.visitChildren(self)




    def dataRow(self):

        localctx = NeoBasicParser.DataRowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 568, self.RULE_dataRow)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2527
            self.expression(0)
            self.state = 2532
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==451:
                self.state = 2528
                self.match(NeoBasicParser.PIPE)
                self.state = 2529
                self.expression(0)
                self.state = 2534
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CallClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CALL(self):
            return self.getToken(NeoBasicParser.CALL, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_callClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCallClause" ):
                listener.enterCallClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCallClause" ):
                listener.exitCallClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCallClause" ):
                return visitor.visitCallClause(self)
            else:
                return visitor.visitChildren(self)




    def callClause(self):

        localctx = NeoBasicParser.CallClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 570, self.RULE_callClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2535
            self.match(NeoBasicParser.CALL)
            self.state = 2538
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 13, 17, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 45, 46, 47, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 283, 284, 285, 286, 287, 288, 289, 290, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 313, 334, 336, 381, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 432, 434, 436, 451, 452, 453, 463, 464]:
                self.state = 2536
                self.expressions()
                pass
            elif token in [423]:
                self.state = 2537
                self.logicalInstructionSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HideClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HIDE(self):
            return self.getToken(NeoBasicParser.HIDE, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_hideClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHideClause" ):
                listener.enterHideClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHideClause" ):
                listener.exitHideClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHideClause" ):
                return visitor.visitHideClause(self)
            else:
                return visitor.visitChildren(self)




    def hideClause(self):

        localctx = NeoBasicParser.HideClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 572, self.RULE_hideClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2540
            self.match(NeoBasicParser.HIDE)
            self.state = 2543
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 13, 17, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 45, 46, 47, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 283, 284, 285, 286, 287, 288, 289, 290, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 313, 334, 336, 381, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 432, 434, 436, 451, 452, 453, 463, 464]:
                self.state = 2541
                self.expressions()
                pass
            elif token in [423]:
                self.state = 2542
                self.logicalInstructionSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW(self):
            return self.getToken(NeoBasicParser.SHOW, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_showClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowClause" ):
                listener.enterShowClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowClause" ):
                listener.exitShowClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowClause" ):
                return visitor.visitShowClause(self)
            else:
                return visitor.visitChildren(self)




    def showClause(self):

        localctx = NeoBasicParser.ShowClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 574, self.RULE_showClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2545
            self.match(NeoBasicParser.SHOW)
            self.state = 2548
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 13, 17, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 45, 46, 47, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 283, 284, 285, 286, 287, 288, 289, 290, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 313, 334, 336, 381, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 432, 434, 436, 451, 452, 453, 463, 464]:
                self.state = 2546
                self.expressions()
                pass
            elif token in [423]:
                self.state = 2547
                self.logicalInstructionSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StayClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STAY(self):
            return self.getToken(NeoBasicParser.STAY, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_stayClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStayClause" ):
                listener.enterStayClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStayClause" ):
                listener.exitStayClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStayClause" ):
                return visitor.visitStayClause(self)
            else:
                return visitor.visitChildren(self)




    def stayClause(self):

        localctx = NeoBasicParser.StayClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 576, self.RULE_stayClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2550
            self.match(NeoBasicParser.STAY)
            self.state = 2553
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 13, 17, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 45, 46, 47, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 283, 284, 285, 286, 287, 288, 289, 290, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 313, 334, 336, 381, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 432, 434, 436, 451, 452, 453, 463, 464]:
                self.state = 2551
                self.expressions()
                pass
            elif token in [423]:
                self.state = 2552
                self.logicalInstructionSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PassClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PASS(self):
            return self.getToken(NeoBasicParser.PASS, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_passClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPassClause" ):
                listener.enterPassClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPassClause" ):
                listener.exitPassClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPassClause" ):
                return visitor.visitPassClause(self)
            else:
                return visitor.visitChildren(self)




    def passClause(self):

        localctx = NeoBasicParser.PassClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 578, self.RULE_passClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2555
            self.match(NeoBasicParser.PASS)
            self.state = 2558
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 13, 17, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 45, 46, 47, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 283, 284, 285, 286, 287, 288, 289, 290, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 313, 334, 336, 381, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 432, 434, 436, 451, 452, 453, 463, 464]:
                self.state = 2556
                self.expressions()
                pass
            elif token in [423]:
                self.state = 2557
                self.logicalInstructionSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PastClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PAST(self):
            return self.getToken(NeoBasicParser.PAST, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_pastClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPastClause" ):
                listener.enterPastClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPastClause" ):
                listener.exitPastClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPastClause" ):
                return visitor.visitPastClause(self)
            else:
                return visitor.visitChildren(self)




    def pastClause(self):

        localctx = NeoBasicParser.PastClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 580, self.RULE_pastClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2560
            self.match(NeoBasicParser.PAST)
            self.state = 2563
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 13, 17, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 45, 46, 47, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 283, 284, 285, 286, 287, 288, 289, 290, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 313, 334, 336, 381, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 432, 434, 436, 451, 452, 453, 463, 464]:
                self.state = 2561
                self.expressions()
                pass
            elif token in [423]:
                self.state = 2562
                self.logicalInstructionSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FailClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FAIL(self):
            return self.getToken(NeoBasicParser.FAIL, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_failClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFailClause" ):
                listener.enterFailClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFailClause" ):
                listener.exitFailClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFailClause" ):
                return visitor.visitFailClause(self)
            else:
                return visitor.visitChildren(self)




    def failClause(self):

        localctx = NeoBasicParser.FailClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 582, self.RULE_failClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2565
            self.match(NeoBasicParser.FAIL)
            self.state = 2568
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 13, 17, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 45, 46, 47, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 283, 284, 285, 286, 287, 288, 289, 290, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 313, 334, 336, 381, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 432, 434, 436, 451, 452, 453, 463, 464]:
                self.state = 2566
                self.expressions()
                pass
            elif token in [423]:
                self.state = 2567
                self.logicalInstructionSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrefixUnaryOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unaryArithmeticOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnaryArithmeticOperatorContext,0)


        def unarySpreadOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnarySpreadOperatorContext,0)


        def unaryLogicalOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnaryLogicalOperatorContext,0)


        def unaryArrayOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnaryArrayOperatorContext,0)


        def unaryCloneOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnaryCloneOperatorContext,0)


        def unaryMoveOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnaryMoveOperatorContext,0)


        def unaryMetaOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnaryMetaOperatorContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_prefixUnaryOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrefixUnaryOperator" ):
                listener.enterPrefixUnaryOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrefixUnaryOperator" ):
                listener.exitPrefixUnaryOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrefixUnaryOperator" ):
                return visitor.visitPrefixUnaryOperator(self)
            else:
                return visitor.visitChildren(self)




    def prefixUnaryOperator(self):

        localctx = NeoBasicParser.PrefixUnaryOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 584, self.RULE_prefixUnaryOperator)
        try:
            self.state = 2577
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [283, 284, 285, 286, 287, 288, 289]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2570
                self.unaryArithmeticOperator()
                pass
            elif token in [290]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2571
                self.unarySpreadOperator()
                pass
            elif token in [124]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2572
                self.unaryLogicalOperator()
                pass
            elif token in [127]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2573
                self.unaryArrayOperator()
                pass
            elif token in [125]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2574
                self.unaryCloneOperator()
                pass
            elif token in [126]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2575
                self.unaryMoveOperator()
                pass
            elif token in [107, 108]:
                self.enterOuterAlt(localctx, 7)
                self.state = 2576
                self.unaryMetaOperator()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryArithmeticOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CARET(self):
            return self.getToken(NeoBasicParser.CARET, 0)

        def SQUARE_ROOT(self):
            return self.getToken(NeoBasicParser.SQUARE_ROOT, 0)

        def FACTORIAL(self):
            return self.getToken(NeoBasicParser.FACTORIAL, 0)

        def INCREMENT(self):
            return self.getToken(NeoBasicParser.INCREMENT, 0)

        def DECREMENT(self):
            return self.getToken(NeoBasicParser.DECREMENT, 0)

        def PLUS(self):
            return self.getToken(NeoBasicParser.PLUS, 0)

        def HYPHEN(self):
            return self.getToken(NeoBasicParser.HYPHEN, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_unaryArithmeticOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryArithmeticOperator" ):
                listener.enterUnaryArithmeticOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryArithmeticOperator" ):
                listener.exitUnaryArithmeticOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryArithmeticOperator" ):
                return visitor.visitUnaryArithmeticOperator(self)
            else:
                return visitor.visitChildren(self)




    def unaryArithmeticOperator(self):

        localctx = NeoBasicParser.UnaryArithmeticOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 586, self.RULE_unaryArithmeticOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2579
            _la = self._input.LA(1)
            if not(((((_la - 283)) & ~0x3f) == 0 and ((1 << (_la - 283)) & 127) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryLogicalOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOT(self):
            return self.getToken(NeoBasicParser.NOT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_unaryLogicalOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryLogicalOperator" ):
                listener.enterUnaryLogicalOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryLogicalOperator" ):
                listener.exitUnaryLogicalOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryLogicalOperator" ):
                return visitor.visitUnaryLogicalOperator(self)
            else:
                return visitor.visitChildren(self)




    def unaryLogicalOperator(self):

        localctx = NeoBasicParser.UnaryLogicalOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 588, self.RULE_unaryLogicalOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2581
            self.match(NeoBasicParser.NOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryArrayOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEL(self):
            return self.getToken(NeoBasicParser.DEL, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_unaryArrayOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryArrayOperator" ):
                listener.enterUnaryArrayOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryArrayOperator" ):
                listener.exitUnaryArrayOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryArrayOperator" ):
                return visitor.visitUnaryArrayOperator(self)
            else:
                return visitor.visitChildren(self)




    def unaryArrayOperator(self):

        localctx = NeoBasicParser.UnaryArrayOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 590, self.RULE_unaryArrayOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2583
            self.match(NeoBasicParser.DEL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnarySpreadOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELLIPSIS(self):
            return self.getToken(NeoBasicParser.ELLIPSIS, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_unarySpreadOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnarySpreadOperator" ):
                listener.enterUnarySpreadOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnarySpreadOperator" ):
                listener.exitUnarySpreadOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnarySpreadOperator" ):
                return visitor.visitUnarySpreadOperator(self)
            else:
                return visitor.visitChildren(self)




    def unarySpreadOperator(self):

        localctx = NeoBasicParser.UnarySpreadOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 592, self.RULE_unarySpreadOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2585
            self.match(NeoBasicParser.ELLIPSIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryCloneOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEW(self):
            return self.getToken(NeoBasicParser.NEW, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_unaryCloneOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryCloneOperator" ):
                listener.enterUnaryCloneOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryCloneOperator" ):
                listener.exitUnaryCloneOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryCloneOperator" ):
                return visitor.visitUnaryCloneOperator(self)
            else:
                return visitor.visitChildren(self)




    def unaryCloneOperator(self):

        localctx = NeoBasicParser.UnaryCloneOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 594, self.RULE_unaryCloneOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2587
            self.match(NeoBasicParser.NEW)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryMoveOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAB(self):
            return self.getToken(NeoBasicParser.NAB, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_unaryMoveOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryMoveOperator" ):
                listener.enterUnaryMoveOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryMoveOperator" ):
                listener.exitUnaryMoveOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryMoveOperator" ):
                return visitor.visitUnaryMoveOperator(self)
            else:
                return visitor.visitChildren(self)




    def unaryMoveOperator(self):

        localctx = NeoBasicParser.UnaryMoveOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 596, self.RULE_unaryMoveOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2589
            self.match(NeoBasicParser.NAB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryMetaOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPEOF(self):
            return self.getToken(NeoBasicParser.TYPEOF, 0)

        def SIZEOF(self):
            return self.getToken(NeoBasicParser.SIZEOF, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_unaryMetaOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryMetaOperator" ):
                listener.enterUnaryMetaOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryMetaOperator" ):
                listener.exitUnaryMetaOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryMetaOperator" ):
                return visitor.visitUnaryMetaOperator(self)
            else:
                return visitor.visitChildren(self)




    def unaryMetaOperator(self):

        localctx = NeoBasicParser.UnaryMetaOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 598, self.RULE_unaryMetaOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2591
            _la = self._input.LA(1)
            if not(_la==107 or _la==108):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryArithmeticOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def binaryExponentialOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryExponentialOperatorContext,0)


        def binaryMultiplicativeOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryMultiplicativeOperatorContext,0)


        def binaryAdditiveOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryAdditiveOperatorContext,0)


        def bitShiftOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BitShiftOperatorContext,0)


        def binaryConjunctionOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryConjunctionOperatorContext,0)


        def binaryExclusiveDisjunctionOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryExclusiveDisjunctionOperatorContext,0)


        def binaryDisjunctionOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryDisjunctionOperatorContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryArithmeticOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryArithmeticOperator" ):
                listener.enterBinaryArithmeticOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryArithmeticOperator" ):
                listener.exitBinaryArithmeticOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryArithmeticOperator" ):
                return visitor.visitBinaryArithmeticOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryArithmeticOperator(self):

        localctx = NeoBasicParser.BinaryArithmeticOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 600, self.RULE_binaryArithmeticOperator)
        try:
            self.state = 2600
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [283, 284]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2593
                self.binaryExponentialOperator()
                pass
            elif token in [294, 295, 296, 297, 298, 299, 300, 301, 302, 303]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2594
                self.binaryMultiplicativeOperator()
                pass
            elif token in [288, 289]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2595
                self.binaryAdditiveOperator()
                pass
            elif token in [304, 305, 306]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2596
                self.bitShiftOperator()
                pass
            elif token in [115, 116, 117, 118]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2597
                self.binaryConjunctionOperator()
                pass
            elif token in [122, 123]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2598
                self.binaryExclusiveDisjunctionOperator()
                pass
            elif token in [119, 120, 121]:
                self.enterOuterAlt(localctx, 7)
                self.state = 2599
                self.binaryDisjunctionOperator()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryExponentialOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CARET(self):
            return self.getToken(NeoBasicParser.CARET, 0)

        def SQUARE_ROOT(self):
            return self.getToken(NeoBasicParser.SQUARE_ROOT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryExponentialOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryExponentialOperator" ):
                listener.enterBinaryExponentialOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryExponentialOperator" ):
                listener.exitBinaryExponentialOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryExponentialOperator" ):
                return visitor.visitBinaryExponentialOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryExponentialOperator(self):

        localctx = NeoBasicParser.BinaryExponentialOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 602, self.RULE_binaryExponentialOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2602
            _la = self._input.LA(1)
            if not(_la==283 or _la==284):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryMultiplicativeOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASTERISK(self):
            return self.getToken(NeoBasicParser.ASTERISK, 0)

        def SLASH(self):
            return self.getToken(NeoBasicParser.SLASH, 0)

        def DIVISION(self):
            return self.getToken(NeoBasicParser.DIVISION, 0)

        def PERCENT(self):
            return self.getToken(NeoBasicParser.PERCENT, 0)

        def QUOTIENT(self):
            return self.getToken(NeoBasicParser.QUOTIENT, 0)

        def PERCENTAGE_RATE(self):
            return self.getToken(NeoBasicParser.PERCENTAGE_RATE, 0)

        def PERCENTAGE_AMOUNT(self):
            return self.getToken(NeoBasicParser.PERCENTAGE_AMOUNT, 0)

        def PERCENTAGE_INCREASE(self):
            return self.getToken(NeoBasicParser.PERCENTAGE_INCREASE, 0)

        def PERCENTAGE_DECREASE(self):
            return self.getToken(NeoBasicParser.PERCENTAGE_DECREASE, 0)

        def PERCENTAGE_VARIATION(self):
            return self.getToken(NeoBasicParser.PERCENTAGE_VARIATION, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryMultiplicativeOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryMultiplicativeOperator" ):
                listener.enterBinaryMultiplicativeOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryMultiplicativeOperator" ):
                listener.exitBinaryMultiplicativeOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryMultiplicativeOperator" ):
                return visitor.visitBinaryMultiplicativeOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryMultiplicativeOperator(self):

        localctx = NeoBasicParser.BinaryMultiplicativeOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 604, self.RULE_binaryMultiplicativeOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2604
            _la = self._input.LA(1)
            if not(((((_la - 294)) & ~0x3f) == 0 and ((1 << (_la - 294)) & 1023) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryAdditiveOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(NeoBasicParser.PLUS, 0)

        def HYPHEN(self):
            return self.getToken(NeoBasicParser.HYPHEN, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryAdditiveOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryAdditiveOperator" ):
                listener.enterBinaryAdditiveOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryAdditiveOperator" ):
                listener.exitBinaryAdditiveOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryAdditiveOperator" ):
                return visitor.visitBinaryAdditiveOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryAdditiveOperator(self):

        localctx = NeoBasicParser.BinaryAdditiveOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 606, self.RULE_binaryAdditiveOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2606
            _la = self._input.LA(1)
            if not(_la==288 or _la==289):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BitShiftOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOUBLE_LEFT_ANGLE(self):
            return self.getToken(NeoBasicParser.DOUBLE_LEFT_ANGLE, 0)

        def DOUBLE_RIGHT_ANGLE(self):
            return self.getToken(NeoBasicParser.DOUBLE_RIGHT_ANGLE, 0)

        def UNSIGNED_RIGHT_SHIFT(self):
            return self.getToken(NeoBasicParser.UNSIGNED_RIGHT_SHIFT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_bitShiftOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitShiftOperator" ):
                listener.enterBitShiftOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitShiftOperator" ):
                listener.exitBitShiftOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBitShiftOperator" ):
                return visitor.visitBitShiftOperator(self)
            else:
                return visitor.visitChildren(self)




    def bitShiftOperator(self):

        localctx = NeoBasicParser.BitShiftOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 608, self.RULE_bitShiftOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2608
            _la = self._input.LA(1)
            if not(((((_la - 304)) & ~0x3f) == 0 and ((1 << (_la - 304)) & 7) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryConjunctionOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AND(self):
            return self.getToken(NeoBasicParser.AND, 0)

        def NSC_AND(self):
            return self.getToken(NeoBasicParser.NSC_AND, 0)

        def NOT_AND(self):
            return self.getToken(NeoBasicParser.NOT_AND, 0)

        def AND_NOT(self):
            return self.getToken(NeoBasicParser.AND_NOT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryConjunctionOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryConjunctionOperator" ):
                listener.enterBinaryConjunctionOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryConjunctionOperator" ):
                listener.exitBinaryConjunctionOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryConjunctionOperator" ):
                return visitor.visitBinaryConjunctionOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryConjunctionOperator(self):

        localctx = NeoBasicParser.BinaryConjunctionOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 610, self.RULE_binaryConjunctionOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2610
            _la = self._input.LA(1)
            if not(((((_la - 115)) & ~0x3f) == 0 and ((1 << (_la - 115)) & 15) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryExclusiveDisjunctionOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def XOR(self):
            return self.getToken(NeoBasicParser.XOR, 0)

        def NOT_XOR(self):
            return self.getToken(NeoBasicParser.NOT_XOR, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryExclusiveDisjunctionOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryExclusiveDisjunctionOperator" ):
                listener.enterBinaryExclusiveDisjunctionOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryExclusiveDisjunctionOperator" ):
                listener.exitBinaryExclusiveDisjunctionOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryExclusiveDisjunctionOperator" ):
                return visitor.visitBinaryExclusiveDisjunctionOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryExclusiveDisjunctionOperator(self):

        localctx = NeoBasicParser.BinaryExclusiveDisjunctionOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 612, self.RULE_binaryExclusiveDisjunctionOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2612
            _la = self._input.LA(1)
            if not(_la==122 or _la==123):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryDisjunctionOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OR(self):
            return self.getToken(NeoBasicParser.OR, 0)

        def NSC_OR(self):
            return self.getToken(NeoBasicParser.NSC_OR, 0)

        def NOT_OR(self):
            return self.getToken(NeoBasicParser.NOT_OR, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryDisjunctionOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryDisjunctionOperator" ):
                listener.enterBinaryDisjunctionOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryDisjunctionOperator" ):
                listener.exitBinaryDisjunctionOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryDisjunctionOperator" ):
                return visitor.visitBinaryDisjunctionOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryDisjunctionOperator(self):

        localctx = NeoBasicParser.BinaryDisjunctionOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 614, self.RULE_binaryDisjunctionOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2614
            _la = self._input.LA(1)
            if not(((((_la - 119)) & ~0x3f) == 0 and ((1 << (_la - 119)) & 7) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryArrayOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AMPERSAND(self):
            return self.getToken(NeoBasicParser.AMPERSAND, 0)

        def PIPE(self):
            return self.getToken(NeoBasicParser.PIPE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryArrayOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryArrayOperator" ):
                listener.enterBinaryArrayOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryArrayOperator" ):
                listener.exitBinaryArrayOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryArrayOperator" ):
                return visitor.visitBinaryArrayOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryArrayOperator(self):

        localctx = NeoBasicParser.BinaryArrayOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 616, self.RULE_binaryArrayOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2616
            _la = self._input.LA(1)
            if not(_la==448 or _la==451):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryComparisonOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELVIS_TEST(self):
            return self.getToken(NeoBasicParser.ELVIS_TEST, 0)

        def THREE_WAY_TEST(self):
            return self.getToken(NeoBasicParser.THREE_WAY_TEST, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryComparisonOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryComparisonOperator" ):
                listener.enterBinaryComparisonOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryComparisonOperator" ):
                listener.exitBinaryComparisonOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryComparisonOperator" ):
                return visitor.visitBinaryComparisonOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryComparisonOperator(self):

        localctx = NeoBasicParser.BinaryComparisonOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 618, self.RULE_binaryComparisonOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2618
            _la = self._input.LA(1)
            if not(_la==307 or _la==308):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryRelationalOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRICT_EQUALITY(self):
            return self.getToken(NeoBasicParser.STRICT_EQUALITY, 0)

        def STRICT_INEQUALITY(self):
            return self.getToken(NeoBasicParser.STRICT_INEQUALITY, 0)

        def LOOSE_EQUALITY(self):
            return self.getToken(NeoBasicParser.LOOSE_EQUALITY, 0)

        def LOOSE_INEQUALITY(self):
            return self.getToken(NeoBasicParser.LOOSE_INEQUALITY, 0)

        def LEFT_ANGLE(self):
            return self.getToken(NeoBasicParser.LEFT_ANGLE, 0)

        def LESS_OR_EQUALS(self):
            return self.getToken(NeoBasicParser.LESS_OR_EQUALS, 0)

        def RIGHT_ANGLE(self):
            return self.getToken(NeoBasicParser.RIGHT_ANGLE, 0)

        def GREATER_OR_EQUALS(self):
            return self.getToken(NeoBasicParser.GREATER_OR_EQUALS, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryRelationalOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryRelationalOperator" ):
                listener.enterBinaryRelationalOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryRelationalOperator" ):
                listener.exitBinaryRelationalOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryRelationalOperator" ):
                return visitor.visitBinaryRelationalOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryRelationalOperator(self):

        localctx = NeoBasicParser.BinaryRelationalOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 620, self.RULE_binaryRelationalOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2620
            _la = self._input.LA(1)
            if not(((((_la - 309)) & ~0x3f) == 0 and ((1 << (_la - 309)) & 255) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryConditionalOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IS(self):
            return self.getToken(NeoBasicParser.IS, 0)

        def IS_NOT(self):
            return self.getToken(NeoBasicParser.IS_NOT, 0)

        def NOT_IS(self):
            return self.getToken(NeoBasicParser.NOT_IS, 0)

        def IN(self):
            return self.getToken(NeoBasicParser.IN, 0)

        def NOT_IN(self):
            return self.getToken(NeoBasicParser.NOT_IN, 0)

        def BETWEEN(self):
            return self.getToken(NeoBasicParser.BETWEEN, 0)

        def NOT_BETWEEN(self):
            return self.getToken(NeoBasicParser.NOT_BETWEEN, 0)

        def LIKE(self):
            return self.getToken(NeoBasicParser.LIKE, 0)

        def NOT_LIKE(self):
            return self.getToken(NeoBasicParser.NOT_LIKE, 0)

        def DIVISIBLE_BY(self):
            return self.getToken(NeoBasicParser.DIVISIBLE_BY, 0)

        def NOT_DIVISIBLE_BY(self):
            return self.getToken(NeoBasicParser.NOT_DIVISIBLE_BY, 0)

        def INSTANCEOF(self):
            return self.getToken(NeoBasicParser.INSTANCEOF, 0)

        def NOT_INSTANCEOF(self):
            return self.getToken(NeoBasicParser.NOT_INSTANCEOF, 0)

        def ANCESTOROF(self):
            return self.getToken(NeoBasicParser.ANCESTOROF, 0)

        def NOT_ANCESTOROF(self):
            return self.getToken(NeoBasicParser.NOT_ANCESTOROF, 0)

        def EXTENDS(self):
            return self.getToken(NeoBasicParser.EXTENDS, 0)

        def NOT_EXTENDS(self):
            return self.getToken(NeoBasicParser.NOT_EXTENDS, 0)

        def IMPLEMENTS(self):
            return self.getToken(NeoBasicParser.IMPLEMENTS, 0)

        def NOT_IMPLEMENTS(self):
            return self.getToken(NeoBasicParser.NOT_IMPLEMENTS, 0)

        def MIXES(self):
            return self.getToken(NeoBasicParser.MIXES, 0)

        def NOT_MIXES(self):
            return self.getToken(NeoBasicParser.NOT_MIXES, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryConditionalOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryConditionalOperator" ):
                listener.enterBinaryConditionalOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryConditionalOperator" ):
                listener.exitBinaryConditionalOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryConditionalOperator" ):
                return visitor.visitBinaryConditionalOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryConditionalOperator(self):

        localctx = NeoBasicParser.BinaryConditionalOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 622, self.RULE_binaryConditionalOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2622
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 7696581394432) != 0) or ((((_la - 109)) & ~0x3f) == 0 and ((1 << (_la - 109)) & 63) != 0) or ((((_la - 317)) & ~0x3f) == 0 and ((1 << (_la - 317)) & 4095) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryMonadBindOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MONAD_BIND(self):
            return self.getToken(NeoBasicParser.MONAD_BIND, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryMonadBindOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryMonadBindOperator" ):
                listener.enterBinaryMonadBindOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryMonadBindOperator" ):
                listener.exitBinaryMonadBindOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryMonadBindOperator" ):
                return visitor.visitBinaryMonadBindOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryMonadBindOperator(self):

        localctx = NeoBasicParser.BinaryMonadBindOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 624, self.RULE_binaryMonadBindOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2624
            self.match(NeoBasicParser.MONAD_BIND)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryPipelineOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PIPELINE(self):
            return self.getToken(NeoBasicParser.PIPELINE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryPipelineOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryPipelineOperator" ):
                listener.enterBinaryPipelineOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryPipelineOperator" ):
                listener.exitBinaryPipelineOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryPipelineOperator" ):
                return visitor.visitBinaryPipelineOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryPipelineOperator(self):

        localctx = NeoBasicParser.BinaryPipelineOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 626, self.RULE_binaryPipelineOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2626
            self.match(NeoBasicParser.PIPELINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CoalescingOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXCLAMATION(self):
            return self.getToken(NeoBasicParser.EXCLAMATION, 0)

        def DOUBLE_EXCLAMATION(self):
            return self.getToken(NeoBasicParser.DOUBLE_EXCLAMATION, 0)

        def QUESTION(self):
            return self.getToken(NeoBasicParser.QUESTION, 0)

        def DOUBLE_QUESTION(self):
            return self.getToken(NeoBasicParser.DOUBLE_QUESTION, 0)

        def ERROR_NONE_COALESCING(self):
            return self.getToken(NeoBasicParser.ERROR_NONE_COALESCING, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_coalescingOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoalescingOperator" ):
                listener.enterCoalescingOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoalescingOperator" ):
                listener.exitCoalescingOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCoalescingOperator" ):
                return visitor.visitCoalescingOperator(self)
            else:
                return visitor.visitChildren(self)




    def coalescingOperator(self):

        localctx = NeoBasicParser.CoalescingOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 628, self.RULE_coalescingOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2628
            _la = self._input.LA(1)
            if not(((((_la - 329)) & ~0x3f) == 0 and ((1 << (_la - 329)) & 31) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExecutionFlowOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXECUTE_SEQUENCE(self):
            return self.getToken(NeoBasicParser.EXECUTE_SEQUENCE, 0)

        def EXECUTE_SEQUENCE_OKAY(self):
            return self.getToken(NeoBasicParser.EXECUTE_SEQUENCE_OKAY, 0)

        def EXECUTE_SEQUENCE_FAIL(self):
            return self.getToken(NeoBasicParser.EXECUTE_SEQUENCE_FAIL, 0)

        def EXECUTE_BACKGROUND(self):
            return self.getToken(NeoBasicParser.EXECUTE_BACKGROUND, 0)

        def OUTPUT_REDIRECTION(self):
            return self.getToken(NeoBasicParser.OUTPUT_REDIRECTION, 0)

        def APPEND_OUTPUT_REDIRECTION(self):
            return self.getToken(NeoBasicParser.APPEND_OUTPUT_REDIRECTION, 0)

        def STDOUT_REDIRECTION(self):
            return self.getToken(NeoBasicParser.STDOUT_REDIRECTION, 0)

        def APPEND_STDOUT_REDIRECTION(self):
            return self.getToken(NeoBasicParser.APPEND_STDOUT_REDIRECTION, 0)

        def STDERR_REDIRECTION(self):
            return self.getToken(NeoBasicParser.STDERR_REDIRECTION, 0)

        def APPEND_STDERR_REDIRECTION(self):
            return self.getToken(NeoBasicParser.APPEND_STDERR_REDIRECTION, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_executionFlowOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExecutionFlowOperator" ):
                listener.enterExecutionFlowOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExecutionFlowOperator" ):
                listener.exitExecutionFlowOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExecutionFlowOperator" ):
                return visitor.visitExecutionFlowOperator(self)
            else:
                return visitor.visitChildren(self)




    def executionFlowOperator(self):

        localctx = NeoBasicParser.ExecutionFlowOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 630, self.RULE_executionFlowOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2630
            _la = self._input.LA(1)
            if not(((((_la - 343)) & ~0x3f) == 0 and ((1 << (_la - 343)) & 1023) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntervalOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTERVAL_INCLUSIVE(self):
            return self.getToken(NeoBasicParser.INTERVAL_INCLUSIVE, 0)

        def INTERVAL_LEFT_EXCLUSIVE(self):
            return self.getToken(NeoBasicParser.INTERVAL_LEFT_EXCLUSIVE, 0)

        def INTERVAL_RIGHT_EXCLUSIVE(self):
            return self.getToken(NeoBasicParser.INTERVAL_RIGHT_EXCLUSIVE, 0)

        def INTERVAL_EXCLUSIVE(self):
            return self.getToken(NeoBasicParser.INTERVAL_EXCLUSIVE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_intervalOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntervalOperator" ):
                listener.enterIntervalOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntervalOperator" ):
                listener.exitIntervalOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntervalOperator" ):
                return visitor.visitIntervalOperator(self)
            else:
                return visitor.visitChildren(self)




    def intervalOperator(self):

        localctx = NeoBasicParser.IntervalOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 632, self.RULE_intervalOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2632
            _la = self._input.LA(1)
            if not(((((_la - 334)) & ~0x3f) == 0 and ((1 << (_la - 334)) & 15) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LeftIntervalOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTERVAL_INCLUSIVE(self):
            return self.getToken(NeoBasicParser.INTERVAL_INCLUSIVE, 0)

        def INTERVAL_LEFT_EXCLUSIVE(self):
            return self.getToken(NeoBasicParser.INTERVAL_LEFT_EXCLUSIVE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_leftIntervalOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLeftIntervalOperator" ):
                listener.enterLeftIntervalOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLeftIntervalOperator" ):
                listener.exitLeftIntervalOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLeftIntervalOperator" ):
                return visitor.visitLeftIntervalOperator(self)
            else:
                return visitor.visitChildren(self)




    def leftIntervalOperator(self):

        localctx = NeoBasicParser.LeftIntervalOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 634, self.RULE_leftIntervalOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2634
            _la = self._input.LA(1)
            if not(_la==334 or _la==335):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RightIntervalOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTERVAL_INCLUSIVE(self):
            return self.getToken(NeoBasicParser.INTERVAL_INCLUSIVE, 0)

        def INTERVAL_RIGHT_EXCLUSIVE(self):
            return self.getToken(NeoBasicParser.INTERVAL_RIGHT_EXCLUSIVE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_rightIntervalOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRightIntervalOperator" ):
                listener.enterRightIntervalOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRightIntervalOperator" ):
                listener.exitRightIntervalOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRightIntervalOperator" ):
                return visitor.visitRightIntervalOperator(self)
            else:
                return visitor.visitChildren(self)




    def rightIntervalOperator(self):

        localctx = NeoBasicParser.RightIntervalOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 636, self.RULE_rightIntervalOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2636
            _la = self._input.LA(1)
            if not(_la==334 or _la==336):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singleAssignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.SingleAssignmentOperatorContext,0)


        def unpackingAssignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnpackingAssignmentOperatorContext,0)


        def compoundAssignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.CompoundAssignmentOperatorContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_assignmentOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentOperator" ):
                listener.enterAssignmentOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentOperator" ):
                listener.exitAssignmentOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignmentOperator" ):
                return visitor.visitAssignmentOperator(self)
            else:
                return visitor.visitChildren(self)




    def assignmentOperator(self):

        localctx = NeoBasicParser.AssignmentOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 638, self.RULE_assignmentOperator)
        try:
            self.state = 2641
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,236,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2638
                self.singleAssignmentOperator()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2639
                self.unpackingAssignmentOperator()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2640
                self.compoundAssignmentOperator()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SingleAssignmentOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUAL(self):
            return self.getToken(NeoBasicParser.EQUAL, 0)

        def DERIVED_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.DERIVED_ASSIGNMENT, 0)

        def LAZY_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.LAZY_ASSIGNMENT, 0)

        def POP_ONE_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.POP_ONE_ASSIGNMENT, 0)

        def PULL_ALL_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.PULL_ALL_ASSIGNMENT, 0)

        def PIPE_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.PIPE_ASSIGNMENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_singleAssignmentOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSingleAssignmentOperator" ):
                listener.enterSingleAssignmentOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSingleAssignmentOperator" ):
                listener.exitSingleAssignmentOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSingleAssignmentOperator" ):
                return visitor.visitSingleAssignmentOperator(self)
            else:
                return visitor.visitChildren(self)




    def singleAssignmentOperator(self):

        localctx = NeoBasicParser.SingleAssignmentOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 640, self.RULE_singleAssignmentOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2643
            _la = self._input.LA(1)
            if not(((((_la - 353)) & ~0x3f) == 0 and ((1 << (_la - 353)) & 63) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnpackingAssignmentOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUAL(self):
            return self.getToken(NeoBasicParser.EQUAL, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_unpackingAssignmentOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnpackingAssignmentOperator" ):
                listener.enterUnpackingAssignmentOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnpackingAssignmentOperator" ):
                listener.exitUnpackingAssignmentOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnpackingAssignmentOperator" ):
                return visitor.visitUnpackingAssignmentOperator(self)
            else:
                return visitor.visitChildren(self)




    def unpackingAssignmentOperator(self):

        localctx = NeoBasicParser.UnpackingAssignmentOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 642, self.RULE_unpackingAssignmentOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2645
            self.match(NeoBasicParser.EQUAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompoundAssignmentOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NTH_POWER_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.NTH_POWER_ASSIGNMENT, 0)

        def NTH_ROOT_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.NTH_ROOT_ASSIGNMENT, 0)

        def MULTIPLICATION_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.MULTIPLICATION_ASSIGNMENT, 0)

        def REAL_DIVISION_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.REAL_DIVISION_ASSIGNMENT, 0)

        def INTEGER_DIVISION_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.INTEGER_DIVISION_ASSIGNMENT, 0)

        def MODULO_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.MODULO_ASSIGNMENT, 0)

        def QUOTIENT_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.QUOTIENT_ASSIGNMENT, 0)

        def PERCENTAGE_RATE_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.PERCENTAGE_RATE_ASSIGNMENT, 0)

        def PERCENTAGE_AMOUNT_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.PERCENTAGE_AMOUNT_ASSIGNMENT, 0)

        def PERCENTAGE_INCREASE_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.PERCENTAGE_INCREASE_ASSIGNMENT, 0)

        def PERCENTAGE_DECREASE_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.PERCENTAGE_DECREASE_ASSIGNMENT, 0)

        def PERCENTAGE_VARIATION_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.PERCENTAGE_VARIATION_ASSIGNMENT, 0)

        def ADDITION_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.ADDITION_ASSIGNMENT, 0)

        def SUBTRACTION_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.SUBTRACTION_ASSIGNMENT, 0)

        def SET_UNION_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.SET_UNION_ASSIGNMENT, 0)

        def SET_INTER_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.SET_INTER_ASSIGNMENT, 0)

        def LEFT_SHIFT_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.LEFT_SHIFT_ASSIGNMENT, 0)

        def SIGNED_RIGHT_SHIFT_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.SIGNED_RIGHT_SHIFT_ASSIGNMENT, 0)

        def UNSIGNED_RIGHT_SHIFT_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.UNSIGNED_RIGHT_SHIFT_ASSIGNMENT, 0)

        def NONE_COALESCING_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.NONE_COALESCING_ASSIGNMENT, 0)

        def SHELL_PID_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.SHELL_PID_ASSIGNMENT, 0)

        def SHELL_BKG_PID_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.SHELL_BKG_PID_ASSIGNMENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_compoundAssignmentOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompoundAssignmentOperator" ):
                listener.enterCompoundAssignmentOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompoundAssignmentOperator" ):
                listener.exitCompoundAssignmentOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompoundAssignmentOperator" ):
                return visitor.visitCompoundAssignmentOperator(self)
            else:
                return visitor.visitChildren(self)




    def compoundAssignmentOperator(self):

        localctx = NeoBasicParser.CompoundAssignmentOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 644, self.RULE_compoundAssignmentOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2647
            _la = self._input.LA(1)
            if not(((((_la - 359)) & ~0x3f) == 0 and ((1 << (_la - 359)) & 4194303) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OverloadableOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def prefixUnaryOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.PrefixUnaryOperatorContext,0)


        def binaryExponentialOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryExponentialOperatorContext,0)


        def binaryMultiplicativeOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryMultiplicativeOperatorContext,0)


        def binaryAdditiveOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryAdditiveOperatorContext,0)


        def bitShiftOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BitShiftOperatorContext,0)


        def binaryConjunctionOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryConjunctionOperatorContext,0)


        def binaryExclusiveDisjunctionOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryExclusiveDisjunctionOperatorContext,0)


        def binaryDisjunctionOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryDisjunctionOperatorContext,0)


        def binaryArrayOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryArrayOperatorContext,0)


        def binaryComparisonOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryComparisonOperatorContext,0)


        def binaryRelationalOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryRelationalOperatorContext,0)


        def binaryConditionalOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryConditionalOperatorContext,0)


        def coalescingOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.CoalescingOperatorContext,0)


        def executionFlowOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.ExecutionFlowOperatorContext,0)


        def assignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.AssignmentOperatorContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_overloadableOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOverloadableOperator" ):
                listener.enterOverloadableOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOverloadableOperator" ):
                listener.exitOverloadableOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOverloadableOperator" ):
                return visitor.visitOverloadableOperator(self)
            else:
                return visitor.visitChildren(self)




    def overloadableOperator(self):

        localctx = NeoBasicParser.OverloadableOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 646, self.RULE_overloadableOperator)
        try:
            self.state = 2664
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,237,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2649
                self.prefixUnaryOperator()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2650
                self.binaryExponentialOperator()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2651
                self.binaryMultiplicativeOperator()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2652
                self.binaryAdditiveOperator()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2653
                self.bitShiftOperator()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2654
                self.binaryConjunctionOperator()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 2655
                self.binaryExclusiveDisjunctionOperator()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 2656
                self.binaryDisjunctionOperator()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 2657
                self.binaryArrayOperator()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 2658
                self.binaryComparisonOperator()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 2659
                self.binaryRelationalOperator()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 2660
                self.binaryConditionalOperator()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 2661
                self.coalescingOperator()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 2662
                self.executionFlowOperator()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 2663
                self.assignmentOperator()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SymbolDecoratorsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbolDecorator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.SymbolDecoratorContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.SymbolDecoratorContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_symbolDecorators

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSymbolDecorators" ):
                listener.enterSymbolDecorators(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSymbolDecorators" ):
                listener.exitSymbolDecorators(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSymbolDecorators" ):
                return visitor.visitSymbolDecorators(self)
            else:
                return visitor.visitChildren(self)




    def symbolDecorators(self):

        localctx = NeoBasicParser.SymbolDecoratorsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 648, self.RULE_symbolDecorators)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2666
            self.symbolDecorator()
            self.state = 2673
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,239,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2668
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==439:
                        self.state = 2667
                        self.match(NeoBasicParser.COMMA)


                    self.state = 2670
                    self.symbolDecorator() 
                self.state = 2675
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,239,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SymbolDecoratorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotationDecorator(self):
            return self.getTypedRuleContext(NeoBasicParser.AnnotationDecoratorContext,0)


        def aspectDecorator(self):
            return self.getTypedRuleContext(NeoBasicParser.AspectDecoratorContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_symbolDecorator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSymbolDecorator" ):
                listener.enterSymbolDecorator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSymbolDecorator" ):
                listener.exitSymbolDecorator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSymbolDecorator" ):
                return visitor.visitSymbolDecorator(self)
            else:
                return visitor.visitChildren(self)




    def symbolDecorator(self):

        localctx = NeoBasicParser.SymbolDecoratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 650, self.RULE_symbolDecorator)
        try:
            self.state = 2678
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [382]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2676
                self.annotationDecorator()
                pass
            elif token in [383]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2677
                self.aspectDecorator()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AnnotationDecoratorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATOM_IDENTIFIER(self):
            return self.getToken(NeoBasicParser.ATOM_IDENTIFIER, 0)

        def taggedValuePairs(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.TaggedValuePairsContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.TaggedValuePairsContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_annotationDecorator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotationDecorator" ):
                listener.enterAnnotationDecorator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotationDecorator" ):
                listener.exitAnnotationDecorator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnnotationDecorator" ):
                return visitor.visitAnnotationDecorator(self)
            else:
                return visitor.visitChildren(self)




    def annotationDecorator(self):

        localctx = NeoBasicParser.AnnotationDecoratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 652, self.RULE_annotationDecorator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2680
            self.match(NeoBasicParser.ATOM_IDENTIFIER)
            self.state = 2684
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,241,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2681
                    self.taggedValuePairs() 
                self.state = 2686
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,241,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AspectDecoratorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASPECT_IDENTIFIER(self):
            return self.getToken(NeoBasicParser.ASPECT_IDENTIFIER, 0)

        def taggedValuePairs(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.TaggedValuePairsContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.TaggedValuePairsContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_aspectDecorator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAspectDecorator" ):
                listener.enterAspectDecorator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAspectDecorator" ):
                listener.exitAspectDecorator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAspectDecorator" ):
                return visitor.visitAspectDecorator(self)
            else:
                return visitor.visitChildren(self)




    def aspectDecorator(self):

        localctx = NeoBasicParser.AspectDecoratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 654, self.RULE_aspectDecorator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2687
            self.match(NeoBasicParser.ASPECT_IDENTIFIER)
            self.state = 2691
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,242,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2688
                    self.taggedValuePairs() 
                self.state = 2693
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,242,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaggedValuePairsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def taggedValuePair(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.TaggedValuePairContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.TaggedValuePairContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_taggedValuePairs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaggedValuePairs" ):
                listener.enterTaggedValuePairs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaggedValuePairs" ):
                listener.exitTaggedValuePairs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTaggedValuePairs" ):
                return visitor.visitTaggedValuePairs(self)
            else:
                return visitor.visitChildren(self)




    def taggedValuePairs(self):

        localctx = NeoBasicParser.TaggedValuePairsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 656, self.RULE_taggedValuePairs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2694
            self.taggedValuePair()
            self.state = 2699
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,243,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2695
                    self.match(NeoBasicParser.COMMA)
                    self.state = 2696
                    self.taggedValuePair() 
                self.state = 2701
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,243,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaggedValuePairContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def IDENTIFIER(self):
            return self.getToken(NeoBasicParser.IDENTIFIER, 0)

        def EQUAL(self):
            return self.getToken(NeoBasicParser.EQUAL, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_taggedValuePair

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaggedValuePair" ):
                listener.enterTaggedValuePair(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaggedValuePair" ):
                listener.exitTaggedValuePair(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTaggedValuePair" ):
                return visitor.visitTaggedValuePair(self)
            else:
                return visitor.visitChildren(self)




    def taggedValuePair(self):

        localctx = NeoBasicParser.TaggedValuePairContext(self, self._ctx, self.state)
        self.enterRule(localctx, 658, self.RULE_taggedValuePair)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2704
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,244,self._ctx)
            if la_ == 1:
                self.state = 2702
                self.match(NeoBasicParser.IDENTIFIER)
                self.state = 2703
                self.match(NeoBasicParser.EQUAL)


            self.state = 2706
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenericTypeParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_ANGLE(self):
            return self.getToken(NeoBasicParser.LEFT_ANGLE, 0)

        def typeParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeParametersContext,0)


        def RIGHT_ANGLE(self):
            return self.getToken(NeoBasicParser.RIGHT_ANGLE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_genericTypeParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenericTypeParameters" ):
                listener.enterGenericTypeParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenericTypeParameters" ):
                listener.exitGenericTypeParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenericTypeParameters" ):
                return visitor.visitGenericTypeParameters(self)
            else:
                return visitor.visitChildren(self)




    def genericTypeParameters(self):

        localctx = NeoBasicParser.GenericTypeParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 660, self.RULE_genericTypeParameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2708
            self.match(NeoBasicParser.LEFT_ANGLE)
            self.state = 2709
            self.typeParameters()
            self.state = 2710
            self.match(NeoBasicParser.RIGHT_ANGLE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.TypeParameterContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.TypeParameterContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_typeParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeParameters" ):
                listener.enterTypeParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeParameters" ):
                listener.exitTypeParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeParameters" ):
                return visitor.visitTypeParameters(self)
            else:
                return visitor.visitChildren(self)




    def typeParameters(self):

        localctx = NeoBasicParser.TypeParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 662, self.RULE_typeParameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2712
            self.typeParameter()
            self.state = 2717
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==439:
                self.state = 2713
                self.match(NeoBasicParser.COMMA)
                self.state = 2714
                self.typeParameter()
                self.state = 2719
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.TypeContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.TypeContext,i)


        def IS(self):
            return self.getToken(NeoBasicParser.IS, 0)

        def ANCESTOROF(self):
            return self.getToken(NeoBasicParser.ANCESTOROF, 0)

        def EXTENDS(self):
            return self.getToken(NeoBasicParser.EXTENDS, 0)

        def IMPLEMENTS(self):
            return self.getToken(NeoBasicParser.IMPLEMENTS, 0)

        def MIXES(self):
            return self.getToken(NeoBasicParser.MIXES, 0)

        def LIFETIME(self):
            return self.getToken(NeoBasicParser.LIFETIME, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_typeParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeParameter" ):
                listener.enterTypeParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeParameter" ):
                listener.exitTypeParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeParameter" ):
                return visitor.visitTypeParameter(self)
            else:
                return visitor.visitChildren(self)




    def typeParameter(self):

        localctx = NeoBasicParser.TypeParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 664, self.RULE_typeParameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2720
            self.type_(0)
            self.state = 2723
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 7696581394432) != 0) or _la==110 or _la==111 or _la==291:
                self.state = 2721
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 7696581394432) != 0) or _la==110 or _la==111 or _la==291):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2722
                self.type_(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.TypeContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.TypeContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_types

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypes" ):
                listener.enterTypes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypes" ):
                listener.exitTypes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypes" ):
                return visitor.visitTypes(self)
            else:
                return visitor.visitChildren(self)




    def types(self):

        localctx = NeoBasicParser.TypesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 666, self.RULE_types)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2725
            self.type_(0)
            self.state = 2730
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,247,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2726
                    self.match(NeoBasicParser.COMMA)
                    self.state = 2727
                    self.type_(0) 
                self.state = 2732
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,247,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def prefixTypeModifier(self):
            return self.getTypedRuleContext(NeoBasicParser.PrefixTypeModifierContext,0)


        def type_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.TypeContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.TypeContext,i)


        def nativeType(self):
            return self.getTypedRuleContext(NeoBasicParser.NativeTypeContext,0)


        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def AND(self):
            return self.getToken(NeoBasicParser.AND, 0)

        def OR(self):
            return self.getToken(NeoBasicParser.OR, 0)

        def XOR(self):
            return self.getToken(NeoBasicParser.XOR, 0)

        def LIFETIME(self):
            return self.getToken(NeoBasicParser.LIFETIME, 0)

        def postfixTypeWrapper(self):
            return self.getTypedRuleContext(NeoBasicParser.PostfixTypeWrapperContext,0)


        def genericTypeParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.GenericTypeParametersContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType" ):
                listener.enterType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType" ):
                listener.exitType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType" ):
                return visitor.visitType(self)
            else:
                return visitor.visitChildren(self)



    def type_(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = NeoBasicParser.TypeContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 668
        self.enterRecursionRule(localctx, 668, self.RULE_type, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2739
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [434]:
                self.state = 2734
                self.prefixTypeModifier()
                self.state = 2735
                self.type_(9)
                pass
            elif token in [4, 5, 6, 13, 17, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 45, 46, 47, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 259, 262, 265, 268]:
                self.state = 2737
                self.nativeType()
                pass
            elif token in [381]:
                self.state = 2738
                self.qualifiedIdentifier()
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 2759
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,250,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 2757
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,249,self._ctx)
                    if la_ == 1:
                        localctx = NeoBasicParser.TypeContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_type)
                        self.state = 2741
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 2742
                        self.match(NeoBasicParser.AND)
                        self.state = 2743
                        self.type_(7)
                        pass

                    elif la_ == 2:
                        localctx = NeoBasicParser.TypeContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_type)
                        self.state = 2744
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 2745
                        self.match(NeoBasicParser.OR)
                        self.state = 2746
                        self.type_(6)
                        pass

                    elif la_ == 3:
                        localctx = NeoBasicParser.TypeContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_type)
                        self.state = 2747
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 2748
                        self.match(NeoBasicParser.XOR)
                        self.state = 2749
                        self.type_(5)
                        pass

                    elif la_ == 4:
                        localctx = NeoBasicParser.TypeContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_type)
                        self.state = 2750
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 2751
                        self.match(NeoBasicParser.LIFETIME)
                        self.state = 2752
                        self.type_(4)
                        pass

                    elif la_ == 5:
                        localctx = NeoBasicParser.TypeContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_type)
                        self.state = 2753
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 2754
                        self.postfixTypeWrapper()
                        pass

                    elif la_ == 6:
                        localctx = NeoBasicParser.TypeContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_type)
                        self.state = 2755
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 2756
                        self.genericTypeParameters()
                        pass

             
                self.state = 2761
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,250,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class PrefixTypeModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_BRACKET(self):
            return self.getToken(NeoBasicParser.LEFT_BRACKET, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def RIGHT_BRACKET(self):
            return self.getToken(NeoBasicParser.RIGHT_BRACKET, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_prefixTypeModifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrefixTypeModifier" ):
                listener.enterPrefixTypeModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrefixTypeModifier" ):
                listener.exitPrefixTypeModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrefixTypeModifier" ):
                return visitor.visitPrefixTypeModifier(self)
            else:
                return visitor.visitChildren(self)




    def prefixTypeModifier(self):

        localctx = NeoBasicParser.PrefixTypeModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 670, self.RULE_prefixTypeModifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2762
            self.match(NeoBasicParser.LEFT_BRACKET)
            self.state = 2763
            self.expressions()
            self.state = 2764
            self.match(NeoBasicParser.RIGHT_BRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PostfixTypeWrapperContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXCLAMATION(self):
            return self.getToken(NeoBasicParser.EXCLAMATION, 0)

        def QUESTION(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.QUESTION)
            else:
                return self.getToken(NeoBasicParser.QUESTION, i)

        def PIPE(self):
            return self.getToken(NeoBasicParser.PIPE, 0)

        def RIGHT_ANGLE(self):
            return self.getToken(NeoBasicParser.RIGHT_ANGLE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_postfixTypeWrapper

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPostfixTypeWrapper" ):
                listener.enterPostfixTypeWrapper(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPostfixTypeWrapper" ):
                listener.exitPostfixTypeWrapper(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPostfixTypeWrapper" ):
                return visitor.visitPostfixTypeWrapper(self)
            else:
                return visitor.visitChildren(self)




    def postfixTypeWrapper(self):

        localctx = NeoBasicParser.PostfixTypeWrapperContext(self, self._ctx, self.state)
        self.enterRule(localctx, 672, self.RULE_postfixTypeWrapper)
        try:
            self.state = 2780
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,251,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2766
                self.match(NeoBasicParser.EXCLAMATION)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2767
                self.match(NeoBasicParser.QUESTION)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2768
                self.match(NeoBasicParser.QUESTION)
                self.state = 2769
                self.match(NeoBasicParser.QUESTION)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2770
                self.match(NeoBasicParser.PIPE)
                self.state = 2771
                self.match(NeoBasicParser.RIGHT_ANGLE)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2772
                self.match(NeoBasicParser.EXCLAMATION)
                self.state = 2773
                self.match(NeoBasicParser.QUESTION)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2774
                self.match(NeoBasicParser.EXCLAMATION)
                self.state = 2775
                self.match(NeoBasicParser.QUESTION)
                self.state = 2776
                self.match(NeoBasicParser.QUESTION)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 2777
                self.match(NeoBasicParser.EXCLAMATION)
                self.state = 2778
                self.match(NeoBasicParser.PIPE)
                self.state = 2779
                self.match(NeoBasicParser.RIGHT_ANGLE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NativeTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def escalarType(self):
            return self.getTypedRuleContext(NeoBasicParser.EscalarTypeContext,0)


        def compoundType(self):
            return self.getTypedRuleContext(NeoBasicParser.CompoundTypeContext,0)


        def optionType(self):
            return self.getTypedRuleContext(NeoBasicParser.OptionTypeContext,0)


        def metaType(self):
            return self.getTypedRuleContext(NeoBasicParser.MetaTypeContext,0)


        def procType(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_nativeType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNativeType" ):
                listener.enterNativeType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNativeType" ):
                listener.exitNativeType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNativeType" ):
                return visitor.visitNativeType(self)
            else:
                return visitor.visitChildren(self)




    def nativeType(self):

        localctx = NeoBasicParser.NativeTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 674, self.RULE_nativeType)
        try:
            self.state = 2787
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2782
                self.escalarType()
                pass
            elif token in [190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2783
                self.compoundType()
                pass
            elif token in [259, 262, 265, 268]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2784
                self.optionType()
                pass
            elif token in [4, 5, 6, 13, 17, 34, 35, 36, 37, 38, 39, 45, 128, 129, 130, 131, 132]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2785
                self.metaType()
                pass
            elif token in [21, 22, 23, 24, 25, 32, 33, 46, 47]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2786
                self.procType()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EscalarTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanType(self):
            return self.getTypedRuleContext(NeoBasicParser.BooleanTypeContext,0)


        def numericType(self):
            return self.getTypedRuleContext(NeoBasicParser.NumericTypeContext,0)


        def temporalType(self):
            return self.getTypedRuleContext(NeoBasicParser.TemporalTypeContext,0)


        def characterType(self):
            return self.getTypedRuleContext(NeoBasicParser.CharacterTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_escalarType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEscalarType" ):
                listener.enterEscalarType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEscalarType" ):
                listener.exitEscalarType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEscalarType" ):
                return visitor.visitEscalarType(self)
            else:
                return visitor.visitChildren(self)




    def escalarType(self):

        localctx = NeoBasicParser.EscalarTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 676, self.RULE_escalarType)
        try:
            self.state = 2793
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [133, 134, 135, 136, 137, 138]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2789
                self.booleanType()
                pass
            elif token in [139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2790
                self.numericType()
                pass
            elif token in [182, 183]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2791
                self.temporalType()
                pass
            elif token in [184, 185, 186, 187, 188, 189]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2792
                self.characterType()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOL8(self):
            return self.getToken(NeoBasicParser.BOOL8, 0)

        def BOOL16(self):
            return self.getToken(NeoBasicParser.BOOL16, 0)

        def BOOL32(self):
            return self.getToken(NeoBasicParser.BOOL32, 0)

        def BOOL64(self):
            return self.getToken(NeoBasicParser.BOOL64, 0)

        def BOOL128(self):
            return self.getToken(NeoBasicParser.BOOL128, 0)

        def BOOL(self):
            return self.getToken(NeoBasicParser.BOOL, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_booleanType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanType" ):
                listener.enterBooleanType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanType" ):
                listener.exitBooleanType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanType" ):
                return visitor.visitBooleanType(self)
            else:
                return visitor.visitChildren(self)




    def booleanType(self):

        localctx = NeoBasicParser.BooleanTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 678, self.RULE_booleanType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2795
            _la = self._input.LA(1)
            if not(((((_la - 133)) & ~0x3f) == 0 and ((1 << (_la - 133)) & 63) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numericNatural(self):
            return self.getTypedRuleContext(NeoBasicParser.NumericNaturalContext,0)


        def numericInteger(self):
            return self.getTypedRuleContext(NeoBasicParser.NumericIntegerContext,0)


        def numericReal(self):
            return self.getTypedRuleContext(NeoBasicParser.NumericRealContext,0)


        def numericDecimal(self):
            return self.getTypedRuleContext(NeoBasicParser.NumericDecimalContext,0)


        def numericRatio(self):
            return self.getTypedRuleContext(NeoBasicParser.NumericRatioContext,0)


        def numericComplex(self):
            return self.getTypedRuleContext(NeoBasicParser.NumericComplexContext,0)


        def numericQuaternion(self):
            return self.getTypedRuleContext(NeoBasicParser.NumericQuaternionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_numericType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericType" ):
                listener.enterNumericType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericType" ):
                listener.exitNumericType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericType" ):
                return visitor.visitNumericType(self)
            else:
                return visitor.visitChildren(self)




    def numericType(self):

        localctx = NeoBasicParser.NumericTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 680, self.RULE_numericType)
        try:
            self.state = 2804
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [139, 140, 141, 142, 143, 144, 145, 146]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2797
                self.numericNatural()
                pass
            elif token in [147, 148, 149, 150, 151, 152, 153]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2798
                self.numericInteger()
                pass
            elif token in [154, 155, 156, 157, 158, 159, 160]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2799
                self.numericReal()
                pass
            elif token in [161, 162, 163, 164, 165, 166, 167]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2800
                self.numericDecimal()
                pass
            elif token in [168, 169, 170, 171, 172, 173]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2801
                self.numericRatio()
                pass
            elif token in [174, 175, 176, 177]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2802
                self.numericComplex()
                pass
            elif token in [178, 179, 180, 181]:
                self.enterOuterAlt(localctx, 7)
                self.state = 2803
                self.numericQuaternion()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericNaturalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BYTE(self):
            return self.getToken(NeoBasicParser.BYTE, 0)

        def NAT8(self):
            return self.getToken(NeoBasicParser.NAT8, 0)

        def NAT16(self):
            return self.getToken(NeoBasicParser.NAT16, 0)

        def NAT32(self):
            return self.getToken(NeoBasicParser.NAT32, 0)

        def NAT64(self):
            return self.getToken(NeoBasicParser.NAT64, 0)

        def NAT128(self):
            return self.getToken(NeoBasicParser.NAT128, 0)

        def NATURAL(self):
            return self.getToken(NeoBasicParser.NATURAL, 0)

        def BIGNATURAL(self):
            return self.getToken(NeoBasicParser.BIGNATURAL, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_numericNatural

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericNatural" ):
                listener.enterNumericNatural(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericNatural" ):
                listener.exitNumericNatural(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericNatural" ):
                return visitor.visitNumericNatural(self)
            else:
                return visitor.visitChildren(self)




    def numericNatural(self):

        localctx = NeoBasicParser.NumericNaturalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 682, self.RULE_numericNatural)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2806
            _la = self._input.LA(1)
            if not(((((_la - 139)) & ~0x3f) == 0 and ((1 << (_la - 139)) & 255) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericIntegerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT8(self):
            return self.getToken(NeoBasicParser.INT8, 0)

        def INT16(self):
            return self.getToken(NeoBasicParser.INT16, 0)

        def INT32(self):
            return self.getToken(NeoBasicParser.INT32, 0)

        def INT64(self):
            return self.getToken(NeoBasicParser.INT64, 0)

        def INT128(self):
            return self.getToken(NeoBasicParser.INT128, 0)

        def INT(self):
            return self.getToken(NeoBasicParser.INT, 0)

        def BIGINT(self):
            return self.getToken(NeoBasicParser.BIGINT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_numericInteger

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericInteger" ):
                listener.enterNumericInteger(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericInteger" ):
                listener.exitNumericInteger(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericInteger" ):
                return visitor.visitNumericInteger(self)
            else:
                return visitor.visitChildren(self)




    def numericInteger(self):

        localctx = NeoBasicParser.NumericIntegerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 684, self.RULE_numericInteger)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2808
            _la = self._input.LA(1)
            if not(((((_la - 147)) & ~0x3f) == 0 and ((1 << (_la - 147)) & 127) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericDecimalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEC8(self):
            return self.getToken(NeoBasicParser.DEC8, 0)

        def DEC16(self):
            return self.getToken(NeoBasicParser.DEC16, 0)

        def DEC32(self):
            return self.getToken(NeoBasicParser.DEC32, 0)

        def DEC64(self):
            return self.getToken(NeoBasicParser.DEC64, 0)

        def DEC128(self):
            return self.getToken(NeoBasicParser.DEC128, 0)

        def DECIMAL(self):
            return self.getToken(NeoBasicParser.DECIMAL, 0)

        def MONEY(self):
            return self.getToken(NeoBasicParser.MONEY, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_numericDecimal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericDecimal" ):
                listener.enterNumericDecimal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericDecimal" ):
                listener.exitNumericDecimal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericDecimal" ):
                return visitor.visitNumericDecimal(self)
            else:
                return visitor.visitChildren(self)




    def numericDecimal(self):

        localctx = NeoBasicParser.NumericDecimalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 686, self.RULE_numericDecimal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2810
            _la = self._input.LA(1)
            if not(((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & 127) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericRealContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REAL8(self):
            return self.getToken(NeoBasicParser.REAL8, 0)

        def REAL16(self):
            return self.getToken(NeoBasicParser.REAL16, 0)

        def REAL32(self):
            return self.getToken(NeoBasicParser.REAL32, 0)

        def REAL64(self):
            return self.getToken(NeoBasicParser.REAL64, 0)

        def REAL128(self):
            return self.getToken(NeoBasicParser.REAL128, 0)

        def REAL(self):
            return self.getToken(NeoBasicParser.REAL, 0)

        def BIGREAL(self):
            return self.getToken(NeoBasicParser.BIGREAL, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_numericReal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericReal" ):
                listener.enterNumericReal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericReal" ):
                listener.exitNumericReal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericReal" ):
                return visitor.visitNumericReal(self)
            else:
                return visitor.visitChildren(self)




    def numericReal(self):

        localctx = NeoBasicParser.NumericRealContext(self, self._ctx, self.state)
        self.enterRule(localctx, 688, self.RULE_numericReal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2812
            _la = self._input.LA(1)
            if not(((((_la - 154)) & ~0x3f) == 0 and ((1 << (_la - 154)) & 127) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericRatioContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RATIO8(self):
            return self.getToken(NeoBasicParser.RATIO8, 0)

        def RATIO16(self):
            return self.getToken(NeoBasicParser.RATIO16, 0)

        def RATIO32(self):
            return self.getToken(NeoBasicParser.RATIO32, 0)

        def RATIO64(self):
            return self.getToken(NeoBasicParser.RATIO64, 0)

        def RATIO128(self):
            return self.getToken(NeoBasicParser.RATIO128, 0)

        def RATIO(self):
            return self.getToken(NeoBasicParser.RATIO, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_numericRatio

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericRatio" ):
                listener.enterNumericRatio(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericRatio" ):
                listener.exitNumericRatio(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericRatio" ):
                return visitor.visitNumericRatio(self)
            else:
                return visitor.visitChildren(self)




    def numericRatio(self):

        localctx = NeoBasicParser.NumericRatioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 690, self.RULE_numericRatio)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2814
            _la = self._input.LA(1)
            if not(((((_la - 168)) & ~0x3f) == 0 and ((1 << (_la - 168)) & 63) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericComplexContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMPLEX32(self):
            return self.getToken(NeoBasicParser.COMPLEX32, 0)

        def COMPLEX64(self):
            return self.getToken(NeoBasicParser.COMPLEX64, 0)

        def COMPLEX128(self):
            return self.getToken(NeoBasicParser.COMPLEX128, 0)

        def COMPLEX(self):
            return self.getToken(NeoBasicParser.COMPLEX, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_numericComplex

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericComplex" ):
                listener.enterNumericComplex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericComplex" ):
                listener.exitNumericComplex(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericComplex" ):
                return visitor.visitNumericComplex(self)
            else:
                return visitor.visitChildren(self)




    def numericComplex(self):

        localctx = NeoBasicParser.NumericComplexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 692, self.RULE_numericComplex)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2816
            _la = self._input.LA(1)
            if not(((((_la - 174)) & ~0x3f) == 0 and ((1 << (_la - 174)) & 15) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericQuaternionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QUATERN32(self):
            return self.getToken(NeoBasicParser.QUATERN32, 0)

        def QUATERN64(self):
            return self.getToken(NeoBasicParser.QUATERN64, 0)

        def QUATERN128(self):
            return self.getToken(NeoBasicParser.QUATERN128, 0)

        def QUATERN(self):
            return self.getToken(NeoBasicParser.QUATERN, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_numericQuaternion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericQuaternion" ):
                listener.enterNumericQuaternion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericQuaternion" ):
                listener.exitNumericQuaternion(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericQuaternion" ):
                return visitor.visitNumericQuaternion(self)
            else:
                return visitor.visitChildren(self)




    def numericQuaternion(self):

        localctx = NeoBasicParser.NumericQuaternionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 694, self.RULE_numericQuaternion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2818
            _la = self._input.LA(1)
            if not(((((_la - 178)) & ~0x3f) == 0 and ((1 << (_la - 178)) & 15) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TemporalTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELAPSE(self):
            return self.getToken(NeoBasicParser.ELAPSE, 0)

        def DATE(self):
            return self.getToken(NeoBasicParser.DATE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_temporalType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemporalType" ):
                listener.enterTemporalType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemporalType" ):
                listener.exitTemporalType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTemporalType" ):
                return visitor.visitTemporalType(self)
            else:
                return visitor.visitChildren(self)




    def temporalType(self):

        localctx = NeoBasicParser.TemporalTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 696, self.RULE_temporalType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2820
            _la = self._input.LA(1)
            if not(_la==182 or _la==183):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CharacterTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASCII(self):
            return self.getToken(NeoBasicParser.ASCII, 0)

        def WCHAR(self):
            return self.getToken(NeoBasicParser.WCHAR, 0)

        def CHAR8(self):
            return self.getToken(NeoBasicParser.CHAR8, 0)

        def CHAR16(self):
            return self.getToken(NeoBasicParser.CHAR16, 0)

        def CHAR32(self):
            return self.getToken(NeoBasicParser.CHAR32, 0)

        def CHAR(self):
            return self.getToken(NeoBasicParser.CHAR, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_characterType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCharacterType" ):
                listener.enterCharacterType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCharacterType" ):
                listener.exitCharacterType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCharacterType" ):
                return visitor.visitCharacterType(self)
            else:
                return visitor.visitChildren(self)




    def characterType(self):

        localctx = NeoBasicParser.CharacterTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 698, self.RULE_characterType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2822
            _la = self._input.LA(1)
            if not(((((_la - 184)) & ~0x3f) == 0 and ((1 << (_la - 184)) & 63) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompoundTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sequenceType(self):
            return self.getTypedRuleContext(NeoBasicParser.SequenceTypeContext,0)


        def compositeType(self):
            return self.getTypedRuleContext(NeoBasicParser.CompositeTypeContext,0)


        def collectionType(self):
            return self.getTypedRuleContext(NeoBasicParser.CollectionTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_compoundType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompoundType" ):
                listener.enterCompoundType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompoundType" ):
                listener.exitCompoundType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompoundType" ):
                return visitor.visitCompoundType(self)
            else:
                return visitor.visitChildren(self)




    def compoundType(self):

        localctx = NeoBasicParser.CompoundTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 700, self.RULE_compoundType)
        try:
            self.state = 2827
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [190, 191, 192, 193, 194, 195, 196, 197]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2824
                self.sequenceType()
                pass
            elif token in [198, 199, 200, 201, 202, 203]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2825
                self.compositeType()
                pass
            elif token in [204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2826
                self.collectionType()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SequenceTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ANSI(self):
            return self.getToken(NeoBasicParser.ANSI, 0)

        def WSTR(self):
            return self.getToken(NeoBasicParser.WSTR, 0)

        def STRING8(self):
            return self.getToken(NeoBasicParser.STRING8, 0)

        def STRING16(self):
            return self.getToken(NeoBasicParser.STRING16, 0)

        def STRING32(self):
            return self.getToken(NeoBasicParser.STRING32, 0)

        def STRING(self):
            return self.getToken(NeoBasicParser.STRING, 0)

        def REGEX(self):
            return self.getToken(NeoBasicParser.REGEX, 0)

        def BINARY(self):
            return self.getToken(NeoBasicParser.BINARY, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_sequenceType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSequenceType" ):
                listener.enterSequenceType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSequenceType" ):
                listener.exitSequenceType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSequenceType" ):
                return visitor.visitSequenceType(self)
            else:
                return visitor.visitChildren(self)




    def sequenceType(self):

        localctx = NeoBasicParser.SequenceTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 702, self.RULE_sequenceType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2829
            _la = self._input.LA(1)
            if not(((((_la - 190)) & ~0x3f) == 0 and ((1 << (_la - 190)) & 255) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompositeTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RANGE(self):
            return self.getToken(NeoBasicParser.RANGE, 0)

        def PAIR(self):
            return self.getToken(NeoBasicParser.PAIR, 0)

        def TUPLE(self):
            return self.getToken(NeoBasicParser.TUPLE, 0)

        def INET(self):
            return self.getToken(NeoBasicParser.INET, 0)

        def PATH(self):
            return self.getToken(NeoBasicParser.PATH, 0)

        def URI(self):
            return self.getToken(NeoBasicParser.URI, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_compositeType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompositeType" ):
                listener.enterCompositeType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompositeType" ):
                listener.exitCompositeType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompositeType" ):
                return visitor.visitCompositeType(self)
            else:
                return visitor.visitChildren(self)




    def compositeType(self):

        localctx = NeoBasicParser.CompositeTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 704, self.RULE_compositeType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2831
            _la = self._input.LA(1)
            if not(((((_la - 198)) & ~0x3f) == 0 and ((1 << (_la - 198)) & 63) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CollectionTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ARRAY(self):
            return self.getToken(NeoBasicParser.ARRAY, 0)

        def LIST(self):
            return self.getToken(NeoBasicParser.LIST, 0)

        def MAP(self):
            return self.getToken(NeoBasicParser.MAP, 0)

        def CHANNEL(self):
            return self.getToken(NeoBasicParser.CHANNEL, 0)

        def VECTOR(self):
            return self.getToken(NeoBasicParser.VECTOR, 0)

        def MATRIX(self):
            return self.getToken(NeoBasicParser.MATRIX, 0)

        def SET(self):
            return self.getToken(NeoBasicParser.SET, 0)

        def QUEUE(self):
            return self.getToken(NeoBasicParser.QUEUE, 0)

        def DEQUE(self):
            return self.getToken(NeoBasicParser.DEQUE, 0)

        def XML(self):
            return self.getToken(NeoBasicParser.XML, 0)

        def TABLE(self):
            return self.getToken(NeoBasicParser.TABLE, 0)

        def MEMO(self):
            return self.getToken(NeoBasicParser.MEMO, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_collectionType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCollectionType" ):
                listener.enterCollectionType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCollectionType" ):
                listener.exitCollectionType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCollectionType" ):
                return visitor.visitCollectionType(self)
            else:
                return visitor.visitChildren(self)




    def collectionType(self):

        localctx = NeoBasicParser.CollectionTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 706, self.RULE_collectionType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2833
            _la = self._input.LA(1)
            if not(((((_la - 204)) & ~0x3f) == 0 and ((1 << (_la - 204)) & 4095) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OptionTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RESULT(self):
            return self.getToken(NeoBasicParser.RESULT, 0)

        def MAYBE(self):
            return self.getToken(NeoBasicParser.MAYBE, 0)

        def EITHER(self):
            return self.getToken(NeoBasicParser.EITHER, 0)

        def STREAM(self):
            return self.getToken(NeoBasicParser.STREAM, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_optionType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOptionType" ):
                listener.enterOptionType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOptionType" ):
                listener.exitOptionType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOptionType" ):
                return visitor.visitOptionType(self)
            else:
                return visitor.visitChildren(self)




    def optionType(self):

        localctx = NeoBasicParser.OptionTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 708, self.RULE_optionType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2835
            _la = self._input.LA(1)
            if not(((((_la - 259)) & ~0x3f) == 0 and ((1 << (_la - 259)) & 585) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MetaTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATOM(self):
            return self.getToken(NeoBasicParser.ATOM, 0)

        def AUTO(self):
            return self.getToken(NeoBasicParser.AUTO, 0)

        def SPAN(self):
            return self.getToken(NeoBasicParser.SPAN, 0)

        def VIEW(self):
            return self.getToken(NeoBasicParser.VIEW, 0)

        def VOID(self):
            return self.getToken(NeoBasicParser.VOID, 0)

        def APPLET(self):
            return self.getToken(NeoBasicParser.APPLET, 0)

        def MODULE(self):
            return self.getToken(NeoBasicParser.MODULE, 0)

        def NOTABENE(self):
            return self.getToken(NeoBasicParser.NOTABENE, 0)

        def INTERFACE(self):
            return self.getToken(NeoBasicParser.INTERFACE, 0)

        def TYPE(self):
            return self.getToken(NeoBasicParser.TYPE, 0)

        def ENUM(self):
            return self.getToken(NeoBasicParser.ENUM, 0)

        def STRUCT(self):
            return self.getToken(NeoBasicParser.STRUCT, 0)

        def PROTO(self):
            return self.getToken(NeoBasicParser.PROTO, 0)

        def TRAIT(self):
            return self.getToken(NeoBasicParser.TRAIT, 0)

        def CLASS(self):
            return self.getToken(NeoBasicParser.CLASS, 0)

        def OBJECT(self):
            return self.getToken(NeoBasicParser.OBJECT, 0)

        def PROPERTY(self):
            return self.getToken(NeoBasicParser.PROPERTY, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_metaType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetaType" ):
                listener.enterMetaType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetaType" ):
                listener.exitMetaType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetaType" ):
                return visitor.visitMetaType(self)
            else:
                return visitor.visitChildren(self)




    def metaType(self):

        localctx = NeoBasicParser.MetaTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 710, self.RULE_metaType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2837
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 36266703986800) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & 31) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def castType(self):
            return self.getTypedRuleContext(NeoBasicParser.CastTypeContext,0)


        def factType(self):
            return self.getTypedRuleContext(NeoBasicParser.FactTypeContext,0)


        def funcType(self):
            return self.getTypedRuleContext(NeoBasicParser.FuncTypeContext,0)


        def feedType(self):
            return self.getTypedRuleContext(NeoBasicParser.FeedTypeContext,0)


        def subType(self):
            return self.getTypedRuleContext(NeoBasicParser.SubTypeContext,0)


        def operatorType(self):
            return self.getTypedRuleContext(NeoBasicParser.OperatorTypeContext,0)


        def eventType(self):
            return self.getTypedRuleContext(NeoBasicParser.EventTypeContext,0)


        def getterType(self):
            return self.getTypedRuleContext(NeoBasicParser.GetterTypeContext,0)


        def setterType(self):
            return self.getTypedRuleContext(NeoBasicParser.SetterTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_procType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcType" ):
                listener.enterProcType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcType" ):
                listener.exitProcType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcType" ):
                return visitor.visitProcType(self)
            else:
                return visitor.visitChildren(self)




    def procType(self):

        localctx = NeoBasicParser.ProcTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 712, self.RULE_procType)
        try:
            self.state = 2848
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [21]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2839
                self.castType()
                pass
            elif token in [22]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2840
                self.factType()
                pass
            elif token in [23]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2841
                self.funcType()
                pass
            elif token in [24]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2842
                self.feedType()
                pass
            elif token in [25]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2843
                self.subType()
                pass
            elif token in [32]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2844
                self.operatorType()
                pass
            elif token in [33]:
                self.enterOuterAlt(localctx, 7)
                self.state = 2845
                self.eventType()
                pass
            elif token in [46]:
                self.enterOuterAlt(localctx, 8)
                self.state = 2846
                self.getterType()
                pass
            elif token in [47]:
                self.enterOuterAlt(localctx, 9)
                self.state = 2847
                self.setterType()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CastTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CAST(self):
            return self.getToken(NeoBasicParser.CAST, 0)

        def parenthesizedParameterTypes(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParameterTypesContext,0)


        def procResultType(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcResultTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_castType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCastType" ):
                listener.enterCastType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCastType" ):
                listener.exitCastType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCastType" ):
                return visitor.visitCastType(self)
            else:
                return visitor.visitChildren(self)




    def castType(self):

        localctx = NeoBasicParser.CastTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 714, self.RULE_castType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2850
            self.match(NeoBasicParser.CAST)
            self.state = 2851
            self.parenthesizedParameterTypes()
            self.state = 2852
            self.procResultType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FactTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FACT(self):
            return self.getToken(NeoBasicParser.FACT, 0)

        def procParameterType(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcParameterTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_factType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactType" ):
                listener.enterFactType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactType" ):
                listener.exitFactType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactType" ):
                return visitor.visitFactType(self)
            else:
                return visitor.visitChildren(self)




    def factType(self):

        localctx = NeoBasicParser.FactTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 716, self.RULE_factType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2854
            self.match(NeoBasicParser.FACT)
            self.state = 2855
            self.procParameterType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FUNC(self):
            return self.getToken(NeoBasicParser.FUNC, 0)

        def parenthesizedParameterTypes(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParameterTypesContext,0)


        def procResultType(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcResultTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_funcType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncType" ):
                listener.enterFuncType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncType" ):
                listener.exitFuncType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncType" ):
                return visitor.visitFuncType(self)
            else:
                return visitor.visitChildren(self)




    def funcType(self):

        localctx = NeoBasicParser.FuncTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 718, self.RULE_funcType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2857
            self.match(NeoBasicParser.FUNC)
            self.state = 2858
            self.parenthesizedParameterTypes()
            self.state = 2859
            self.procResultType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeedTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FEED(self):
            return self.getToken(NeoBasicParser.FEED, 0)

        def parenthesizedParameterTypes(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParameterTypesContext,0)


        def procResultType(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcResultTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_feedType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeedType" ):
                listener.enterFeedType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeedType" ):
                listener.exitFeedType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeedType" ):
                return visitor.visitFeedType(self)
            else:
                return visitor.visitChildren(self)




    def feedType(self):

        localctx = NeoBasicParser.FeedTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 720, self.RULE_feedType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2861
            self.match(NeoBasicParser.FEED)
            self.state = 2862
            self.parenthesizedParameterTypes()
            self.state = 2863
            self.procResultType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUB(self):
            return self.getToken(NeoBasicParser.SUB, 0)

        def parenthesizedParameterTypes(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParameterTypesContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_subType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubType" ):
                listener.enterSubType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubType" ):
                listener.exitSubType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubType" ):
                return visitor.visitSubType(self)
            else:
                return visitor.visitChildren(self)




    def subType(self):

        localctx = NeoBasicParser.SubTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 722, self.RULE_subType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2865
            self.match(NeoBasicParser.SUB)
            self.state = 2866
            self.parenthesizedParameterTypes()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperatorTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPERATOR(self):
            return self.getToken(NeoBasicParser.OPERATOR, 0)

        def parenthesizedParameterTypes(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParameterTypesContext,0)


        def procResultType(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcResultTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_operatorType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperatorType" ):
                listener.enterOperatorType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperatorType" ):
                listener.exitOperatorType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperatorType" ):
                return visitor.visitOperatorType(self)
            else:
                return visitor.visitChildren(self)




    def operatorType(self):

        localctx = NeoBasicParser.OperatorTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 724, self.RULE_operatorType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2868
            self.match(NeoBasicParser.OPERATOR)
            self.state = 2869
            self.parenthesizedParameterTypes()
            self.state = 2870
            self.procResultType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EventTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EVENT(self):
            return self.getToken(NeoBasicParser.EVENT, 0)

        def bracketedParameterTypes(self):
            return self.getTypedRuleContext(NeoBasicParser.BracketedParameterTypesContext,0)


        def procResultType(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcResultTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_eventType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEventType" ):
                listener.enterEventType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEventType" ):
                listener.exitEventType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEventType" ):
                return visitor.visitEventType(self)
            else:
                return visitor.visitChildren(self)




    def eventType(self):

        localctx = NeoBasicParser.EventTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 726, self.RULE_eventType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2872
            self.match(NeoBasicParser.EVENT)
            self.state = 2873
            self.bracketedParameterTypes()
            self.state = 2874
            self.procResultType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetterTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GETTER(self):
            return self.getToken(NeoBasicParser.GETTER, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_getterType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetterType" ):
                listener.enterGetterType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetterType" ):
                listener.exitGetterType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetterType" ):
                return visitor.visitGetterType(self)
            else:
                return visitor.visitChildren(self)




    def getterType(self):

        localctx = NeoBasicParser.GetterTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 728, self.RULE_getterType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2876
            self.match(NeoBasicParser.GETTER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetterTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SETTER(self):
            return self.getToken(NeoBasicParser.SETTER, 0)

        def parenthesizedParameterTypes(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParameterTypesContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_setterType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetterType" ):
                listener.enterSetterType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetterType" ):
                listener.exitSetterType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetterType" ):
                return visitor.visitSetterType(self)
            else:
                return visitor.visitChildren(self)




    def setterType(self):

        localctx = NeoBasicParser.SetterTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 730, self.RULE_setterType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2878
            self.match(NeoBasicParser.SETTER)
            self.state = 2879
            self.parenthesizedParameterTypes()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParenthesizedParameterTypesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LEFT_PARENTHESIS, 0)

        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def procParameterTypes(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcParameterTypesContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_parenthesizedParameterTypes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenthesizedParameterTypes" ):
                listener.enterParenthesizedParameterTypes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenthesizedParameterTypes" ):
                listener.exitParenthesizedParameterTypes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenthesizedParameterTypes" ):
                return visitor.visitParenthesizedParameterTypes(self)
            else:
                return visitor.visitChildren(self)




    def parenthesizedParameterTypes(self):

        localctx = NeoBasicParser.ParenthesizedParameterTypesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 732, self.RULE_parenthesizedParameterTypes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2881
            self.match(NeoBasicParser.LEFT_PARENTHESIS)
            self.state = 2883
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 247385886433392) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & -1) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & 16777215) != 0) or ((((_la - 259)) & ~0x3f) == 0 and ((1 << (_la - 259)) & 2147484233) != 0) or _la==334 or _la==381 or _la==434 or _la==441:
                self.state = 2882
                self.procParameterTypes()


            self.state = 2885
            self.match(NeoBasicParser.RIGHT_PARENTHESIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BracketedParameterTypesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_BRACKET(self):
            return self.getToken(NeoBasicParser.LEFT_BRACKET, 0)

        def RIGHT_BRACKET(self):
            return self.getToken(NeoBasicParser.RIGHT_BRACKET, 0)

        def procParameterTypes(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcParameterTypesContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_bracketedParameterTypes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBracketedParameterTypes" ):
                listener.enterBracketedParameterTypes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBracketedParameterTypes" ):
                listener.exitBracketedParameterTypes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBracketedParameterTypes" ):
                return visitor.visitBracketedParameterTypes(self)
            else:
                return visitor.visitChildren(self)




    def bracketedParameterTypes(self):

        localctx = NeoBasicParser.BracketedParameterTypesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 734, self.RULE_bracketedParameterTypes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2887
            self.match(NeoBasicParser.LEFT_BRACKET)
            self.state = 2889
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 247385886433392) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & -1) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & 16777215) != 0) or ((((_la - 259)) & ~0x3f) == 0 and ((1 << (_la - 259)) & 2147484233) != 0) or _la==334 or _la==381 or _la==434 or _la==441:
                self.state = 2888
                self.procParameterTypes()


            self.state = 2891
            self.match(NeoBasicParser.RIGHT_BRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcParameterTypesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def procParameterType(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ProcParameterTypeContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ProcParameterTypeContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_procParameterTypes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcParameterTypes" ):
                listener.enterProcParameterTypes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcParameterTypes" ):
                listener.exitProcParameterTypes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcParameterTypes" ):
                return visitor.visitProcParameterTypes(self)
            else:
                return visitor.visitChildren(self)




    def procParameterTypes(self):

        localctx = NeoBasicParser.ProcParameterTypesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 736, self.RULE_procParameterTypes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2893
            self.procParameterType()
            self.state = 2898
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==439:
                self.state = 2894
                self.match(NeoBasicParser.COMMA)
                self.state = 2895
                self.procParameterType()
                self.state = 2900
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcParameterTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def prefixParameterType(self):
            return self.getTypedRuleContext(NeoBasicParser.PrefixParameterTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_procParameterType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcParameterType" ):
                listener.enterProcParameterType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcParameterType" ):
                listener.exitProcParameterType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcParameterType" ):
                return visitor.visitProcParameterType(self)
            else:
                return visitor.visitChildren(self)




    def procParameterType(self):

        localctx = NeoBasicParser.ProcParameterTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 738, self.RULE_procParameterType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2902
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==290 or _la==334 or _la==441:
                self.state = 2901
                self.prefixParameterType()


            self.state = 2904
            self.type_(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def escalarLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.EscalarLiteralContext,0)


        def optionLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.OptionLiteralContext,0)


        def compoundLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.CompoundLiteralContext,0)


        def lambdaLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.LambdaLiteralContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteral" ):
                return visitor.visitLiteral(self)
            else:
                return visitor.visitChildren(self)




    def literal(self):

        localctx = NeoBasicParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 740, self.RULE_literal)
        try:
            self.state = 2910
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,261,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2906
                self.escalarLiteral()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2907
                self.optionLiteral()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2908
                self.compoundLiteral()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2909
                self.lambdaLiteral()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EscalarLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.BooleanLiteralContext,0)


        def numericLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.NumericLiteralContext,0)


        def elapseLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.ElapseLiteralContext,0)


        def dateLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.DateLiteralContext,0)


        def characterLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.CharacterLiteralContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_escalarLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEscalarLiteral" ):
                listener.enterEscalarLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEscalarLiteral" ):
                listener.exitEscalarLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEscalarLiteral" ):
                return visitor.visitEscalarLiteral(self)
            else:
                return visitor.visitChildren(self)




    def escalarLiteral(self):

        localctx = NeoBasicParser.EscalarLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 742, self.RULE_escalarLiteral)
        try:
            self.state = 2917
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [216, 217]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2912
                self.booleanLiteral()
                pass
            elif token in [218, 219, 220, 221, 222, 223, 224, 384, 385, 386, 387, 388, 389, 391]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2913
                self.numericLiteral()
                pass
            elif token in [390, 404]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2914
                self.elapseLiteral()
                pass
            elif token in [225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 403]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2915
                self.dateLiteral()
                pass
            elif token in [237, 239, 240, 241, 242, 243, 244, 393, 394]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2916
                self.characterLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(NeoBasicParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(NeoBasicParser.FALSE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_booleanLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanLiteral" ):
                listener.enterBooleanLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanLiteral" ):
                listener.exitBooleanLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanLiteral" ):
                return visitor.visitBooleanLiteral(self)
            else:
                return visitor.visitChildren(self)




    def booleanLiteral(self):

        localctx = NeoBasicParser.BooleanLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 744, self.RULE_booleanLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2919
            _la = self._input.LA(1)
            if not(_la==216 or _la==217):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NATURAL_LIT(self):
            return self.getToken(NeoBasicParser.NATURAL_LIT, 0)

        def INTEGER_LIT(self):
            return self.getToken(NeoBasicParser.INTEGER_LIT, 0)

        def DECIMAL_LIT(self):
            return self.getToken(NeoBasicParser.DECIMAL_LIT, 0)

        def REAL_LIT(self):
            return self.getToken(NeoBasicParser.REAL_LIT, 0)

        def RATIO_LIT(self):
            return self.getToken(NeoBasicParser.RATIO_LIT, 0)

        def IMAGINARY_LIT(self):
            return self.getToken(NeoBasicParser.IMAGINARY_LIT, 0)

        def TERM_LIT(self):
            return self.getToken(NeoBasicParser.TERM_LIT, 0)

        def NONZERO(self):
            return self.getToken(NeoBasicParser.NONZERO, 0)

        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def ZERO(self):
            return self.getToken(NeoBasicParser.ZERO, 0)

        def MINVALUE(self):
            return self.getToken(NeoBasicParser.MINVALUE, 0)

        def MAXVALUE(self):
            return self.getToken(NeoBasicParser.MAXVALUE, 0)

        def NAN(self):
            return self.getToken(NeoBasicParser.NAN, 0)

        def POSITIVEINFINITY(self):
            return self.getToken(NeoBasicParser.POSITIVEINFINITY, 0)

        def NEGATIVEINFINITY(self):
            return self.getToken(NeoBasicParser.NEGATIVEINFINITY, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_numericLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericLiteral" ):
                listener.enterNumericLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericLiteral" ):
                listener.exitNumericLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericLiteral" ):
                return visitor.visitNumericLiteral(self)
            else:
                return visitor.visitChildren(self)




    def numericLiteral(self):

        localctx = NeoBasicParser.NumericLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 746, self.RULE_numericLiteral)
        try:
            self.state = 2936
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [384]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2921
                self.match(NeoBasicParser.NATURAL_LIT)
                pass
            elif token in [385]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2922
                self.match(NeoBasicParser.INTEGER_LIT)
                pass
            elif token in [386]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2923
                self.match(NeoBasicParser.DECIMAL_LIT)
                pass
            elif token in [387]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2924
                self.match(NeoBasicParser.REAL_LIT)
                pass
            elif token in [388]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2925
                self.match(NeoBasicParser.RATIO_LIT)
                pass
            elif token in [389]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2926
                self.match(NeoBasicParser.IMAGINARY_LIT)
                pass
            elif token in [391]:
                self.enterOuterAlt(localctx, 7)
                self.state = 2927
                self.match(NeoBasicParser.TERM_LIT)
                pass
            elif token in [218]:
                self.enterOuterAlt(localctx, 8)
                self.state = 2928
                self.match(NeoBasicParser.NONZERO)
                self.state = 2929
                self.parenthesizedExpression()
                pass
            elif token in [219]:
                self.enterOuterAlt(localctx, 9)
                self.state = 2930
                self.match(NeoBasicParser.ZERO)
                pass
            elif token in [220]:
                self.enterOuterAlt(localctx, 10)
                self.state = 2931
                self.match(NeoBasicParser.MINVALUE)
                pass
            elif token in [221]:
                self.enterOuterAlt(localctx, 11)
                self.state = 2932
                self.match(NeoBasicParser.MAXVALUE)
                pass
            elif token in [222]:
                self.enterOuterAlt(localctx, 12)
                self.state = 2933
                self.match(NeoBasicParser.NAN)
                pass
            elif token in [223]:
                self.enterOuterAlt(localctx, 13)
                self.state = 2934
                self.match(NeoBasicParser.POSITIVEINFINITY)
                pass
            elif token in [224]:
                self.enterOuterAlt(localctx, 14)
                self.state = 2935
                self.match(NeoBasicParser.NEGATIVEINFINITY)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElapseLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELAPSE_LIT(self):
            return self.getToken(NeoBasicParser.ELAPSE_LIT, 0)

        def ATOM_ELAPSE_LIT(self):
            return self.getToken(NeoBasicParser.ATOM_ELAPSE_LIT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_elapseLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElapseLiteral" ):
                listener.enterElapseLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElapseLiteral" ):
                listener.exitElapseLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElapseLiteral" ):
                return visitor.visitElapseLiteral(self)
            else:
                return visitor.visitChildren(self)




    def elapseLiteral(self):

        localctx = NeoBasicParser.ElapseLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 748, self.RULE_elapseLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2938
            _la = self._input.LA(1)
            if not(_la==390 or _la==404):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATOM_DOT_LIT(self):
            return self.getToken(NeoBasicParser.ATOM_DOT_LIT, 0)

        def LOCALDATE(self):
            return self.getToken(NeoBasicParser.LOCALDATE, 0)

        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def LOCALDATETIME(self):
            return self.getToken(NeoBasicParser.LOCALDATETIME, 0)

        def OFFSETDATE(self):
            return self.getToken(NeoBasicParser.OFFSETDATE, 0)

        def OFFSETDATETIME(self):
            return self.getToken(NeoBasicParser.OFFSETDATETIME, 0)

        def ZONEDDATE(self):
            return self.getToken(NeoBasicParser.ZONEDDATE, 0)

        def ZONEDDATETIME(self):
            return self.getToken(NeoBasicParser.ZONEDDATETIME, 0)

        def TOMORROW(self):
            return self.getToken(NeoBasicParser.TOMORROW, 0)

        def TODAY(self):
            return self.getToken(NeoBasicParser.TODAY, 0)

        def NOW(self):
            return self.getToken(NeoBasicParser.NOW, 0)

        def YESTERDAY(self):
            return self.getToken(NeoBasicParser.YESTERDAY, 0)

        def EON(self):
            return self.getToken(NeoBasicParser.EON, 0)

        def EPOCH(self):
            return self.getToken(NeoBasicParser.EPOCH, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_dateLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDateLiteral" ):
                listener.enterDateLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDateLiteral" ):
                listener.exitDateLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDateLiteral" ):
                return visitor.visitDateLiteral(self)
            else:
                return visitor.visitChildren(self)




    def dateLiteral(self):

        localctx = NeoBasicParser.DateLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 750, self.RULE_dateLiteral)
        try:
            self.state = 2971
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [403]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2940
                self.match(NeoBasicParser.ATOM_DOT_LIT)
                pass
            elif token in [225]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2941
                self.match(NeoBasicParser.LOCALDATE)
                self.state = 2943
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,264,self._ctx)
                if la_ == 1:
                    self.state = 2942
                    self.parenthesizedExpression()


                pass
            elif token in [226]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2945
                self.match(NeoBasicParser.LOCALDATETIME)
                self.state = 2947
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,265,self._ctx)
                if la_ == 1:
                    self.state = 2946
                    self.parenthesizedExpression()


                pass
            elif token in [227]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2949
                self.match(NeoBasicParser.OFFSETDATE)
                self.state = 2951
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,266,self._ctx)
                if la_ == 1:
                    self.state = 2950
                    self.parenthesizedExpression()


                pass
            elif token in [228]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2953
                self.match(NeoBasicParser.OFFSETDATETIME)
                self.state = 2955
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,267,self._ctx)
                if la_ == 1:
                    self.state = 2954
                    self.parenthesizedExpression()


                pass
            elif token in [229]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2957
                self.match(NeoBasicParser.ZONEDDATE)
                self.state = 2959
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,268,self._ctx)
                if la_ == 1:
                    self.state = 2958
                    self.parenthesizedExpression()


                pass
            elif token in [230]:
                self.enterOuterAlt(localctx, 7)
                self.state = 2961
                self.match(NeoBasicParser.ZONEDDATETIME)
                self.state = 2963
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,269,self._ctx)
                if la_ == 1:
                    self.state = 2962
                    self.parenthesizedExpression()


                pass
            elif token in [231]:
                self.enterOuterAlt(localctx, 8)
                self.state = 2965
                self.match(NeoBasicParser.TOMORROW)
                pass
            elif token in [232]:
                self.enterOuterAlt(localctx, 9)
                self.state = 2966
                self.match(NeoBasicParser.TODAY)
                pass
            elif token in [233]:
                self.enterOuterAlt(localctx, 10)
                self.state = 2967
                self.match(NeoBasicParser.NOW)
                pass
            elif token in [234]:
                self.enterOuterAlt(localctx, 11)
                self.state = 2968
                self.match(NeoBasicParser.YESTERDAY)
                pass
            elif token in [235]:
                self.enterOuterAlt(localctx, 12)
                self.state = 2969
                self.match(NeoBasicParser.EON)
                pass
            elif token in [236]:
                self.enterOuterAlt(localctx, 13)
                self.state = 2970
                self.match(NeoBasicParser.EPOCH)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CharacterLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASCII_LIT(self):
            return self.getToken(NeoBasicParser.ASCII_LIT, 0)

        def CHAR_LIT(self):
            return self.getToken(NeoBasicParser.CHAR_LIT, 0)

        def LETTER(self):
            return self.getToken(NeoBasicParser.LETTER, 0)

        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def DIGIT(self):
            return self.getToken(NeoBasicParser.DIGIT, 0)

        def PUNCTUATION(self):
            return self.getToken(NeoBasicParser.PUNCTUATION, 0)

        def SYMBOL(self):
            return self.getToken(NeoBasicParser.SYMBOL, 0)

        def SEPARATOR(self):
            return self.getToken(NeoBasicParser.SEPARATOR, 0)

        def NONPRINTABLE(self):
            return self.getToken(NeoBasicParser.NONPRINTABLE, 0)

        def NULL(self):
            return self.getToken(NeoBasicParser.NULL, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_characterLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCharacterLiteral" ):
                listener.enterCharacterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCharacterLiteral" ):
                listener.exitCharacterLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCharacterLiteral" ):
                return visitor.visitCharacterLiteral(self)
            else:
                return visitor.visitChildren(self)




    def characterLiteral(self):

        localctx = NeoBasicParser.CharacterLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 752, self.RULE_characterLiteral)
        try:
            self.state = 2988
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [393]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2973
                self.match(NeoBasicParser.ASCII_LIT)
                pass
            elif token in [394]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2974
                self.match(NeoBasicParser.CHAR_LIT)
                pass
            elif token in [237]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2975
                self.match(NeoBasicParser.LETTER)
                self.state = 2976
                self.parenthesizedExpression()
                pass
            elif token in [239]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2977
                self.match(NeoBasicParser.DIGIT)
                self.state = 2978
                self.parenthesizedExpression()
                pass
            elif token in [240]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2979
                self.match(NeoBasicParser.PUNCTUATION)
                self.state = 2980
                self.parenthesizedExpression()
                pass
            elif token in [241]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2981
                self.match(NeoBasicParser.SYMBOL)
                self.state = 2982
                self.parenthesizedExpression()
                pass
            elif token in [242]:
                self.enterOuterAlt(localctx, 7)
                self.state = 2983
                self.match(NeoBasicParser.SEPARATOR)
                self.state = 2984
                self.parenthesizedExpression()
                pass
            elif token in [243]:
                self.enterOuterAlt(localctx, 8)
                self.state = 2985
                self.match(NeoBasicParser.NONPRINTABLE)
                self.state = 2986
                self.parenthesizedExpression()
                pass
            elif token in [244]:
                self.enterOuterAlt(localctx, 9)
                self.state = 2987
                self.match(NeoBasicParser.NULL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OptionLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def resultLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.ResultLiteralContext,0)


        def maybeLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.MaybeLiteralContext,0)


        def eitherLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.EitherLiteralContext,0)


        def streamLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.StreamLiteralContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_optionLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOptionLiteral" ):
                listener.enterOptionLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOptionLiteral" ):
                listener.exitOptionLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOptionLiteral" ):
                return visitor.visitOptionLiteral(self)
            else:
                return visitor.visitChildren(self)




    def optionLiteral(self):

        localctx = NeoBasicParser.OptionLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 754, self.RULE_optionLiteral)
        try:
            self.state = 2994
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [260, 261]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2990
                self.resultLiteral()
                pass
            elif token in [263, 264]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2991
                self.maybeLiteral()
                pass
            elif token in [266, 267]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2992
                self.eitherLiteral()
                pass
            elif token in [269, 270]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2993
                self.streamLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResultLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OKAY(self):
            return self.getToken(NeoBasicParser.OKAY, 0)

        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def FAIL(self):
            return self.getToken(NeoBasicParser.FAIL, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_resultLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResultLiteral" ):
                listener.enterResultLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResultLiteral" ):
                listener.exitResultLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResultLiteral" ):
                return visitor.visitResultLiteral(self)
            else:
                return visitor.visitChildren(self)




    def resultLiteral(self):

        localctx = NeoBasicParser.ResultLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 756, self.RULE_resultLiteral)
        try:
            self.state = 3000
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [260]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2996
                self.match(NeoBasicParser.OKAY)
                self.state = 2997
                self.parenthesizedExpression()
                pass
            elif token in [261]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2998
                self.match(NeoBasicParser.FAIL)
                self.state = 2999
                self.parenthesizedExpression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MaybeLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SOME(self):
            return self.getToken(NeoBasicParser.SOME, 0)

        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def NONE(self):
            return self.getToken(NeoBasicParser.NONE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_maybeLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaybeLiteral" ):
                listener.enterMaybeLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaybeLiteral" ):
                listener.exitMaybeLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaybeLiteral" ):
                return visitor.visitMaybeLiteral(self)
            else:
                return visitor.visitChildren(self)




    def maybeLiteral(self):

        localctx = NeoBasicParser.MaybeLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 758, self.RULE_maybeLiteral)
        try:
            self.state = 3005
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [263]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3002
                self.match(NeoBasicParser.SOME)
                self.state = 3003
                self.parenthesizedExpression()
                pass
            elif token in [264]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3004
                self.match(NeoBasicParser.NONE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EitherLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def YEA(self):
            return self.getToken(NeoBasicParser.YEA, 0)

        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def NAY(self):
            return self.getToken(NeoBasicParser.NAY, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_eitherLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEitherLiteral" ):
                listener.enterEitherLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEitherLiteral" ):
                listener.exitEitherLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEitherLiteral" ):
                return visitor.visitEitherLiteral(self)
            else:
                return visitor.visitChildren(self)




    def eitherLiteral(self):

        localctx = NeoBasicParser.EitherLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 760, self.RULE_eitherLiteral)
        try:
            self.state = 3011
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [266]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3007
                self.match(NeoBasicParser.YEA)
                self.state = 3008
                self.parenthesizedExpression()
                pass
            elif token in [267]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3009
                self.match(NeoBasicParser.NAY)
                self.state = 3010
                self.parenthesizedExpression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StreamLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATUM(self):
            return self.getToken(NeoBasicParser.DATUM, 0)

        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def EOT(self):
            return self.getToken(NeoBasicParser.EOT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_streamLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStreamLiteral" ):
                listener.enterStreamLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStreamLiteral" ):
                listener.exitStreamLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStreamLiteral" ):
                return visitor.visitStreamLiteral(self)
            else:
                return visitor.visitChildren(self)




    def streamLiteral(self):

        localctx = NeoBasicParser.StreamLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 762, self.RULE_streamLiteral)
        try:
            self.state = 3016
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [269]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3013
                self.match(NeoBasicParser.DATUM)
                self.state = 3014
                self.parenthesizedExpression()
                pass
            elif token in [270]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3015
                self.match(NeoBasicParser.EOT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompoundLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sequenceLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.SequenceLiteralContext,0)


        def musicalLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.MusicalLiteralContext,0)


        def compositeLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.CompositeLiteralContext,0)


        def xmlDocLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlDocLiteralContext,0)


        def collectionLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.CollectionLiteralContext,0)


        def objectLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.ObjectLiteralContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_compoundLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompoundLiteral" ):
                listener.enterCompoundLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompoundLiteral" ):
                listener.exitCompoundLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompoundLiteral" ):
                return visitor.visitCompoundLiteral(self)
            else:
                return visitor.visitChildren(self)




    def compoundLiteral(self):

        localctx = NeoBasicParser.CompoundLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 764, self.RULE_compoundLiteral)
        try:
            self.state = 3024
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,277,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3018
                self.sequenceLiteral()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3019
                self.musicalLiteral()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3020
                self.compositeLiteral()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 3021
                self.xmlDocLiteral()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 3022
                self.collectionLiteral()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 3023
                self.objectLiteral()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SequenceLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEMPLATE_SINGLELINE_STRING_LIT(self):
            return self.getToken(NeoBasicParser.TEMPLATE_SINGLELINE_STRING_LIT, 0)

        def TEMPLATE_MULTILINE_STRING_LIT(self):
            return self.getToken(NeoBasicParser.TEMPLATE_MULTILINE_STRING_LIT, 0)

        def VERBATIM_SINGLELINE_STRING_LIT(self):
            return self.getToken(NeoBasicParser.VERBATIM_SINGLELINE_STRING_LIT, 0)

        def VERBATIM_MULTILINE_STRING_LIT(self):
            return self.getToken(NeoBasicParser.VERBATIM_MULTILINE_STRING_LIT, 0)

        def TRANSLATABLE_SINGLELINE_STRING_LIT(self):
            return self.getToken(NeoBasicParser.TRANSLATABLE_SINGLELINE_STRING_LIT, 0)

        def TRANSLATABLE_MULTILINE_STRING_LIT(self):
            return self.getToken(NeoBasicParser.TRANSLATABLE_MULTILINE_STRING_LIT, 0)

        def HEREDOC_STRING_LIT(self):
            return self.getToken(NeoBasicParser.HEREDOC_STRING_LIT, 0)

        def REGULAR_EXPRESSION_LIT(self):
            return self.getToken(NeoBasicParser.REGULAR_EXPRESSION_LIT, 0)

        def ATOM_DOT_LIT(self):
            return self.getToken(NeoBasicParser.ATOM_DOT_LIT, 0)

        def BINARY_LIT(self):
            return self.getToken(NeoBasicParser.BINARY_LIT, 0)

        def NONBLANK(self):
            return self.getToken(NeoBasicParser.NONBLANK, 0)

        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def BLANK(self):
            return self.getToken(NeoBasicParser.BLANK, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_sequenceLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSequenceLiteral" ):
                listener.enterSequenceLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSequenceLiteral" ):
                listener.exitSequenceLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSequenceLiteral" ):
                return visitor.visitSequenceLiteral(self)
            else:
                return visitor.visitChildren(self)




    def sequenceLiteral(self):

        localctx = NeoBasicParser.SequenceLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 766, self.RULE_sequenceLiteral)
        try:
            self.state = 3039
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [397]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3026
                self.match(NeoBasicParser.TEMPLATE_SINGLELINE_STRING_LIT)
                pass
            elif token in [398]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3027
                self.match(NeoBasicParser.TEMPLATE_MULTILINE_STRING_LIT)
                pass
            elif token in [395]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3028
                self.match(NeoBasicParser.VERBATIM_SINGLELINE_STRING_LIT)
                pass
            elif token in [396]:
                self.enterOuterAlt(localctx, 4)
                self.state = 3029
                self.match(NeoBasicParser.VERBATIM_MULTILINE_STRING_LIT)
                pass
            elif token in [399]:
                self.enterOuterAlt(localctx, 5)
                self.state = 3030
                self.match(NeoBasicParser.TRANSLATABLE_SINGLELINE_STRING_LIT)
                pass
            elif token in [400]:
                self.enterOuterAlt(localctx, 6)
                self.state = 3031
                self.match(NeoBasicParser.TRANSLATABLE_MULTILINE_STRING_LIT)
                pass
            elif token in [401]:
                self.enterOuterAlt(localctx, 7)
                self.state = 3032
                self.match(NeoBasicParser.HEREDOC_STRING_LIT)
                pass
            elif token in [402]:
                self.enterOuterAlt(localctx, 8)
                self.state = 3033
                self.match(NeoBasicParser.REGULAR_EXPRESSION_LIT)
                pass
            elif token in [403]:
                self.enterOuterAlt(localctx, 9)
                self.state = 3034
                self.match(NeoBasicParser.ATOM_DOT_LIT)
                pass
            elif token in [392]:
                self.enterOuterAlt(localctx, 10)
                self.state = 3035
                self.match(NeoBasicParser.BINARY_LIT)
                pass
            elif token in [246]:
                self.enterOuterAlt(localctx, 11)
                self.state = 3036
                self.match(NeoBasicParser.NONBLANK)
                self.state = 3037
                self.parenthesizedExpression()
                pass
            elif token in [245]:
                self.enterOuterAlt(localctx, 12)
                self.state = 3038
                self.match(NeoBasicParser.BLANK)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEMPLATE_SINGLELINE_STRING_LIT(self):
            return self.getToken(NeoBasicParser.TEMPLATE_SINGLELINE_STRING_LIT, 0)

        def VERBATIM_SINGLELINE_STRING_LIT(self):
            return self.getToken(NeoBasicParser.VERBATIM_SINGLELINE_STRING_LIT, 0)

        def TRANSLATABLE_SINGLELINE_STRING_LIT(self):
            return self.getToken(NeoBasicParser.TRANSLATABLE_SINGLELINE_STRING_LIT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_stringLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringLiteral" ):
                listener.enterStringLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringLiteral" ):
                listener.exitStringLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringLiteral" ):
                return visitor.visitStringLiteral(self)
            else:
                return visitor.visitChildren(self)




    def stringLiteral(self):

        localctx = NeoBasicParser.StringLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 768, self.RULE_stringLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3041
            _la = self._input.LA(1)
            if not(((((_la - 395)) & ~0x3f) == 0 and ((1 << (_la - 395)) & 21) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MusicalLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATOM_MUSIC_LIT(self):
            return self.getToken(NeoBasicParser.ATOM_MUSIC_LIT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_musicalLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMusicalLiteral" ):
                listener.enterMusicalLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMusicalLiteral" ):
                listener.exitMusicalLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMusicalLiteral" ):
                return visitor.visitMusicalLiteral(self)
            else:
                return visitor.visitChildren(self)




    def musicalLiteral(self):

        localctx = NeoBasicParser.MusicalLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 770, self.RULE_musicalLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3043
            self.match(NeoBasicParser.ATOM_MUSIC_LIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompositeLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def rangeLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.RangeLiteralContext,0)


        def pairLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.PairLiteralContext,0)


        def tupleLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.TupleLiteralContext,0)


        def inetLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.InetLiteralContext,0)


        def uriLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.UriLiteralContext,0)


        def shellPathLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.ShellPathLiteralContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_compositeLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompositeLiteral" ):
                listener.enterCompositeLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompositeLiteral" ):
                listener.exitCompositeLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompositeLiteral" ):
                return visitor.visitCompositeLiteral(self)
            else:
                return visitor.visitChildren(self)




    def compositeLiteral(self):

        localctx = NeoBasicParser.CompositeLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 772, self.RULE_compositeLiteral)
        try:
            self.state = 3051
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,279,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3045
                self.rangeLiteral()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3046
                self.pairLiteral()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3047
                self.tupleLiteral()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 3048
                self.inetLiteral()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 3049
                self.uriLiteral()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 3050
                self.shellPathLiteral()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RangeLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def escalarLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.EscalarLiteralContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.EscalarLiteralContext,i)


        def intervalOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.IntervalOperatorContext,0)


        def leftIntervalOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.LeftIntervalOperatorContext,0)


        def rightIntervalOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.RightIntervalOperatorContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_rangeLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRangeLiteral" ):
                listener.enterRangeLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRangeLiteral" ):
                listener.exitRangeLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRangeLiteral" ):
                return visitor.visitRangeLiteral(self)
            else:
                return visitor.visitChildren(self)




    def rangeLiteral(self):

        localctx = NeoBasicParser.RangeLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 774, self.RULE_rangeLiteral)
        try:
            self.state = 3063
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,280,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3053
                self.escalarLiteral()
                self.state = 3054
                self.intervalOperator()
                self.state = 3055
                self.escalarLiteral()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3057
                self.escalarLiteral()
                self.state = 3058
                self.leftIntervalOperator()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3060
                self.rightIntervalOperator()
                self.state = 3061
                self.escalarLiteral()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PairLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def escalarLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.EscalarLiteralContext,0)


        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_pairLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPairLiteral" ):
                listener.enterPairLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPairLiteral" ):
                listener.exitPairLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPairLiteral" ):
                return visitor.visitPairLiteral(self)
            else:
                return visitor.visitChildren(self)




    def pairLiteral(self):

        localctx = NeoBasicParser.PairLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 776, self.RULE_pairLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3065
            self.escalarLiteral()
            self.state = 3066
            self.match(NeoBasicParser.COLON)
            self.state = 3067
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TupleLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LEFT_PARENTHESIS, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def COMMA(self):
            return self.getToken(NeoBasicParser.COMMA, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_tupleLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTupleLiteral" ):
                listener.enterTupleLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTupleLiteral" ):
                listener.exitTupleLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTupleLiteral" ):
                return visitor.visitTupleLiteral(self)
            else:
                return visitor.visitChildren(self)




    def tupleLiteral(self):

        localctx = NeoBasicParser.TupleLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 778, self.RULE_tupleLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3069
            self.match(NeoBasicParser.LEFT_PARENTHESIS)
            self.state = 3070
            self.expressions()
            self.state = 3072
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==439:
                self.state = 3071
                self.match(NeoBasicParser.COMMA)


            self.state = 3074
            self.match(NeoBasicParser.RIGHT_PARENTHESIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InetLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATOM_DOT_LIT(self):
            return self.getToken(NeoBasicParser.ATOM_DOT_LIT, 0)

        def IPV4(self):
            return self.getToken(NeoBasicParser.IPV4, 0)

        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def IPV6(self):
            return self.getToken(NeoBasicParser.IPV6, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_inetLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInetLiteral" ):
                listener.enterInetLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInetLiteral" ):
                listener.exitInetLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInetLiteral" ):
                return visitor.visitInetLiteral(self)
            else:
                return visitor.visitChildren(self)




    def inetLiteral(self):

        localctx = NeoBasicParser.InetLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 780, self.RULE_inetLiteral)
        try:
            self.state = 3081
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [403]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3076
                self.match(NeoBasicParser.ATOM_DOT_LIT)
                pass
            elif token in [257]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3077
                self.match(NeoBasicParser.IPV4)
                self.state = 3078
                self.parenthesizedExpression()
                pass
            elif token in [258]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3079
                self.match(NeoBasicParser.IPV6)
                self.state = 3080
                self.parenthesizedExpression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UriLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def URL(self):
            return self.getToken(NeoBasicParser.URL, 0)

        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def URN(self):
            return self.getToken(NeoBasicParser.URN, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_uriLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUriLiteral" ):
                listener.enterUriLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUriLiteral" ):
                listener.exitUriLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUriLiteral" ):
                return visitor.visitUriLiteral(self)
            else:
                return visitor.visitChildren(self)




    def uriLiteral(self):

        localctx = NeoBasicParser.UriLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 782, self.RULE_uriLiteral)
        try:
            self.state = 3087
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [255]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3083
                self.match(NeoBasicParser.URL)
                self.state = 3084
                self.parenthesizedExpression()
                pass
            elif token in [256]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3085
                self.match(NeoBasicParser.URN)
                self.state = 3086
                self.parenthesizedExpression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShellPathLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHELL_PATH(self):
            return self.getToken(NeoBasicParser.SHELL_PATH, 0)

        def SHELL_STRING_PATH(self):
            return self.getToken(NeoBasicParser.SHELL_STRING_PATH, 0)

        def FOLDER(self):
            return self.getToken(NeoBasicParser.FOLDER, 0)

        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def FILE(self):
            return self.getToken(NeoBasicParser.FILE, 0)

        def LINKLINKFILE(self):
            return self.getToken(NeoBasicParser.LINKLINKFILE, 0)

        def PIPEFILE(self):
            return self.getToken(NeoBasicParser.PIPEFILE, 0)

        def SOCKETFILE(self):
            return self.getToken(NeoBasicParser.SOCKETFILE, 0)

        def BLOCKDEVICE(self):
            return self.getToken(NeoBasicParser.BLOCKDEVICE, 0)

        def CHARDEVICE(self):
            return self.getToken(NeoBasicParser.CHARDEVICE, 0)

        def NULLDEVICE(self):
            return self.getToken(NeoBasicParser.NULLDEVICE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_shellPathLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShellPathLiteral" ):
                listener.enterShellPathLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShellPathLiteral" ):
                listener.exitShellPathLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShellPathLiteral" ):
                return visitor.visitShellPathLiteral(self)
            else:
                return visitor.visitChildren(self)




    def shellPathLiteral(self):

        localctx = NeoBasicParser.ShellPathLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 784, self.RULE_shellPathLiteral)
        try:
            self.state = 3106
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [415]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3089
                self.match(NeoBasicParser.SHELL_PATH)
                pass
            elif token in [414]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3090
                self.match(NeoBasicParser.SHELL_STRING_PATH)
                pass
            elif token in [247]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3091
                self.match(NeoBasicParser.FOLDER)
                self.state = 3092
                self.parenthesizedExpression()
                pass
            elif token in [248]:
                self.enterOuterAlt(localctx, 4)
                self.state = 3093
                self.match(NeoBasicParser.FILE)
                self.state = 3094
                self.parenthesizedExpression()
                pass
            elif token in [249]:
                self.enterOuterAlt(localctx, 5)
                self.state = 3095
                self.match(NeoBasicParser.LINKLINKFILE)
                self.state = 3096
                self.parenthesizedExpression()
                pass
            elif token in [250]:
                self.enterOuterAlt(localctx, 6)
                self.state = 3097
                self.match(NeoBasicParser.PIPEFILE)
                self.state = 3098
                self.parenthesizedExpression()
                pass
            elif token in [251]:
                self.enterOuterAlt(localctx, 7)
                self.state = 3099
                self.match(NeoBasicParser.SOCKETFILE)
                self.state = 3100
                self.parenthesizedExpression()
                pass
            elif token in [252]:
                self.enterOuterAlt(localctx, 8)
                self.state = 3101
                self.match(NeoBasicParser.BLOCKDEVICE)
                self.state = 3102
                self.parenthesizedExpression()
                pass
            elif token in [253]:
                self.enterOuterAlt(localctx, 9)
                self.state = 3103
                self.match(NeoBasicParser.CHARDEVICE)
                self.state = 3104
                self.parenthesizedExpression()
                pass
            elif token in [254]:
                self.enterOuterAlt(localctx, 10)
                self.state = 3105
                self.match(NeoBasicParser.NULLDEVICE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShellPathLiteralsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shellPathLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ShellPathLiteralContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ShellPathLiteralContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_shellPathLiterals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShellPathLiterals" ):
                listener.enterShellPathLiterals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShellPathLiterals" ):
                listener.exitShellPathLiterals(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShellPathLiterals" ):
                return visitor.visitShellPathLiterals(self)
            else:
                return visitor.visitChildren(self)




    def shellPathLiterals(self):

        localctx = NeoBasicParser.ShellPathLiteralsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 786, self.RULE_shellPathLiterals)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3108
            self.shellPathLiteral()
            self.state = 3113
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==439:
                self.state = 3109
                self.match(NeoBasicParser.COMMA)
                self.state = 3110
                self.shellPathLiteral()
                self.state = 3115
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlDocLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def xmlDocElement(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlDocElementContext,0)


        def xmlDocFragment(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlDocFragmentContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlDocLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlDocLiteral" ):
                listener.enterXmlDocLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlDocLiteral" ):
                listener.exitXmlDocLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlDocLiteral" ):
                return visitor.visitXmlDocLiteral(self)
            else:
                return visitor.visitChildren(self)




    def xmlDocLiteral(self):

        localctx = NeoBasicParser.XmlDocLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 788, self.RULE_xmlDocLiteral)
        try:
            self.state = 3118
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [313]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3116
                self.xmlDocElement()
                pass
            elif token in [463, 464]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3117
                self.xmlDocFragment()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlDocElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def xmlElementPaired(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlElementPairedContext,0)


        def xmlElementSelfClosed(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlElementSelfClosedContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlDocElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlDocElement" ):
                listener.enterXmlDocElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlDocElement" ):
                listener.exitXmlDocElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlDocElement" ):
                return visitor.visitXmlDocElement(self)
            else:
                return visitor.visitChildren(self)




    def xmlDocElement(self):

        localctx = NeoBasicParser.XmlDocElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 790, self.RULE_xmlDocElement)
        try:
            self.state = 3122
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,287,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3120
                self.xmlElementPaired()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3121
                self.xmlElementSelfClosed()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlElementPairedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def xmlOpeningElement(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlOpeningElementContext,0)


        def xmlClosingElement(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlClosingElementContext,0)


        def xmlChildren(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.XmlChildrenContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.XmlChildrenContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlElementPaired

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlElementPaired" ):
                listener.enterXmlElementPaired(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlElementPaired" ):
                listener.exitXmlElementPaired(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlElementPaired" ):
                return visitor.visitXmlElementPaired(self)
            else:
                return visitor.visitChildren(self)




    def xmlElementPaired(self):

        localctx = NeoBasicParser.XmlElementPairedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 792, self.RULE_xmlElementPaired)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3124
            self.xmlOpeningElement()
            self.state = 3128
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==1 or _la==313 or _la==436:
                self.state = 3125
                self.xmlChildren()
                self.state = 3130
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 3131
            self.xmlClosingElement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlOpeningElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_ANGLE(self):
            return self.getToken(NeoBasicParser.LEFT_ANGLE, 0)

        def xmlTagName(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlTagNameContext,0)


        def RIGHT_ANGLE(self):
            return self.getToken(NeoBasicParser.RIGHT_ANGLE, 0)

        def xmlAttributes(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.XmlAttributesContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.XmlAttributesContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlOpeningElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlOpeningElement" ):
                listener.enterXmlOpeningElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlOpeningElement" ):
                listener.exitXmlOpeningElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlOpeningElement" ):
                return visitor.visitXmlOpeningElement(self)
            else:
                return visitor.visitChildren(self)




    def xmlOpeningElement(self):

        localctx = NeoBasicParser.XmlOpeningElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 794, self.RULE_xmlOpeningElement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3133
            self.match(NeoBasicParser.LEFT_ANGLE)
            self.state = 3134
            self.xmlTagName()
            self.state = 3138
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==381:
                self.state = 3135
                self.xmlAttributes()
                self.state = 3140
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 3141
            self.match(NeoBasicParser.RIGHT_ANGLE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlClosingElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def XML_CLOSING_TAG(self):
            return self.getToken(NeoBasicParser.XML_CLOSING_TAG, 0)

        def xmlTagName(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlTagNameContext,0)


        def RIGHT_ANGLE(self):
            return self.getToken(NeoBasicParser.RIGHT_ANGLE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlClosingElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlClosingElement" ):
                listener.enterXmlClosingElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlClosingElement" ):
                listener.exitXmlClosingElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlClosingElement" ):
                return visitor.visitXmlClosingElement(self)
            else:
                return visitor.visitChildren(self)




    def xmlClosingElement(self):

        localctx = NeoBasicParser.XmlClosingElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 796, self.RULE_xmlClosingElement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3143
            self.match(NeoBasicParser.XML_CLOSING_TAG)
            self.state = 3144
            self.xmlTagName()
            self.state = 3145
            self.match(NeoBasicParser.RIGHT_ANGLE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlElementSelfClosedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_ANGLE(self):
            return self.getToken(NeoBasicParser.LEFT_ANGLE, 0)

        def xmlTagName(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlTagNameContext,0)


        def XML_SELFCLOSING_TAG(self):
            return self.getToken(NeoBasicParser.XML_SELFCLOSING_TAG, 0)

        def xmlAttributes(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.XmlAttributesContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.XmlAttributesContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlElementSelfClosed

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlElementSelfClosed" ):
                listener.enterXmlElementSelfClosed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlElementSelfClosed" ):
                listener.exitXmlElementSelfClosed(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlElementSelfClosed" ):
                return visitor.visitXmlElementSelfClosed(self)
            else:
                return visitor.visitChildren(self)




    def xmlElementSelfClosed(self):

        localctx = NeoBasicParser.XmlElementSelfClosedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 798, self.RULE_xmlElementSelfClosed)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3147
            self.match(NeoBasicParser.LEFT_ANGLE)
            self.state = 3148
            self.xmlTagName()
            self.state = 3152
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==381:
                self.state = 3149
                self.xmlAttributes()
                self.state = 3154
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 3155
            self.match(NeoBasicParser.XML_SELFCLOSING_TAG)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlDocFragmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def xmlFragmentPaired(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlFragmentPairedContext,0)


        def xmlFragmentSelfClosed(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlFragmentSelfClosedContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlDocFragment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlDocFragment" ):
                listener.enterXmlDocFragment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlDocFragment" ):
                listener.exitXmlDocFragment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlDocFragment" ):
                return visitor.visitXmlDocFragment(self)
            else:
                return visitor.visitChildren(self)




    def xmlDocFragment(self):

        localctx = NeoBasicParser.XmlDocFragmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 800, self.RULE_xmlDocFragment)
        try:
            self.state = 3159
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [463]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3157
                self.xmlFragmentPaired()
                pass
            elif token in [464]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3158
                self.xmlFragmentSelfClosed()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlFragmentPairedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def XML_OPENING_FRAGMENT(self):
            return self.getToken(NeoBasicParser.XML_OPENING_FRAGMENT, 0)

        def XML_CLOSING_FRAGMENT(self):
            return self.getToken(NeoBasicParser.XML_CLOSING_FRAGMENT, 0)

        def xmlChildren(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.XmlChildrenContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.XmlChildrenContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlFragmentPaired

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlFragmentPaired" ):
                listener.enterXmlFragmentPaired(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlFragmentPaired" ):
                listener.exitXmlFragmentPaired(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlFragmentPaired" ):
                return visitor.visitXmlFragmentPaired(self)
            else:
                return visitor.visitChildren(self)




    def xmlFragmentPaired(self):

        localctx = NeoBasicParser.XmlFragmentPairedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 802, self.RULE_xmlFragmentPaired)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3161
            self.match(NeoBasicParser.XML_OPENING_FRAGMENT)
            self.state = 3165
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==1 or _la==313 or _la==436:
                self.state = 3162
                self.xmlChildren()
                self.state = 3167
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 3168
            self.match(NeoBasicParser.XML_CLOSING_FRAGMENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlFragmentSelfClosedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def XML_CLOSING_FRAGMENT(self):
            return self.getToken(NeoBasicParser.XML_CLOSING_FRAGMENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlFragmentSelfClosed

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlFragmentSelfClosed" ):
                listener.enterXmlFragmentSelfClosed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlFragmentSelfClosed" ):
                listener.exitXmlFragmentSelfClosed(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlFragmentSelfClosed" ):
                return visitor.visitXmlFragmentSelfClosed(self)
            else:
                return visitor.visitChildren(self)




    def xmlFragmentSelfClosed(self):

        localctx = NeoBasicParser.XmlFragmentSelfClosedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 804, self.RULE_xmlFragmentSelfClosed)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3170
            self.match(NeoBasicParser.XML_CLOSING_FRAGMENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlTagNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(NeoBasicParser.IDENTIFIER, 0)

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlTagName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlTagName" ):
                listener.enterXmlTagName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlTagName" ):
                listener.exitXmlTagName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlTagName" ):
                return visitor.visitXmlTagName(self)
            else:
                return visitor.visitChildren(self)




    def xmlTagName(self):

        localctx = NeoBasicParser.XmlTagNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 806, self.RULE_xmlTagName)
        try:
            self.state = 3174
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,293,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3172
                self.match(NeoBasicParser.IDENTIFIER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3173
                self.qualifiedIdentifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlAttributesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def xmlTagName(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlTagNameContext,0)


        def EQUAL(self):
            return self.getToken(NeoBasicParser.EQUAL, 0)

        def xmlAttributeValue(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlAttributeValueContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlAttributes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlAttributes" ):
                listener.enterXmlAttributes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlAttributes" ):
                listener.exitXmlAttributes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlAttributes" ):
                return visitor.visitXmlAttributes(self)
            else:
                return visitor.visitChildren(self)




    def xmlAttributes(self):

        localctx = NeoBasicParser.XmlAttributesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 808, self.RULE_xmlAttributes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3176
            self.xmlTagName()
            self.state = 3179
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==353:
                self.state = 3177
                self.match(NeoBasicParser.EQUAL)
                self.state = 3178
                self.xmlAttributeValue()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlAttributeValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def literal(self):
            return self.getTypedRuleContext(NeoBasicParser.LiteralContext,0)


        def expressionPlaceholder(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionPlaceholderContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlAttributeValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlAttributeValue" ):
                listener.enterXmlAttributeValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlAttributeValue" ):
                listener.exitXmlAttributeValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlAttributeValue" ):
                return visitor.visitXmlAttributeValue(self)
            else:
                return visitor.visitChildren(self)




    def xmlAttributeValue(self):

        localctx = NeoBasicParser.XmlAttributeValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 810, self.RULE_xmlAttributeValue)
        try:
            self.state = 3183
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,295,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3181
                self.literal()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3182
                self.expressionPlaceholder()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlChildrenContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def xmlDocElement(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlDocElementContext,0)


        def expressionPlaceholder(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionPlaceholderContext,0)


        def XML_CONTENT(self):
            return self.getToken(NeoBasicParser.XML_CONTENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlChildren

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlChildren" ):
                listener.enterXmlChildren(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlChildren" ):
                listener.exitXmlChildren(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlChildren" ):
                return visitor.visitXmlChildren(self)
            else:
                return visitor.visitChildren(self)




    def xmlChildren(self):

        localctx = NeoBasicParser.XmlChildrenContext(self, self._ctx, self.state)
        self.enterRule(localctx, 812, self.RULE_xmlChildren)
        try:
            self.state = 3188
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [313]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3185
                self.xmlDocElement()
                pass
            elif token in [436]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3186
                self.expressionPlaceholder()
                pass
            elif token in [1]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3187
                self.match(NeoBasicParser.XML_CONTENT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionPlaceholderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_CURLY(self):
            return self.getToken(NeoBasicParser.LEFT_CURLY, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def RIGHT_CURLY(self):
            return self.getToken(NeoBasicParser.RIGHT_CURLY, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_expressionPlaceholder

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionPlaceholder" ):
                listener.enterExpressionPlaceholder(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionPlaceholder" ):
                listener.exitExpressionPlaceholder(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressionPlaceholder" ):
                return visitor.visitExpressionPlaceholder(self)
            else:
                return visitor.visitChildren(self)




    def expressionPlaceholder(self):

        localctx = NeoBasicParser.ExpressionPlaceholderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 814, self.RULE_expressionPlaceholder)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3190
            self.match(NeoBasicParser.LEFT_CURLY)
            self.state = 3191
            self.expression(0)
            self.state = 3192
            self.match(NeoBasicParser.RIGHT_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CollectionLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def collectionLiteralValue(self):
            return self.getTypedRuleContext(NeoBasicParser.CollectionLiteralValueContext,0)


        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def arrayAosToSoaLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.ArrayAosToSoaLiteralContext,0)


        def listComprehension(self):
            return self.getTypedRuleContext(NeoBasicParser.ListComprehensionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_collectionLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCollectionLiteral" ):
                listener.enterCollectionLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCollectionLiteral" ):
                listener.exitCollectionLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCollectionLiteral" ):
                return visitor.visitCollectionLiteral(self)
            else:
                return visitor.visitChildren(self)




    def collectionLiteral(self):

        localctx = NeoBasicParser.CollectionLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 816, self.RULE_collectionLiteral)
        try:
            self.state = 3200
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,298,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3195
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,297,self._ctx)
                if la_ == 1:
                    self.state = 3194
                    self.type_(0)


                self.state = 3197
                self.collectionLiteralValue()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3198
                self.arrayAosToSoaLiteral()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3199
                self.listComprehension()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CollectionLiteralValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_BRACKET(self):
            return self.getToken(NeoBasicParser.LEFT_BRACKET, 0)

        def RIGHT_BRACKET(self):
            return self.getToken(NeoBasicParser.RIGHT_BRACKET, 0)

        def elements(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ElementsContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ElementsContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_collectionLiteralValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCollectionLiteralValue" ):
                listener.enterCollectionLiteralValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCollectionLiteralValue" ):
                listener.exitCollectionLiteralValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCollectionLiteralValue" ):
                return visitor.visitCollectionLiteralValue(self)
            else:
                return visitor.visitChildren(self)




    def collectionLiteralValue(self):

        localctx = NeoBasicParser.CollectionLiteralValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 818, self.RULE_collectionLiteralValue)
        self._la = 0 # Token type
        try:
            self.state = 3215
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,301,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3202
                self.match(NeoBasicParser.LEFT_BRACKET)
                self.state = 3203
                self.match(NeoBasicParser.RIGHT_BRACKET)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3204
                self.match(NeoBasicParser.LEFT_BRACKET)
                self.state = 3209 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 3205
                    self.elements()
                    self.state = 3207
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==439:
                        self.state = 3206
                        self.match(NeoBasicParser.COMMA)


                    self.state = 3211 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 247385886433392) != 0) or ((((_la - 93)) & ~0x3f) == 0 and ((1 << (_la - 93)) & -4128769) != 0) or ((((_la - 157)) & ~0x3f) == 0 and ((1 << (_la - 157)) & -1) != 0) or ((((_la - 221)) & ~0x3f) == 0 and ((1 << (_la - 221)) & -4610560118520676353) != 0) or ((((_la - 285)) & ~0x3f) == 0 and ((1 << (_la - 285)) & 2814750039735871) != 0) or ((((_la - 381)) & ~0x3f) == 0 and ((1 << (_la - 381)) & 47287830447128569) != 0) or ((((_la - 451)) & ~0x3f) == 0 and ((1 << (_la - 451)) & 12295) != 0)):
                        break

                self.state = 3213
                self.match(NeoBasicParser.RIGHT_BRACKET)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def element(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ElementContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ElementContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_elements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElements" ):
                listener.enterElements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElements" ):
                listener.exitElements(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElements" ):
                return visitor.visitElements(self)
            else:
                return visitor.visitChildren(self)




    def elements(self):

        localctx = NeoBasicParser.ElementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 820, self.RULE_elements)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3218 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 3217
                    self.element()

                else:
                    raise NoViableAltException(self)
                self.state = 3220 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,302,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def elementValue(self):
            return self.getTypedRuleContext(NeoBasicParser.ElementValueContext,0)


        def elementKey(self):
            return self.getTypedRuleContext(NeoBasicParser.ElementKeyContext,0)


        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_element

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElement" ):
                listener.enterElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElement" ):
                listener.exitElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElement" ):
                return visitor.visitElement(self)
            else:
                return visitor.visitChildren(self)




    def element(self):

        localctx = NeoBasicParser.ElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 822, self.RULE_element)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3225
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,303,self._ctx)
            if la_ == 1:
                self.state = 3222
                self.elementKey()
                self.state = 3223
                self.match(NeoBasicParser.COLON)


            self.state = 3227
            self.elementValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementKeyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_elementKey

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementKey" ):
                listener.enterElementKey(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementKey" ):
                listener.exitElementKey(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElementKey" ):
                return visitor.visitElementKey(self)
            else:
                return visitor.visitChildren(self)




    def elementKey(self):

        localctx = NeoBasicParser.ElementKeyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 824, self.RULE_elementKey)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3229
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_elementValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementValue" ):
                listener.enterElementValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementValue" ):
                listener.exitElementValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElementValue" ):
                return visitor.visitElementValue(self)
            else:
                return visitor.visitChildren(self)




    def elementValue(self):

        localctx = NeoBasicParser.ElementValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 826, self.RULE_elementValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3231
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayAosToSoaLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_BRACKET(self):
            return self.getToken(NeoBasicParser.LEFT_BRACKET, 0)

        def RIGHT_BRACKET(self):
            return self.getToken(NeoBasicParser.RIGHT_BRACKET, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_arrayAosToSoaLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayAosToSoaLiteral" ):
                listener.enterArrayAosToSoaLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayAosToSoaLiteral" ):
                listener.exitArrayAosToSoaLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayAosToSoaLiteral" ):
                return visitor.visitArrayAosToSoaLiteral(self)
            else:
                return visitor.visitChildren(self)




    def arrayAosToSoaLiteral(self):

        localctx = NeoBasicParser.ArrayAosToSoaLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 828, self.RULE_arrayAosToSoaLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3233
            self.match(NeoBasicParser.LEFT_BRACKET)
            self.state = 3234
            self.match(NeoBasicParser.RIGHT_BRACKET)
            self.state = 3235
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ListComprehensionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_BRACKET(self):
            return self.getToken(NeoBasicParser.LEFT_BRACKET, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def RIGHT_BRACKET(self):
            return self.getToken(NeoBasicParser.RIGHT_BRACKET, 0)

        def comprehensionClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ComprehensionClauseContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ComprehensionClauseContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_listComprehension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterListComprehension" ):
                listener.enterListComprehension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitListComprehension" ):
                listener.exitListComprehension(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitListComprehension" ):
                return visitor.visitListComprehension(self)
            else:
                return visitor.visitChildren(self)




    def listComprehension(self):

        localctx = NeoBasicParser.ListComprehensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 830, self.RULE_listComprehension)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3237
            self.match(NeoBasicParser.LEFT_BRACKET)
            self.state = 3238
            self.expressions()
            self.state = 3240 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 3239
                self.comprehensionClause()
                self.state = 3242 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==64):
                    break

            self.state = 3244
            self.match(NeoBasicParser.RIGHT_BRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComprehensionClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def forEachClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ForEachClauseContext,0)


        def IF(self):
            return self.getToken(NeoBasicParser.IF, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_comprehensionClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComprehensionClause" ):
                listener.enterComprehensionClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComprehensionClause" ):
                listener.exitComprehensionClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComprehensionClause" ):
                return visitor.visitComprehensionClause(self)
            else:
                return visitor.visitChildren(self)




    def comprehensionClause(self):

        localctx = NeoBasicParser.ComprehensionClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 832, self.RULE_comprehensionClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3246
            self.forEachClause()
            self.state = 3249
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==48:
                self.state = 3247
                self.match(NeoBasicParser.IF)
                self.state = 3248
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def objectLiteralValue(self):
            return self.getTypedRuleContext(NeoBasicParser.ObjectLiteralValueContext,0)


        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_objectLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectLiteral" ):
                listener.enterObjectLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectLiteral" ):
                listener.exitObjectLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectLiteral" ):
                return visitor.visitObjectLiteral(self)
            else:
                return visitor.visitChildren(self)




    def objectLiteral(self):

        localctx = NeoBasicParser.ObjectLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 834, self.RULE_objectLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3252
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 247385886433392) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & -1) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & 16777215) != 0) or ((((_la - 259)) & ~0x3f) == 0 and ((1 << (_la - 259)) & 585) != 0) or _la==381 or _la==434:
                self.state = 3251
                self.type_(0)


            self.state = 3254
            self.objectLiteralValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectLiteralValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_CURLY(self):
            return self.getToken(NeoBasicParser.LEFT_CURLY, 0)

        def RIGHT_CURLY(self):
            return self.getToken(NeoBasicParser.RIGHT_CURLY, 0)

        def objectMembers(self):
            return self.getTypedRuleContext(NeoBasicParser.ObjectMembersContext,0)


        def COMMA(self):
            return self.getToken(NeoBasicParser.COMMA, 0)

        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_objectLiteralValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectLiteralValue" ):
                listener.enterObjectLiteralValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectLiteralValue" ):
                listener.exitObjectLiteralValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectLiteralValue" ):
                return visitor.visitObjectLiteralValue(self)
            else:
                return visitor.visitChildren(self)




    def objectLiteralValue(self):

        localctx = NeoBasicParser.ObjectLiteralValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 836, self.RULE_objectLiteralValue)
        self._la = 0 # Token type
        try:
            self.state = 3269
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,308,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3256
                self.match(NeoBasicParser.LEFT_CURLY)
                self.state = 3257
                self.match(NeoBasicParser.RIGHT_CURLY)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3258
                self.match(NeoBasicParser.LEFT_CURLY)
                self.state = 3259
                self.objectMembers()
                self.state = 3261
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==439:
                    self.state = 3260
                    self.match(NeoBasicParser.COMMA)


                self.state = 3263
                self.match(NeoBasicParser.RIGHT_CURLY)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3265
                self.match(NeoBasicParser.LEFT_CURLY)
                self.state = 3266
                self.logicalInstructionSuite()
                self.state = 3267
                self.match(NeoBasicParser.RIGHT_CURLY)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectMembersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def objectMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ObjectMemberContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ObjectMemberContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_objectMembers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectMembers" ):
                listener.enterObjectMembers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectMembers" ):
                listener.exitObjectMembers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectMembers" ):
                return visitor.visitObjectMembers(self)
            else:
                return visitor.visitChildren(self)




    def objectMembers(self):

        localctx = NeoBasicParser.ObjectMembersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 838, self.RULE_objectMembers)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3271
            self.objectMember()
            self.state = 3276
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,309,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 3272
                    self.match(NeoBasicParser.COMMA)
                    self.state = 3273
                    self.objectMember() 
                self.state = 3278
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,309,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def memberValue(self):
            return self.getTypedRuleContext(NeoBasicParser.MemberValueContext,0)


        def memberName(self):
            return self.getTypedRuleContext(NeoBasicParser.MemberNameContext,0)


        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_objectMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectMember" ):
                listener.enterObjectMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectMember" ):
                listener.exitObjectMember(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectMember" ):
                return visitor.visitObjectMember(self)
            else:
                return visitor.visitChildren(self)




    def objectMember(self):

        localctx = NeoBasicParser.ObjectMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 840, self.RULE_objectMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3282
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,310,self._ctx)
            if la_ == 1:
                self.state = 3279
                self.memberName()
                self.state = 3280
                self.match(NeoBasicParser.COLON)


            self.state = 3284
            self.memberValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MemberNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def inferredDecoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_memberName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMemberName" ):
                listener.enterMemberName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMemberName" ):
                listener.exitMemberName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMemberName" ):
                return visitor.visitMemberName(self)
            else:
                return visitor.visitChildren(self)




    def memberName(self):

        localctx = NeoBasicParser.MemberNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 842, self.RULE_memberName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3286
            self.inferredDecoratedIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MemberValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_memberValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMemberValue" ):
                listener.enterMemberValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMemberValue" ):
                listener.exitMemberValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMemberValue" ):
                return visitor.visitMemberValue(self)
            else:
                return visitor.visitChildren(self)




    def memberValue(self):

        localctx = NeoBasicParser.MemberValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 844, self.RULE_memberValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3288
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LambdaLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def lambdaClause(self):
            return self.getTypedRuleContext(NeoBasicParser.LambdaClauseContext,0)


        def lambdaStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.LambdaStatementContext,0)


        def arithmeticComprehension(self):
            return self.getTypedRuleContext(NeoBasicParser.ArithmeticComprehensionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_lambdaLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLambdaLiteral" ):
                listener.enterLambdaLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLambdaLiteral" ):
                listener.exitLambdaLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLambdaLiteral" ):
                return visitor.visitLambdaLiteral(self)
            else:
                return visitor.visitChildren(self)




    def lambdaLiteral(self):

        localctx = NeoBasicParser.LambdaLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 846, self.RULE_lambdaLiteral)
        try:
            self.state = 3293
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [106]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3290
                self.lambdaClause()
                pass
            elif token in [453]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3291
                self.lambdaStatement()
                pass
            elif token in [115, 116, 117, 118, 119, 120, 121, 122, 123, 283, 284, 288, 289, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3292
                self.arithmeticComprehension()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LambdaClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LAMBDA(self):
            return self.getToken(NeoBasicParser.LAMBDA, 0)

        def IMPLICIT_RETURN(self):
            return self.getToken(NeoBasicParser.IMPLICIT_RETURN, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def procParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcParametersContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_lambdaClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLambdaClause" ):
                listener.enterLambdaClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLambdaClause" ):
                listener.exitLambdaClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLambdaClause" ):
                return visitor.visitLambdaClause(self)
            else:
                return visitor.visitChildren(self)




    def lambdaClause(self):

        localctx = NeoBasicParser.LambdaClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 848, self.RULE_lambdaClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3295
            self.match(NeoBasicParser.LAMBDA)
            self.state = 3297
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 2215641088) != 0) or _la==112 or _la==292 or _la==293 or ((((_la - 381)) & ~0x3f) == 0 and ((1 << (_la - 381)) & 7) != 0) or _la==450:
                self.state = 3296
                self.procParameters()


            self.state = 3299
            self.match(NeoBasicParser.IMPLICIT_RETURN)
            self.state = 3300
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LambdaStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LAMBDA_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LAMBDA_PARENTHESIS, 0)

        def statementBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementBlockContext,0)


        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_lambdaStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLambdaStatement" ):
                listener.enterLambdaStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLambdaStatement" ):
                listener.exitLambdaStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLambdaStatement" ):
                return visitor.visitLambdaStatement(self)
            else:
                return visitor.visitChildren(self)




    def lambdaStatement(self):

        localctx = NeoBasicParser.LambdaStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 850, self.RULE_lambdaStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3302
            self.match(NeoBasicParser.LAMBDA_PARENTHESIS)
            self.state = 3303
            self.statementBlock()
            self.state = 3304
            self.match(NeoBasicParser.RIGHT_PARENTHESIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArithmeticComprehensionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def binaryArithmeticOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryArithmeticOperatorContext,0)


        def LAMBDA_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LAMBDA_PARENTHESIS, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def comprehensionClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ComprehensionClauseContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ComprehensionClauseContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_arithmeticComprehension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArithmeticComprehension" ):
                listener.enterArithmeticComprehension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArithmeticComprehension" ):
                listener.exitArithmeticComprehension(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArithmeticComprehension" ):
                return visitor.visitArithmeticComprehension(self)
            else:
                return visitor.visitChildren(self)




    def arithmeticComprehension(self):

        localctx = NeoBasicParser.ArithmeticComprehensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 852, self.RULE_arithmeticComprehension)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3306
            self.binaryArithmeticOperator()
            self.state = 3307
            self.match(NeoBasicParser.LAMBDA_PARENTHESIS)
            self.state = 3308
            self.expression(0)
            self.state = 3310 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 3309
                self.comprehensionClause()
                self.state = 3312 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==64):
                    break

            self.state = 3314
            self.match(NeoBasicParser.RIGHT_PARENTHESIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredeclaredValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def predefinedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.PredefinedIdentifierContext,0)


        def predefinedShellValue(self):
            return self.getTypedRuleContext(NeoBasicParser.PredefinedShellValueContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_predeclaredValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredeclaredValue" ):
                listener.enterPredeclaredValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredeclaredValue" ):
                listener.exitPredeclaredValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredeclaredValue" ):
                return visitor.visitPredeclaredValue(self)
            else:
                return visitor.visitChildren(self)




    def predeclaredValue(self):

        localctx = NeoBasicParser.PredeclaredValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 854, self.RULE_predeclaredValue)
        try:
            self.state = 3318
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [93, 94, 95, 96, 97, 98, 99, 452]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3316
                self.predefinedIdentifier()
                pass
            elif token in [406, 407, 408, 409, 410, 411, 412, 413]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3317
                self.predefinedShellValue()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredefinedIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def THIS(self):
            return self.getToken(NeoBasicParser.THIS, 0)

        def IOTA(self):
            return self.getToken(NeoBasicParser.IOTA, 0)

        def NTH(self):
            return self.getToken(NeoBasicParser.NTH, 0)

        def IT(self):
            return self.getToken(NeoBasicParser.IT, 0)

        def SELF(self):
            return self.getToken(NeoBasicParser.SELF, 0)

        def SUPER(self):
            return self.getToken(NeoBasicParser.SUPER, 0)

        def PARENT(self):
            return self.getToken(NeoBasicParser.PARENT, 0)

        def UNDERSCORE(self):
            return self.getToken(NeoBasicParser.UNDERSCORE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_predefinedIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredefinedIdentifier" ):
                listener.enterPredefinedIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredefinedIdentifier" ):
                listener.exitPredefinedIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredefinedIdentifier" ):
                return visitor.visitPredefinedIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def predefinedIdentifier(self):

        localctx = NeoBasicParser.PredefinedIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 856, self.RULE_predefinedIdentifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3320
            _la = self._input.LA(1)
            if not(((((_la - 93)) & ~0x3f) == 0 and ((1 << (_la - 93)) & 127) != 0) or _la==452):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredefinedShellValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHELL_CURRENT_OPTIONS(self):
            return self.getToken(NeoBasicParser.SHELL_CURRENT_OPTIONS, 0)

        def SHELL_EXIT_STATUS(self):
            return self.getToken(NeoBasicParser.SHELL_EXIT_STATUS, 0)

        def SHELL_ERROR_LEVEL(self):
            return self.getToken(NeoBasicParser.SHELL_ERROR_LEVEL, 0)

        def SHELL_BKG_EXIT_STATUS(self):
            return self.getToken(NeoBasicParser.SHELL_BKG_EXIT_STATUS, 0)

        def SHELL_BKG_ERROR_LEVEL(self):
            return self.getToken(NeoBasicParser.SHELL_BKG_ERROR_LEVEL, 0)

        def SHELL_FILE_DESCRIPTOR(self):
            return self.getToken(NeoBasicParser.SHELL_FILE_DESCRIPTOR, 0)

        def SHELL_CMD_ARGUMENT(self):
            return self.getToken(NeoBasicParser.SHELL_CMD_ARGUMENT, 0)

        def SHELL_ENV_VARIABLE(self):
            return self.getToken(NeoBasicParser.SHELL_ENV_VARIABLE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_predefinedShellValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredefinedShellValue" ):
                listener.enterPredefinedShellValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredefinedShellValue" ):
                listener.exitPredefinedShellValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredefinedShellValue" ):
                return visitor.visitPredefinedShellValue(self)
            else:
                return visitor.visitChildren(self)




    def predefinedShellValue(self):

        localctx = NeoBasicParser.PredefinedShellValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 858, self.RULE_predefinedShellValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3322
            _la = self._input.LA(1)
            if not(((((_la - 406)) & ~0x3f) == 0 and ((1 << (_la - 406)) & 255) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredeclaredFunctorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def predeclaredFact(self):
            return self.getTypedRuleContext(NeoBasicParser.PredeclaredFactContext,0)


        def predeclaredFmap(self):
            return self.getTypedRuleContext(NeoBasicParser.PredeclaredFmapContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_predeclaredFunctor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredeclaredFunctor" ):
                listener.enterPredeclaredFunctor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredeclaredFunctor" ):
                listener.exitPredeclaredFunctor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredeclaredFunctor" ):
                return visitor.visitPredeclaredFunctor(self)
            else:
                return visitor.visitChildren(self)




    def predeclaredFunctor(self):

        localctx = NeoBasicParser.PredeclaredFunctorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 860, self.RULE_predeclaredFunctor)
        try:
            self.state = 3326
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [216, 217, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 260, 261, 263, 264, 266, 267, 269, 270]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3324
                self.predeclaredFact()
                pass
            elif token in [100, 101, 102, 103, 104, 105]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3325
                self.predeclaredFmap()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredeclaredFactContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(NeoBasicParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(NeoBasicParser.FALSE, 0)

        def ZERO(self):
            return self.getToken(NeoBasicParser.ZERO, 0)

        def MINVALUE(self):
            return self.getToken(NeoBasicParser.MINVALUE, 0)

        def MAXVALUE(self):
            return self.getToken(NeoBasicParser.MAXVALUE, 0)

        def NAN(self):
            return self.getToken(NeoBasicParser.NAN, 0)

        def POSITIVEINFINITY(self):
            return self.getToken(NeoBasicParser.POSITIVEINFINITY, 0)

        def NEGATIVEINFINITY(self):
            return self.getToken(NeoBasicParser.NEGATIVEINFINITY, 0)

        def LOCALDATE(self):
            return self.getToken(NeoBasicParser.LOCALDATE, 0)

        def LOCALDATETIME(self):
            return self.getToken(NeoBasicParser.LOCALDATETIME, 0)

        def OFFSETDATE(self):
            return self.getToken(NeoBasicParser.OFFSETDATE, 0)

        def OFFSETDATETIME(self):
            return self.getToken(NeoBasicParser.OFFSETDATETIME, 0)

        def ZONEDDATE(self):
            return self.getToken(NeoBasicParser.ZONEDDATE, 0)

        def ZONEDDATETIME(self):
            return self.getToken(NeoBasicParser.ZONEDDATETIME, 0)

        def TOMORROW(self):
            return self.getToken(NeoBasicParser.TOMORROW, 0)

        def TODAY(self):
            return self.getToken(NeoBasicParser.TODAY, 0)

        def NOW(self):
            return self.getToken(NeoBasicParser.NOW, 0)

        def YESTERDAY(self):
            return self.getToken(NeoBasicParser.YESTERDAY, 0)

        def EON(self):
            return self.getToken(NeoBasicParser.EON, 0)

        def EPOCH(self):
            return self.getToken(NeoBasicParser.EPOCH, 0)

        def LETTER(self):
            return self.getToken(NeoBasicParser.LETTER, 0)

        def DIGIT(self):
            return self.getToken(NeoBasicParser.DIGIT, 0)

        def PUNCTUATION(self):
            return self.getToken(NeoBasicParser.PUNCTUATION, 0)

        def SYMBOL(self):
            return self.getToken(NeoBasicParser.SYMBOL, 0)

        def SEPARATOR(self):
            return self.getToken(NeoBasicParser.SEPARATOR, 0)

        def NONPRINTABLE(self):
            return self.getToken(NeoBasicParser.NONPRINTABLE, 0)

        def NULL(self):
            return self.getToken(NeoBasicParser.NULL, 0)

        def NONBLANK(self):
            return self.getToken(NeoBasicParser.NONBLANK, 0)

        def BLANK(self):
            return self.getToken(NeoBasicParser.BLANK, 0)

        def FOLDER(self):
            return self.getToken(NeoBasicParser.FOLDER, 0)

        def FILE(self):
            return self.getToken(NeoBasicParser.FILE, 0)

        def LINKLINKFILE(self):
            return self.getToken(NeoBasicParser.LINKLINKFILE, 0)

        def PIPEFILE(self):
            return self.getToken(NeoBasicParser.PIPEFILE, 0)

        def SOCKETFILE(self):
            return self.getToken(NeoBasicParser.SOCKETFILE, 0)

        def BLOCKDEVICE(self):
            return self.getToken(NeoBasicParser.BLOCKDEVICE, 0)

        def CHARDEVICE(self):
            return self.getToken(NeoBasicParser.CHARDEVICE, 0)

        def NULLDEVICE(self):
            return self.getToken(NeoBasicParser.NULLDEVICE, 0)

        def OKAY(self):
            return self.getToken(NeoBasicParser.OKAY, 0)

        def FAIL(self):
            return self.getToken(NeoBasicParser.FAIL, 0)

        def SOME(self):
            return self.getToken(NeoBasicParser.SOME, 0)

        def NONE(self):
            return self.getToken(NeoBasicParser.NONE, 0)

        def YEA(self):
            return self.getToken(NeoBasicParser.YEA, 0)

        def NAY(self):
            return self.getToken(NeoBasicParser.NAY, 0)

        def DATUM(self):
            return self.getToken(NeoBasicParser.DATUM, 0)

        def EOT(self):
            return self.getToken(NeoBasicParser.EOT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_predeclaredFact

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredeclaredFact" ):
                listener.enterPredeclaredFact(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredeclaredFact" ):
                listener.exitPredeclaredFact(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredeclaredFact" ):
                return visitor.visitPredeclaredFact(self)
            else:
                return visitor.visitChildren(self)




    def predeclaredFact(self):

        localctx = NeoBasicParser.PredeclaredFactContext(self, self._ctx, self.state)
        self.enterRule(localctx, 862, self.RULE_predeclaredFact)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3328
            _la = self._input.LA(1)
            if not(((((_la - 216)) & ~0x3f) == 0 and ((1 << (_la - 216)) & 30874836259569659) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredeclaredFmapContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALL(self):
            return self.getToken(NeoBasicParser.ALL, 0)

        def ANY(self):
            return self.getToken(NeoBasicParser.ANY, 0)

        def LOT(self):
            return self.getToken(NeoBasicParser.LOT, 0)

        def NIL(self):
            return self.getToken(NeoBasicParser.NIL, 0)

        def ONE(self):
            return self.getToken(NeoBasicParser.ONE, 0)

        def TWO(self):
            return self.getToken(NeoBasicParser.TWO, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_predeclaredFmap

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredeclaredFmap" ):
                listener.enterPredeclaredFmap(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredeclaredFmap" ):
                listener.exitPredeclaredFmap(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredeclaredFmap" ):
                return visitor.visitPredeclaredFmap(self)
            else:
                return visitor.visitChildren(self)




    def predeclaredFmap(self):

        localctx = NeoBasicParser.PredeclaredFmapContext(self, self._ctx, self.state)
        self.enterRule(localctx, 864, self.RULE_predeclaredFmap)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3330
            _la = self._input.LA(1)
            if not(((((_la - 100)) & ~0x3f) == 0 and ((1 << (_la - 100)) & 63) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrimaryExpressionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.PrimaryExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_primaryExpressions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimaryExpressions" ):
                listener.enterPrimaryExpressions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimaryExpressions" ):
                listener.exitPrimaryExpressions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimaryExpressions" ):
                return visitor.visitPrimaryExpressions(self)
            else:
                return visitor.visitChildren(self)




    def primaryExpressions(self):

        localctx = NeoBasicParser.PrimaryExpressionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 866, self.RULE_primaryExpressions)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3332
            self.primaryExpression(0)
            self.state = 3337
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,316,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 3333
                    self.match(NeoBasicParser.COMMA)
                    self.state = 3334
                    self.primaryExpression(0) 
                self.state = 3339
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,316,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrimaryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primaryOperand(self):
            return self.getTypedRuleContext(NeoBasicParser.PrimaryOperandContext,0)


        def sos_Expression(self):
            return self.getTypedRuleContext(NeoBasicParser.Sos_ExpressionContext,0)


        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def prefixUnaryOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.PrefixUnaryOperatorContext,0)


        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.PrimaryExpressionContext,i)


        def primaryFunctor(self):
            return self.getTypedRuleContext(NeoBasicParser.PrimaryFunctorContext,0)


        def juxtapositionExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.JuxtapositionExpressionContext,0)


        def DOT(self):
            return self.getToken(NeoBasicParser.DOT, 0)

        def LEFT_BRACKET(self):
            return self.getToken(NeoBasicParser.LEFT_BRACKET, 0)

        def arrayIndexing(self):
            return self.getTypedRuleContext(NeoBasicParser.ArrayIndexingContext,0)


        def RIGHT_BRACKET(self):
            return self.getToken(NeoBasicParser.RIGHT_BRACKET, 0)

        def parenthesizedArguments(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedArgumentsContext,0)


        def genericTypeParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.GenericTypeParametersContext,0)


        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def macroOption(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.MacroOptionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.MacroOptionContext,i)


        def SEMICOLON(self):
            return self.getToken(NeoBasicParser.SEMICOLON, 0)

        def formatType(self):
            return self.getTypedRuleContext(NeoBasicParser.FormatTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_primaryExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimaryExpression" ):
                listener.enterPrimaryExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimaryExpression" ):
                listener.exitPrimaryExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimaryExpression" ):
                return visitor.visitPrimaryExpression(self)
            else:
                return visitor.visitChildren(self)



    def primaryExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = NeoBasicParser.PrimaryExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 868
        self.enterRecursionRule(localctx, 868, self.RULE_primaryExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3351
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,317,self._ctx)
            if la_ == 1:
                self.state = 3341
                self.primaryOperand()
                pass

            elif la_ == 2:
                self.state = 3342
                self.sos_Expression()
                pass

            elif la_ == 3:
                self.state = 3343
                self.parenthesizedExpression()
                pass

            elif la_ == 4:
                self.state = 3344
                self.prefixUnaryOperator()
                self.state = 3345
                self.primaryExpression(4)
                pass

            elif la_ == 5:
                self.state = 3347
                self.primaryFunctor()
                self.state = 3348
                self.primaryExpression(2)
                pass

            elif la_ == 6:
                self.state = 3350
                self.juxtapositionExpression()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 3379
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,321,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 3377
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,320,self._ctx)
                    if la_ == 1:
                        localctx = NeoBasicParser.PrimaryExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 3353
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 3354
                        self.match(NeoBasicParser.DOT)
                        self.state = 3355
                        self.primaryExpression(8)
                        pass

                    elif la_ == 2:
                        localctx = NeoBasicParser.PrimaryExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 3356
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 3357
                        self.match(NeoBasicParser.LEFT_BRACKET)
                        self.state = 3358
                        self.arrayIndexing()
                        self.state = 3359
                        self.match(NeoBasicParser.RIGHT_BRACKET)
                        pass

                    elif la_ == 3:
                        localctx = NeoBasicParser.PrimaryExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 3361
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 3363
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==313:
                            self.state = 3362
                            self.genericTypeParameters()


                        self.state = 3365
                        self.parenthesizedArguments()
                        pass

                    elif la_ == 4:
                        localctx = NeoBasicParser.PrimaryExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 3366
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 3367
                        self.expressions()
                        self.state = 3371
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,319,self._ctx)
                        while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                            if _alt==1:
                                self.state = 3368
                                self.macroOption() 
                            self.state = 3373
                            self._errHandler.sync(self)
                            _alt = self._interp.adaptivePredict(self._input,319,self._ctx)

                        pass

                    elif la_ == 5:
                        localctx = NeoBasicParser.PrimaryExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 3374
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 3375
                        self.match(NeoBasicParser.SEMICOLON)
                        self.state = 3376
                        self.formatType()
                        pass

             
                self.state = 3381
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,321,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class PrimaryOperandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def predeclaredValue(self):
            return self.getTypedRuleContext(NeoBasicParser.PredeclaredValueContext,0)


        def literal(self):
            return self.getTypedRuleContext(NeoBasicParser.LiteralContext,0)


        def IDENTIFIER(self):
            return self.getToken(NeoBasicParser.IDENTIFIER, 0)

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_primaryOperand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimaryOperand" ):
                listener.enterPrimaryOperand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimaryOperand" ):
                listener.exitPrimaryOperand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimaryOperand" ):
                return visitor.visitPrimaryOperand(self)
            else:
                return visitor.visitChildren(self)




    def primaryOperand(self):

        localctx = NeoBasicParser.PrimaryOperandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 870, self.RULE_primaryOperand)
        try:
            self.state = 3387
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,322,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3382
                self.predeclaredValue()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3383
                self.literal()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3384
                self.match(NeoBasicParser.IDENTIFIER)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 3385
                self.qualifiedIdentifier()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 3386
                self.type_(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrimaryFunctorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def predeclaredFunctor(self):
            return self.getTypedRuleContext(NeoBasicParser.PredeclaredFunctorContext,0)


        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_primaryFunctor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimaryFunctor" ):
                listener.enterPrimaryFunctor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimaryFunctor" ):
                listener.exitPrimaryFunctor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimaryFunctor" ):
                return visitor.visitPrimaryFunctor(self)
            else:
                return visitor.visitChildren(self)




    def primaryFunctor(self):

        localctx = NeoBasicParser.PrimaryFunctorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 872, self.RULE_primaryFunctor)
        try:
            self.state = 3391
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [100, 101, 102, 103, 104, 105, 216, 217, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 260, 261, 263, 264, 266, 267, 269, 270]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3389
                self.predeclaredFunctor()
                pass
            elif token in [381]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3390
                self.qualifiedIdentifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Sos_ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LEFT_PARENTHESIS, 0)

        def statementSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementSentenceContext,0)


        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_sos_Expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSos_Expression" ):
                listener.enterSos_Expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSos_Expression" ):
                listener.exitSos_Expression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSos_Expression" ):
                return visitor.visitSos_Expression(self)
            else:
                return visitor.visitChildren(self)




    def sos_Expression(self):

        localctx = NeoBasicParser.Sos_ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 874, self.RULE_sos_Expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3393
            self.match(NeoBasicParser.LEFT_PARENTHESIS)
            self.state = 3394
            self.statementSentence()
            self.state = 3395
            self.match(NeoBasicParser.RIGHT_PARENTHESIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParenthesizedExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LEFT_PARENTHESIS, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_parenthesizedExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenthesizedExpression" ):
                listener.enterParenthesizedExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenthesizedExpression" ):
                listener.exitParenthesizedExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenthesizedExpression" ):
                return visitor.visitParenthesizedExpression(self)
            else:
                return visitor.visitChildren(self)




    def parenthesizedExpression(self):

        localctx = NeoBasicParser.ParenthesizedExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 876, self.RULE_parenthesizedExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3397
            self.match(NeoBasicParser.LEFT_PARENTHESIS)
            self.state = 3398
            self.expression(0)
            self.state = 3399
            self.match(NeoBasicParser.RIGHT_PARENTHESIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayIndexingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def intervalExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.IntervalExpressionContext,0)


        def sliceExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.SliceExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_arrayIndexing

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayIndexing" ):
                listener.enterArrayIndexing(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayIndexing" ):
                listener.exitArrayIndexing(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayIndexing" ):
                return visitor.visitArrayIndexing(self)
            else:
                return visitor.visitChildren(self)




    def arrayIndexing(self):

        localctx = NeoBasicParser.ArrayIndexingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 878, self.RULE_arrayIndexing)
        try:
            self.state = 3404
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,324,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3401
                self.expressions()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3402
                self.intervalExpression(0)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3403
                self.sliceExpression(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntervalExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,i)


        def intervalOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.IntervalOperatorContext,0)


        def leftIntervalOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.LeftIntervalOperatorContext,0)


        def rightIntervalOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.RightIntervalOperatorContext,0)


        def intervalExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.IntervalExpressionContext,0)


        def INTERVAL_INCLUSIVE(self):
            return self.getToken(NeoBasicParser.INTERVAL_INCLUSIVE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_intervalExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntervalExpression" ):
                listener.enterIntervalExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntervalExpression" ):
                listener.exitIntervalExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntervalExpression" ):
                return visitor.visitIntervalExpression(self)
            else:
                return visitor.visitChildren(self)



    def intervalExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = NeoBasicParser.IntervalExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 880
        self.enterRecursionRule(localctx, 880, self.RULE_intervalExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3417
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,325,self._ctx)
            if la_ == 1:
                self.state = 3407
                self.expression(0)
                self.state = 3408
                self.intervalOperator()
                self.state = 3409
                self.expression(0)
                pass

            elif la_ == 2:
                self.state = 3411
                self.expression(0)
                self.state = 3412
                self.leftIntervalOperator()
                pass

            elif la_ == 3:
                self.state = 3414
                self.rightIntervalOperator()
                self.state = 3415
                self.expression(0)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 3424
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,326,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = NeoBasicParser.IntervalExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_intervalExpression)
                    self.state = 3419
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 3420
                    self.match(NeoBasicParser.INTERVAL_INCLUSIVE)
                    self.state = 3421
                    self.expression(0) 
                self.state = 3426
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,326,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class SliceExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,i)


        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def sliceExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.SliceExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_sliceExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSliceExpression" ):
                listener.enterSliceExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSliceExpression" ):
                listener.exitSliceExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSliceExpression" ):
                return visitor.visitSliceExpression(self)
            else:
                return visitor.visitChildren(self)



    def sliceExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = NeoBasicParser.SliceExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 882
        self.enterRecursionRule(localctx, 882, self.RULE_sliceExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3437
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,327,self._ctx)
            if la_ == 1:
                self.state = 3428
                self.expression(0)
                self.state = 3429
                self.match(NeoBasicParser.COLON)
                self.state = 3430
                self.expression(0)
                pass

            elif la_ == 2:
                self.state = 3432
                self.match(NeoBasicParser.COLON)
                self.state = 3433
                self.expression(0)
                pass

            elif la_ == 3:
                self.state = 3434
                self.expression(0)
                self.state = 3435
                self.match(NeoBasicParser.COLON)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 3444
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,328,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = NeoBasicParser.SliceExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_sliceExpression)
                    self.state = 3439
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 3440
                    self.match(NeoBasicParser.COLON)
                    self.state = 3441
                    self.expression(0) 
                self.state = 3446
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,328,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class FormatTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def ATOM_IDENTIFIER(self):
            return self.getToken(NeoBasicParser.ATOM_IDENTIFIER, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.StringLiteralContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_formatType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormatType" ):
                listener.enterFormatType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormatType" ):
                listener.exitFormatType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFormatType" ):
                return visitor.visitFormatType(self)
            else:
                return visitor.visitChildren(self)




    def formatType(self):

        localctx = NeoBasicParser.FormatTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 884, self.RULE_formatType)
        try:
            self.state = 3450
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6, 13, 17, 21, 22, 23, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 45, 46, 47, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 259, 262, 265, 268, 381, 434]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3447
                self.type_(0)
                pass
            elif token in [382]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3448
                self.match(NeoBasicParser.ATOM_IDENTIFIER)
                pass
            elif token in [395, 397, 399]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3449
                self.stringLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MacroOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TILDE(self):
            return self.getToken(NeoBasicParser.TILDE, 0)

        def IDENTIFIER(self):
            return self.getToken(NeoBasicParser.IDENTIFIER, 0)

        def EQUAL(self):
            return self.getToken(NeoBasicParser.EQUAL, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_macroOption

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMacroOption" ):
                listener.enterMacroOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMacroOption" ):
                listener.exitMacroOption(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMacroOption" ):
                return visitor.visitMacroOption(self)
            else:
                return visitor.visitChildren(self)




    def macroOption(self):

        localctx = NeoBasicParser.MacroOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 886, self.RULE_macroOption)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3452
            self.match(NeoBasicParser.TILDE)
            self.state = 3453
            self.match(NeoBasicParser.IDENTIFIER)

            self.state = 3454
            self.match(NeoBasicParser.EQUAL)
            self.state = 3455
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JuxtapositionExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sequenceLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.SequenceLiteralContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.SequenceLiteralContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_juxtapositionExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJuxtapositionExpression" ):
                listener.enterJuxtapositionExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJuxtapositionExpression" ):
                listener.exitJuxtapositionExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJuxtapositionExpression" ):
                return visitor.visitJuxtapositionExpression(self)
            else:
                return visitor.visitChildren(self)




    def juxtapositionExpression(self):

        localctx = NeoBasicParser.JuxtapositionExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 888, self.RULE_juxtapositionExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3458 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 3457
                    self.sequenceLiteral()

                else:
                    raise NoViableAltException(self)
                self.state = 3460 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,330,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_expressions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressions" ):
                listener.enterExpressions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressions" ):
                listener.exitExpressions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressions" ):
                return visitor.visitExpressions(self)
            else:
                return visitor.visitChildren(self)




    def expressions(self):

        localctx = NeoBasicParser.ExpressionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 890, self.RULE_expressions)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3462
            self.expression(0)
            self.state = 3467
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,331,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 3463
                    self.match(NeoBasicParser.COMMA)
                    self.state = 3464
                    self.expression(0) 
                self.state = 3469
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,331,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primaryExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.PrimaryExpressionContext,0)


        def guardsExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.GuardsExpressionContext,0)


        def shellProcess(self):
            return self.getTypedRuleContext(NeoBasicParser.ShellProcessContext,0)


        def assignmentExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.AssignmentExpressionContext,0)


        def FUNCTOR(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.FUNCTOR)
            else:
                return self.getToken(NeoBasicParser.FUNCTOR, i)

        def primaryFunctor(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.PrimaryFunctorContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.PrimaryFunctorContext,i)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,i)


        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def parenthesizedArguments(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedArgumentsContext,0)


        def lambdaLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.LambdaLiteralContext,0)


        def binaryExponentialOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryExponentialOperatorContext,0)


        def binaryMultiplicativeOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryMultiplicativeOperatorContext,0)


        def bitShiftOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BitShiftOperatorContext,0)


        def binaryAdditiveOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryAdditiveOperatorContext,0)


        def binaryArrayOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryArrayOperatorContext,0)


        def binaryComparisonOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryComparisonOperatorContext,0)


        def binaryRelationalOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryRelationalOperatorContext,0)


        def binaryConditionalOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryConditionalOperatorContext,0)


        def binaryConjunctionOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryConjunctionOperatorContext,0)


        def binaryExclusiveDisjunctionOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryExclusiveDisjunctionOperatorContext,0)


        def binaryDisjunctionOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryDisjunctionOperatorContext,0)


        def binaryMonadBindOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryMonadBindOperatorContext,0)


        def binaryPipelineOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryPipelineOperatorContext,0)


        def IF(self):
            return self.getToken(NeoBasicParser.IF, 0)

        def ELSE(self):
            return self.getToken(NeoBasicParser.ELSE, 0)

        def coalescingOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.CoalescingOperatorContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)



    def expression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = NeoBasicParser.ExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 892
        self.enterRecursionRule(localctx, 892, self.RULE_expression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3499
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,335,self._ctx)
            if la_ == 1:
                self.state = 3471
                self.primaryExpression(0)
                pass

            elif la_ == 2:
                self.state = 3472
                self.guardsExpression()
                pass

            elif la_ == 3:
                self.state = 3473
                self.shellProcess()
                pass

            elif la_ == 4:
                self.state = 3474
                self.assignmentExpression()
                pass

            elif la_ == 5:
                self.state = 3475
                self.primaryExpression(0)
                self.state = 3478 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 3476
                        self.match(NeoBasicParser.FUNCTOR)
                        self.state = 3477
                        self.primaryFunctor()

                    else:
                        raise NoViableAltException(self)
                    self.state = 3480 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,332,self._ctx)

                self.state = 3483
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,333,self._ctx)
                if la_ == 1:
                    self.state = 3482
                    self.expression(0)


                pass

            elif la_ == 6:
                self.state = 3485
                self.primaryFunctor()
                self.state = 3490
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==339:
                    self.state = 3486
                    self.match(NeoBasicParser.FUNCTOR)
                    self.state = 3487
                    self.primaryFunctor()
                    self.state = 3492
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 3493
                self.expressions()
                pass

            elif la_ == 7:
                self.state = 3495
                self.primaryExpression(0)
                self.state = 3496
                self.parenthesizedArguments()
                self.state = 3497
                self.lambdaLiteral()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 3566
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,338,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 3564
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,337,self._ctx)
                    if la_ == 1:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3501
                        if not self.precpred(self._ctx, 21):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 21)")
                        self.state = 3502
                        self.binaryExponentialOperator()
                        self.state = 3503
                        self.expression(22)
                        pass

                    elif la_ == 2:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3505
                        if not self.precpred(self._ctx, 20):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 20)")
                        self.state = 3506
                        self.binaryMultiplicativeOperator()
                        self.state = 3507
                        self.expression(21)
                        pass

                    elif la_ == 3:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3509
                        if not self.precpred(self._ctx, 19):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 19)")
                        self.state = 3510
                        self.bitShiftOperator()
                        self.state = 3511
                        self.expression(20)
                        pass

                    elif la_ == 4:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3513
                        if not self.precpred(self._ctx, 18):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 18)")
                        self.state = 3514
                        self.binaryAdditiveOperator()
                        self.state = 3515
                        self.expression(19)
                        pass

                    elif la_ == 5:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3517
                        if not self.precpred(self._ctx, 17):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 17)")
                        self.state = 3518
                        self.binaryArrayOperator()
                        self.state = 3519
                        self.expression(18)
                        pass

                    elif la_ == 6:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3521
                        if not self.precpred(self._ctx, 16):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
                        self.state = 3522
                        self.binaryComparisonOperator()
                        self.state = 3523
                        self.expression(17)
                        pass

                    elif la_ == 7:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3525
                        if not self.precpred(self._ctx, 15):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
                        self.state = 3526
                        self.binaryRelationalOperator()
                        self.state = 3527
                        self.expression(16)
                        pass

                    elif la_ == 8:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3529
                        if not self.precpred(self._ctx, 14):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 14)")
                        self.state = 3530
                        self.binaryConditionalOperator()
                        self.state = 3531
                        self.expression(15)
                        pass

                    elif la_ == 9:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3533
                        if not self.precpred(self._ctx, 13):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
                        self.state = 3534
                        self.binaryConjunctionOperator()
                        self.state = 3535
                        self.expression(14)
                        pass

                    elif la_ == 10:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3537
                        if not self.precpred(self._ctx, 12):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
                        self.state = 3538
                        self.binaryExclusiveDisjunctionOperator()
                        self.state = 3539
                        self.expression(13)
                        pass

                    elif la_ == 11:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3541
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 11)")
                        self.state = 3542
                        self.binaryDisjunctionOperator()
                        self.state = 3543
                        self.expression(12)
                        pass

                    elif la_ == 12:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3545
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 3546
                        self.binaryMonadBindOperator()
                        self.state = 3547
                        self.expression(11)
                        pass

                    elif la_ == 13:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3549
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 3550
                        self.binaryPipelineOperator()
                        self.state = 3551
                        self.expression(10)
                        pass

                    elif la_ == 14:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3553
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 3554
                        self.match(NeoBasicParser.IF)
                        self.state = 3555
                        self.expression(0)
                        self.state = 3556
                        self.match(NeoBasicParser.ELSE)
                        self.state = 3557
                        self.expression(8)
                        pass

                    elif la_ == 15:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3559
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 3560
                        self.coalescingOperator()
                        self.state = 3562
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,336,self._ctx)
                        if la_ == 1:
                            self.state = 3561
                            self.expression(0)


                        pass

             
                self.state = 3568
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,338,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class GuardsExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def guardClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.GuardClauseContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.GuardClauseContext,i)


        def guardDefault(self):
            return self.getTypedRuleContext(NeoBasicParser.GuardDefaultContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_guardsExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGuardsExpression" ):
                listener.enterGuardsExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGuardsExpression" ):
                listener.exitGuardsExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGuardsExpression" ):
                return visitor.visitGuardsExpression(self)
            else:
                return visitor.visitChildren(self)




    def guardsExpression(self):

        localctx = NeoBasicParser.GuardsExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 894, self.RULE_guardsExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3570 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 3569
                    self.guardClause()

                else:
                    raise NoViableAltException(self)
                self.state = 3572 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,339,self._ctx)

            self.state = 3575
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,340,self._ctx)
            if la_ == 1:
                self.state = 3574
                self.guardDefault()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GuardClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PIPE(self):
            return self.getToken(NeoBasicParser.PIPE, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,i)


        def IMPLICIT_RETURN(self):
            return self.getToken(NeoBasicParser.IMPLICIT_RETURN, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_guardClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGuardClause" ):
                listener.enterGuardClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGuardClause" ):
                listener.exitGuardClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGuardClause" ):
                return visitor.visitGuardClause(self)
            else:
                return visitor.visitChildren(self)




    def guardClause(self):

        localctx = NeoBasicParser.GuardClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 896, self.RULE_guardClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3577
            self.match(NeoBasicParser.PIPE)
            self.state = 3578
            self.expression(0)
            self.state = 3579
            self.match(NeoBasicParser.IMPLICIT_RETURN)
            self.state = 3580
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GuardDefaultContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PIPE(self):
            return self.getToken(NeoBasicParser.PIPE, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_guardDefault

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGuardDefault" ):
                listener.enterGuardDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGuardDefault" ):
                listener.exitGuardDefault(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGuardDefault" ):
                return visitor.visitGuardDefault(self)
            else:
                return visitor.visitChildren(self)




    def guardDefault(self):

        localctx = NeoBasicParser.GuardDefaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 898, self.RULE_guardDefault)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3582
            self.match(NeoBasicParser.PIPE)
            self.state = 3583
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShellProcessContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shellPathLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.ShellPathLiteralContext,0)


        def LEFT_CURLY(self):
            return self.getToken(NeoBasicParser.LEFT_CURLY, 0)

        def statementBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementBlockContext,0)


        def RIGHT_CURLY(self):
            return self.getToken(NeoBasicParser.RIGHT_CURLY, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_shellProcess

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShellProcess" ):
                listener.enterShellProcess(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShellProcess" ):
                listener.exitShellProcess(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShellProcess" ):
                return visitor.visitShellProcess(self)
            else:
                return visitor.visitChildren(self)




    def shellProcess(self):

        localctx = NeoBasicParser.ShellProcessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 900, self.RULE_shellProcess)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3585
            self.shellPathLiteral()
            self.state = 3586
            self.match(NeoBasicParser.LEFT_CURLY)
            self.state = 3587
            self.statementBlock()
            self.state = 3588
            self.match(NeoBasicParser.RIGHT_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primaryExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.PrimaryExpressionContext,0)


        def assignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.AssignmentOperatorContext,0)


        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_assignmentExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentExpression" ):
                listener.enterAssignmentExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentExpression" ):
                listener.exitAssignmentExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignmentExpression" ):
                return visitor.visitAssignmentExpression(self)
            else:
                return visitor.visitChildren(self)




    def assignmentExpression(self):

        localctx = NeoBasicParser.AssignmentExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 902, self.RULE_assignmentExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3590
            self.primaryExpression(0)
            self.state = 3591
            self.assignmentOperator()
            self.state = 3592
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[204] = self.simpleStatement_sempred
        self._predicates[334] = self.type_sempred
        self._predicates[434] = self.primaryExpression_sempred
        self._predicates[440] = self.intervalExpression_sempred
        self._predicates[441] = self.sliceExpression_sempred
        self._predicates[446] = self.expression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def simpleStatement_sempred(self, localctx:SimpleStatementContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 10)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 9)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 7)
         

    def type_sempred(self, localctx:TypeContext, predIndex:int):
            if predIndex == 4:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 8:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 9:
                return self.precpred(self._ctx, 7)
         

    def primaryExpression_sempred(self, localctx:PrimaryExpressionContext, predIndex:int):
            if predIndex == 10:
                return self.precpred(self._ctx, 7)
         

            if predIndex == 11:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 12:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 13:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 14:
                return self.precpred(self._ctx, 3)
         

    def intervalExpression_sempred(self, localctx:IntervalExpressionContext, predIndex:int):
            if predIndex == 15:
                return self.precpred(self._ctx, 1)
         

    def sliceExpression_sempred(self, localctx:SliceExpressionContext, predIndex:int):
            if predIndex == 16:
                return self.precpred(self._ctx, 1)
         

    def expression_sempred(self, localctx:ExpressionContext, predIndex:int):
            if predIndex == 17:
                return self.precpred(self._ctx, 21)
         

            if predIndex == 18:
                return self.precpred(self._ctx, 20)
         

            if predIndex == 19:
                return self.precpred(self._ctx, 19)
         

            if predIndex == 20:
                return self.precpred(self._ctx, 18)
         

            if predIndex == 21:
                return self.precpred(self._ctx, 17)
         

            if predIndex == 22:
                return self.precpred(self._ctx, 16)
         

            if predIndex == 23:
                return self.precpred(self._ctx, 15)
         

            if predIndex == 24:
                return self.precpred(self._ctx, 14)
         

            if predIndex == 25:
                return self.precpred(self._ctx, 13)
         

            if predIndex == 26:
                return self.precpred(self._ctx, 12)
         

            if predIndex == 27:
                return self.precpred(self._ctx, 11)
         

            if predIndex == 28:
                return self.precpred(self._ctx, 10)
         

            if predIndex == 29:
                return self.precpred(self._ctx, 9)
         

            if predIndex == 30:
                return self.precpred(self._ctx, 7)
         

            if predIndex == 31:
                return self.precpred(self._ctx, 8)
         




