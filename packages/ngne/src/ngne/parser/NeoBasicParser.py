# Generated from NeoBasicParser.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,498,3515,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
        91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,
        98,7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,
        2,104,7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,
        7,109,2,110,7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,
        2,115,7,115,2,116,7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,
        7,120,2,121,7,121,2,122,7,122,2,123,7,123,2,124,7,124,2,125,7,125,
        2,126,7,126,2,127,7,127,2,128,7,128,2,129,7,129,2,130,7,130,2,131,
        7,131,2,132,7,132,2,133,7,133,2,134,7,134,2,135,7,135,2,136,7,136,
        2,137,7,137,2,138,7,138,2,139,7,139,2,140,7,140,2,141,7,141,2,142,
        7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,7,146,2,147,7,147,
        2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,7,152,2,153,
        7,153,2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,7,158,
        2,159,7,159,2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,2,164,
        7,164,2,165,7,165,2,166,7,166,2,167,7,167,2,168,7,168,2,169,7,169,
        2,170,7,170,2,171,7,171,2,172,7,172,2,173,7,173,2,174,7,174,2,175,
        7,175,2,176,7,176,2,177,7,177,2,178,7,178,2,179,7,179,2,180,7,180,
        2,181,7,181,2,182,7,182,2,183,7,183,2,184,7,184,2,185,7,185,2,186,
        7,186,2,187,7,187,2,188,7,188,2,189,7,189,2,190,7,190,2,191,7,191,
        2,192,7,192,2,193,7,193,2,194,7,194,2,195,7,195,2,196,7,196,2,197,
        7,197,2,198,7,198,2,199,7,199,2,200,7,200,2,201,7,201,2,202,7,202,
        2,203,7,203,2,204,7,204,2,205,7,205,2,206,7,206,2,207,7,207,2,208,
        7,208,2,209,7,209,2,210,7,210,2,211,7,211,2,212,7,212,2,213,7,213,
        2,214,7,214,2,215,7,215,2,216,7,216,2,217,7,217,2,218,7,218,2,219,
        7,219,2,220,7,220,2,221,7,221,2,222,7,222,2,223,7,223,2,224,7,224,
        2,225,7,225,2,226,7,226,2,227,7,227,2,228,7,228,2,229,7,229,2,230,
        7,230,2,231,7,231,2,232,7,232,2,233,7,233,2,234,7,234,2,235,7,235,
        2,236,7,236,2,237,7,237,2,238,7,238,2,239,7,239,2,240,7,240,2,241,
        7,241,2,242,7,242,2,243,7,243,2,244,7,244,2,245,7,245,2,246,7,246,
        2,247,7,247,2,248,7,248,2,249,7,249,2,250,7,250,2,251,7,251,2,252,
        7,252,2,253,7,253,2,254,7,254,2,255,7,255,2,256,7,256,2,257,7,257,
        2,258,7,258,2,259,7,259,2,260,7,260,2,261,7,261,2,262,7,262,2,263,
        7,263,2,264,7,264,2,265,7,265,2,266,7,266,2,267,7,267,2,268,7,268,
        2,269,7,269,2,270,7,270,2,271,7,271,2,272,7,272,2,273,7,273,2,274,
        7,274,2,275,7,275,2,276,7,276,2,277,7,277,2,278,7,278,2,279,7,279,
        2,280,7,280,2,281,7,281,2,282,7,282,2,283,7,283,2,284,7,284,2,285,
        7,285,2,286,7,286,2,287,7,287,2,288,7,288,2,289,7,289,2,290,7,290,
        2,291,7,291,2,292,7,292,2,293,7,293,2,294,7,294,2,295,7,295,2,296,
        7,296,2,297,7,297,2,298,7,298,2,299,7,299,2,300,7,300,2,301,7,301,
        2,302,7,302,2,303,7,303,2,304,7,304,2,305,7,305,2,306,7,306,2,307,
        7,307,2,308,7,308,2,309,7,309,2,310,7,310,2,311,7,311,2,312,7,312,
        2,313,7,313,2,314,7,314,2,315,7,315,2,316,7,316,2,317,7,317,2,318,
        7,318,2,319,7,319,2,320,7,320,2,321,7,321,2,322,7,322,2,323,7,323,
        2,324,7,324,2,325,7,325,2,326,7,326,2,327,7,327,2,328,7,328,2,329,
        7,329,2,330,7,330,2,331,7,331,2,332,7,332,2,333,7,333,2,334,7,334,
        2,335,7,335,2,336,7,336,2,337,7,337,2,338,7,338,2,339,7,339,2,340,
        7,340,2,341,7,341,2,342,7,342,2,343,7,343,2,344,7,344,2,345,7,345,
        2,346,7,346,2,347,7,347,2,348,7,348,2,349,7,349,2,350,7,350,2,351,
        7,351,2,352,7,352,2,353,7,353,2,354,7,354,2,355,7,355,2,356,7,356,
        2,357,7,357,2,358,7,358,2,359,7,359,2,360,7,360,2,361,7,361,2,362,
        7,362,2,363,7,363,2,364,7,364,2,365,7,365,2,366,7,366,2,367,7,367,
        2,368,7,368,2,369,7,369,2,370,7,370,2,371,7,371,2,372,7,372,2,373,
        7,373,2,374,7,374,2,375,7,375,2,376,7,376,2,377,7,377,2,378,7,378,
        2,379,7,379,2,380,7,380,2,381,7,381,2,382,7,382,2,383,7,383,2,384,
        7,384,2,385,7,385,2,386,7,386,2,387,7,387,2,388,7,388,2,389,7,389,
        2,390,7,390,2,391,7,391,2,392,7,392,2,393,7,393,2,394,7,394,2,395,
        7,395,2,396,7,396,2,397,7,397,2,398,7,398,2,399,7,399,2,400,7,400,
        2,401,7,401,2,402,7,402,2,403,7,403,2,404,7,404,2,405,7,405,2,406,
        7,406,2,407,7,407,2,408,7,408,2,409,7,409,2,410,7,410,2,411,7,411,
        2,412,7,412,2,413,7,413,2,414,7,414,2,415,7,415,2,416,7,416,2,417,
        7,417,2,418,7,418,2,419,7,419,2,420,7,420,2,421,7,421,2,422,7,422,
        2,423,7,423,2,424,7,424,2,425,7,425,2,426,7,426,2,427,7,427,2,428,
        7,428,2,429,7,429,2,430,7,430,2,431,7,431,2,432,7,432,2,433,7,433,
        2,434,7,434,2,435,7,435,2,436,7,436,2,437,7,437,2,438,7,438,2,439,
        7,439,2,440,7,440,2,441,7,441,2,442,7,442,2,443,7,443,2,444,7,444,
        2,445,7,445,1,0,1,0,1,0,1,1,1,1,1,2,1,2,1,3,1,3,1,3,3,3,903,8,3,
        1,4,1,4,1,4,4,4,908,8,4,11,4,12,4,909,1,5,1,5,1,5,1,5,1,5,5,5,917,
        8,5,10,5,12,5,920,9,5,1,5,1,5,1,6,1,6,1,6,3,6,927,8,6,1,7,1,7,1,
        7,1,7,1,8,1,8,1,8,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,3,9,944,8,9,1,
        10,1,10,1,10,3,10,949,8,10,1,10,1,10,1,11,1,11,1,11,3,11,956,8,11,
        1,12,1,12,1,12,3,12,961,8,12,1,13,1,13,1,13,1,14,1,14,1,15,1,15,
        3,15,970,8,15,1,16,1,16,1,16,1,17,1,17,1,17,1,17,1,18,1,18,1,19,
        1,19,1,19,5,19,984,8,19,10,19,12,19,987,9,19,1,20,3,20,990,8,20,
        1,20,1,20,1,21,3,21,995,8,21,1,21,1,21,1,22,1,22,1,22,1,23,1,23,
        3,23,1004,8,23,1,24,1,24,3,24,1008,8,24,1,25,3,25,1011,8,25,1,25,
        1,25,3,25,1015,8,25,1,26,1,26,1,26,5,26,1020,8,26,10,26,12,26,1023,
        9,26,1,27,1,27,1,27,5,27,1028,8,27,10,27,12,27,1031,9,27,1,28,1,
        28,1,28,5,28,1036,8,28,10,28,12,28,1039,9,28,1,29,1,29,1,29,5,29,
        1044,8,29,10,29,12,29,1047,9,29,1,30,1,30,1,30,5,30,1052,8,30,10,
        30,12,30,1055,9,30,1,31,1,31,1,31,5,31,1060,8,31,10,31,12,31,1063,
        9,31,1,32,1,32,1,32,1,32,1,32,3,32,1070,8,32,1,33,1,33,1,33,3,33,
        1075,8,33,1,34,1,34,3,34,1079,8,34,1,35,1,35,1,35,1,36,1,36,1,36,
        1,37,1,37,3,37,1089,8,37,1,38,1,38,1,38,3,38,1094,8,38,1,39,1,39,
        1,39,1,39,1,39,1,40,1,40,1,40,5,40,1104,8,40,10,40,12,40,1107,9,
        40,1,41,1,41,3,41,1111,8,41,1,42,1,42,3,42,1115,8,42,1,43,1,43,1,
        43,4,43,1120,8,43,11,43,12,43,1121,1,44,1,44,1,44,3,44,1127,8,44,
        1,45,1,45,1,45,1,45,1,45,1,46,1,46,1,46,5,46,1137,8,46,10,46,12,
        46,1140,9,46,1,47,1,47,1,48,1,48,1,49,1,49,1,49,5,49,1149,8,49,10,
        49,12,49,1152,9,49,1,50,1,50,1,51,1,51,1,51,3,51,1159,8,51,1,52,
        1,52,1,52,1,52,1,52,1,53,1,53,1,53,5,53,1169,8,53,10,53,12,53,1172,
        9,53,1,54,1,54,1,54,1,54,3,54,1178,8,54,1,55,1,55,1,56,1,56,1,56,
        4,56,1185,8,56,11,56,12,56,1186,1,57,1,57,1,57,1,57,1,58,1,58,1,
        58,1,58,1,59,1,59,1,60,1,60,1,60,3,60,1202,8,60,1,60,1,60,1,61,1,
        61,1,62,1,62,1,63,1,63,1,63,3,63,1213,8,63,1,64,1,64,1,64,1,64,1,
        64,1,65,1,65,1,65,5,65,1223,8,65,10,65,12,65,1226,9,65,1,66,1,66,
        1,66,3,66,1231,8,66,1,67,1,67,1,68,1,68,1,68,4,68,1238,8,68,11,68,
        12,68,1239,1,69,1,69,1,69,1,69,1,70,4,70,1247,8,70,11,70,12,70,1248,
        1,70,1,70,1,70,1,70,1,70,3,70,1256,8,70,1,71,1,71,1,71,3,71,1261,
        8,71,1,72,1,72,3,72,1265,8,72,1,72,5,72,1268,8,72,10,72,12,72,1271,
        9,72,1,72,3,72,1274,8,72,1,73,1,73,1,73,1,73,3,73,1280,8,73,1,74,
        1,74,1,75,1,75,1,75,1,75,1,75,1,75,5,75,1290,8,75,10,75,12,75,1293,
        9,75,1,75,1,75,1,76,1,76,1,76,1,77,1,77,1,77,1,78,1,78,1,78,1,79,
        1,79,1,79,3,79,1309,8,79,1,80,1,80,3,80,1313,8,80,1,80,1,80,1,81,
        1,81,1,81,5,81,1320,8,81,10,81,12,81,1323,9,81,1,82,1,82,3,82,1327,
        8,82,1,82,1,82,1,83,1,83,3,83,1333,8,83,1,83,1,83,1,84,1,84,1,84,
        5,84,1340,8,84,10,84,12,84,1343,9,84,1,85,3,85,1346,8,85,1,85,3,
        85,1349,8,85,1,85,1,85,3,85,1353,8,85,1,85,3,85,1356,8,85,1,85,1,
        85,3,85,1360,8,85,1,86,1,86,1,87,1,87,1,88,1,88,1,88,1,88,1,88,1,
        88,3,88,1372,8,88,1,89,1,89,1,89,1,89,3,89,1378,8,89,1,90,1,90,1,
        91,1,91,1,91,1,92,1,92,1,93,1,93,1,93,1,94,4,94,1391,8,94,11,94,
        12,94,1392,1,94,3,94,1396,8,94,1,95,1,95,1,95,1,95,1,95,1,95,1,96,
        1,96,1,96,1,96,3,96,1408,8,96,1,96,1,96,1,97,1,97,1,97,1,97,1,97,
        1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,3,97,1427,8,97,
        1,98,1,98,1,99,1,99,1,99,3,99,1434,8,99,1,100,1,100,1,100,1,100,
        1,100,1,101,1,101,1,101,5,101,1444,8,101,10,101,12,101,1447,9,101,
        1,102,1,102,3,102,1451,8,102,1,103,1,103,1,103,1,103,1,104,1,104,
        3,104,1459,8,104,1,104,1,104,1,104,1,105,1,105,1,106,1,106,1,106,
        3,106,1469,8,106,1,107,1,107,1,107,1,107,1,107,1,108,1,108,1,108,
        5,108,1479,8,108,10,108,12,108,1482,9,108,1,109,1,109,1,109,3,109,
        1487,8,109,1,110,1,110,1,110,1,110,1,111,1,111,1,111,1,111,1,111,
        4,111,1498,8,111,11,111,12,111,1499,1,112,1,112,1,112,1,112,1,112,
        1,112,1,113,1,113,1,114,1,114,1,114,3,114,1513,8,114,1,115,1,115,
        1,115,1,115,1,115,1,116,1,116,1,116,5,116,1523,8,116,10,116,12,116,
        1526,9,116,1,117,1,117,1,117,3,117,1531,8,117,1,118,1,118,1,118,
        1,118,3,118,1537,8,118,1,119,1,119,1,119,4,119,1542,8,119,11,119,
        12,119,1543,1,120,1,120,1,120,1,120,1,120,1,120,1,121,1,121,1,122,
        1,122,1,122,3,122,1557,8,122,1,123,1,123,1,123,1,123,1,123,1,124,
        1,124,1,124,5,124,1567,8,124,10,124,12,124,1570,9,124,1,125,1,125,
        1,125,3,125,1575,8,125,1,126,1,126,1,126,1,126,3,126,1581,8,126,
        1,127,1,127,1,127,4,127,1586,8,127,11,127,12,127,1587,1,128,1,128,
        1,128,1,128,1,128,1,128,1,129,1,129,1,130,1,130,1,130,1,130,3,130,
        1602,8,130,1,130,1,130,1,131,1,131,1,132,1,132,1,132,1,132,1,132,
        3,132,1613,8,132,1,132,3,132,1616,8,132,1,133,1,133,1,134,1,134,
        1,134,1,134,1,134,3,134,1625,8,134,1,134,3,134,1628,8,134,1,135,
        1,135,1,136,1,136,1,136,1,136,3,136,1636,8,136,1,136,3,136,1639,
        8,136,1,137,1,137,1,138,1,138,1,138,1,138,1,138,3,138,1648,8,138,
        1,138,3,138,1651,8,138,1,139,1,139,3,139,1655,8,139,1,140,3,140,
        1658,8,140,1,140,1,140,3,140,1662,8,140,1,141,1,141,1,142,1,142,
        1,142,1,142,1,142,3,142,1671,8,142,1,142,3,142,1674,8,142,1,143,
        1,143,3,143,1678,8,143,1,143,1,143,1,144,1,144,1,145,1,145,1,145,
        3,145,1687,8,145,1,145,3,145,1690,8,145,1,145,3,145,1693,8,145,1,
        145,1,145,1,146,1,146,1,147,1,147,3,147,1701,8,147,1,148,1,148,1,
        148,1,149,1,149,1,149,1,149,1,149,1,150,1,150,1,150,5,150,1714,8,
        150,10,150,12,150,1717,9,150,1,151,1,151,1,151,3,151,1722,8,151,
        1,152,1,152,3,152,1726,8,152,1,152,1,152,3,152,1730,8,152,1,153,
        1,153,1,153,5,153,1735,8,153,10,153,12,153,1738,9,153,1,154,1,154,
        1,155,1,155,1,155,3,155,1745,8,155,1,155,1,155,1,156,1,156,3,156,
        1751,8,156,1,157,1,157,1,157,1,158,1,158,1,158,1,158,1,158,1,159,
        1,159,1,159,5,159,1764,8,159,10,159,12,159,1767,9,159,1,160,1,160,
        1,160,1,160,3,160,1773,8,160,1,161,1,161,3,161,1777,8,161,1,161,
        1,161,3,161,1781,8,161,1,162,1,162,1,163,1,163,1,163,4,163,1788,
        8,163,11,163,12,163,1789,1,164,1,164,1,164,1,164,1,165,1,165,1,166,
        1,166,1,166,3,166,1801,8,166,1,166,3,166,1804,8,166,1,166,1,166,
        1,167,1,167,1,168,1,168,1,169,1,169,1,169,3,169,1815,8,169,1,169,
        1,169,1,170,1,170,1,171,1,171,1,172,1,172,1,172,3,172,1826,8,172,
        1,172,3,172,1829,8,172,1,172,3,172,1832,8,172,1,172,1,172,1,173,
        1,173,3,173,1838,8,173,1,174,1,174,1,174,1,175,1,175,1,175,5,175,
        1846,8,175,10,175,12,175,1849,9,175,1,176,1,176,3,176,1853,8,176,
        1,176,1,176,3,176,1857,8,176,1,177,1,177,1,178,1,178,1,178,1,178,
        3,178,1865,8,178,1,179,1,179,1,180,1,180,1,180,3,180,1872,8,180,
        1,180,3,180,1875,8,180,1,180,1,180,1,181,1,181,1,181,1,181,1,182,
        1,182,1,182,5,182,1886,8,182,10,182,12,182,1889,9,182,1,183,1,183,
        1,183,3,183,1894,8,183,1,183,1,183,1,184,1,184,1,185,1,185,3,185,
        1902,8,185,1,185,3,185,1905,8,185,1,185,1,185,1,186,1,186,1,187,
        1,187,1,187,3,187,1914,8,187,1,187,3,187,1917,8,187,1,187,1,187,
        3,187,1921,8,187,1,187,1,187,1,188,1,188,1,189,1,189,3,189,1929,
        8,189,1,190,1,190,3,190,1933,8,190,1,190,3,190,1936,8,190,1,190,
        3,190,1939,8,190,1,190,1,190,1,191,1,191,3,191,1945,8,191,1,191,
        3,191,1948,8,191,1,191,3,191,1951,8,191,1,191,1,191,1,192,1,192,
        1,192,1,192,1,192,1,192,1,192,1,192,1,192,1,192,3,192,1965,8,192,
        1,193,1,193,1,193,1,193,1,193,1,194,1,194,1,194,5,194,1975,8,194,
        10,194,12,194,1978,9,194,1,195,1,195,1,195,1,195,1,195,3,195,1985,
        8,195,1,196,1,196,1,196,1,196,1,196,1,196,1,196,3,196,1994,8,196,
        1,196,1,196,1,196,1,196,1,196,1,196,1,196,1,196,1,196,1,196,1,196,
        1,196,1,196,5,196,2009,8,196,10,196,12,196,2012,9,196,1,197,1,197,
        1,198,1,198,1,199,1,199,1,199,1,199,1,199,3,199,2023,8,199,1,200,
        1,200,1,200,1,200,1,201,1,201,1,201,4,201,2032,8,201,11,201,12,201,
        2033,1,202,1,202,1,202,1,202,1,203,1,203,1,203,1,203,1,203,1,203,
        1,203,1,203,3,203,2048,8,203,1,204,1,204,1,204,1,205,1,205,3,205,
        2055,8,205,1,205,3,205,2058,8,205,1,206,1,206,3,206,2062,8,206,1,
        206,3,206,2065,8,206,1,207,1,207,3,207,2069,8,207,1,208,1,208,3,
        208,2073,8,208,1,209,1,209,1,209,1,210,1,210,1,210,1,210,1,210,1,
        210,1,210,1,210,1,210,1,210,3,210,2088,8,210,1,211,1,211,1,211,3,
        211,2093,8,211,1,212,1,212,1,212,3,212,2098,8,212,1,213,1,213,1,
        213,3,213,2103,8,213,1,214,1,214,1,214,3,214,2108,8,214,1,215,1,
        215,1,215,1,216,1,216,3,216,2115,8,216,1,217,1,217,3,217,2119,8,
        217,1,218,1,218,1,218,1,219,1,219,1,219,1,220,1,220,1,220,1,221,
        1,221,1,221,3,221,2133,8,221,1,222,1,222,1,222,1,222,1,222,1,223,
        1,223,1,223,1,223,3,223,2144,8,223,1,224,1,224,1,224,1,225,1,225,
        1,225,1,225,3,225,2153,8,225,1,226,1,226,1,226,1,226,3,226,2159,
        8,226,1,227,1,227,1,228,1,228,3,228,2165,8,228,1,229,1,229,1,230,
        1,230,5,230,2171,8,230,10,230,12,230,2174,9,230,1,230,3,230,2177,
        8,230,1,231,1,231,1,231,1,231,1,232,1,232,1,232,1,232,1,232,1,233,
        1,233,1,233,1,233,1,234,1,234,4,234,2194,8,234,11,234,12,234,2195,
        1,234,3,234,2199,8,234,1,235,1,235,3,235,2203,8,235,1,236,1,236,
        1,236,1,236,1,236,1,237,1,237,5,237,2212,8,237,10,237,12,237,2215,
        9,237,1,238,1,238,1,238,3,238,2220,8,238,1,239,1,239,1,239,3,239,
        2225,8,239,1,239,1,239,1,240,1,240,4,240,2231,8,240,11,240,12,240,
        2232,1,240,3,240,2236,8,240,1,241,1,241,1,241,1,242,1,242,1,242,
        1,242,1,242,1,243,1,243,1,243,1,243,1,244,1,244,3,244,2252,8,244,
        1,245,1,245,3,245,2256,8,245,1,245,1,245,1,246,1,246,1,246,3,246,
        2263,8,246,1,247,3,247,2266,8,247,1,247,3,247,2269,8,247,1,247,1,
        247,1,248,1,248,3,248,2275,8,248,1,248,3,248,2278,8,248,1,248,1,
        248,1,249,1,249,1,249,1,249,3,249,2286,8,249,1,249,3,249,2289,8,
        249,1,250,1,250,1,250,1,251,1,251,1,251,1,252,1,252,1,252,3,252,
        2300,8,252,1,253,1,253,3,253,2304,8,253,1,254,1,254,1,254,1,254,
        1,254,3,254,2311,8,254,1,255,1,255,1,255,1,256,1,256,1,256,1,257,
        1,257,1,257,1,257,1,258,1,258,5,258,2325,8,258,10,258,12,258,2328,
        9,258,1,258,1,258,1,259,1,259,1,259,1,260,1,260,1,260,1,260,1,261,
        1,261,1,262,1,262,1,262,3,262,2344,8,262,1,263,1,263,3,263,2348,
        8,263,1,263,3,263,2351,8,263,1,264,1,264,3,264,2355,8,264,1,264,
        1,264,1,265,1,265,1,265,1,266,1,266,1,266,1,266,1,266,1,266,3,266,
        2368,8,266,1,267,1,267,3,267,2372,8,267,1,268,1,268,1,269,1,269,
        1,270,1,270,1,271,1,271,1,271,1,271,1,271,3,271,2385,8,271,1,272,
        1,272,1,272,3,272,2390,8,272,1,272,1,272,3,272,2394,8,272,1,272,
        1,272,3,272,2398,8,272,1,272,1,272,3,272,2402,8,272,1,272,1,272,
        3,272,2406,8,272,1,272,1,272,3,272,2410,8,272,1,272,1,272,3,272,
        2414,8,272,1,272,1,272,3,272,2418,8,272,1,272,1,272,3,272,2422,8,
        272,1,272,1,272,3,272,2426,8,272,1,273,1,273,3,273,2430,8,273,1,
        273,3,273,2433,8,273,1,274,1,274,1,274,3,274,2438,8,274,1,275,1,
        275,1,275,3,275,2443,8,275,1,276,1,276,1,276,1,276,1,276,1,276,1,
        277,1,277,1,277,5,277,2454,8,277,10,277,12,277,2457,9,277,1,278,
        1,278,1,278,5,278,2462,8,278,10,278,12,278,2465,9,278,1,279,1,279,
        1,279,3,279,2470,8,279,1,280,1,280,1,280,3,280,2475,8,280,1,281,
        1,281,1,281,3,281,2480,8,281,1,282,1,282,1,282,3,282,2485,8,282,
        1,283,1,283,1,283,3,283,2490,8,283,1,284,1,284,1,284,3,284,2495,
        8,284,1,285,1,285,1,285,3,285,2500,8,285,1,286,1,286,1,286,1,286,
        1,286,1,286,1,286,3,286,2509,8,286,1,287,1,287,1,288,1,288,1,289,
        1,289,1,290,1,290,1,291,1,291,1,292,1,292,1,293,1,293,1,294,1,294,
        1,294,1,294,1,294,1,294,1,294,3,294,2532,8,294,1,295,1,295,1,296,
        1,296,1,297,1,297,1,298,1,298,1,299,1,299,1,300,1,300,1,301,1,301,
        1,302,1,302,1,303,1,303,1,304,1,304,1,305,1,305,1,306,1,306,1,307,
        1,307,1,308,1,308,1,309,1,309,1,310,1,310,1,311,1,311,1,312,1,312,
        1,313,1,313,1,313,3,313,2573,8,313,1,314,1,314,1,315,1,315,1,316,
        1,316,1,317,1,317,1,317,1,317,1,317,1,317,1,317,1,317,1,317,1,317,
        1,317,1,317,1,317,1,317,1,317,3,317,2596,8,317,1,318,1,318,3,318,
        2600,8,318,1,318,5,318,2603,8,318,10,318,12,318,2606,9,318,1,319,
        1,319,3,319,2610,8,319,1,320,1,320,5,320,2614,8,320,10,320,12,320,
        2617,9,320,1,321,1,321,5,321,2621,8,321,10,321,12,321,2624,9,321,
        1,322,1,322,1,322,5,322,2629,8,322,10,322,12,322,2632,9,322,1,323,
        1,323,3,323,2636,8,323,1,323,1,323,1,324,1,324,1,324,1,324,1,325,
        1,325,1,325,5,325,2647,8,325,10,325,12,325,2650,9,325,1,326,1,326,
        1,326,3,326,2655,8,326,1,327,1,327,1,327,5,327,2660,8,327,10,327,
        12,327,2663,9,327,1,328,1,328,1,328,1,328,1,328,1,328,1,328,3,328,
        2672,8,328,1,328,1,328,1,328,1,328,1,328,1,328,1,328,1,328,1,328,
        1,328,1,328,1,328,1,328,5,328,2687,8,328,10,328,12,328,2690,9,328,
        1,329,1,329,1,329,1,329,1,330,1,330,1,330,1,330,1,330,1,330,1,330,
        1,330,1,330,1,330,1,330,1,330,1,330,1,330,3,330,2710,8,330,1,331,
        1,331,1,331,1,331,3,331,2716,8,331,1,332,1,332,1,332,1,332,1,332,
        1,332,1,332,1,332,3,332,2726,8,332,1,333,1,333,1,333,1,333,3,333,
        2732,8,333,1,334,1,334,1,335,1,335,1,335,1,335,1,335,1,335,1,335,
        3,335,2743,8,335,1,336,1,336,1,337,1,337,1,338,1,338,1,339,1,339,
        1,340,1,340,1,341,1,341,1,342,1,342,1,343,1,343,1,344,1,344,1,345,
        1,345,1,345,3,345,2766,8,345,1,346,1,346,1,347,1,347,1,348,1,348,
        1,349,1,349,1,350,1,350,1,351,1,351,1,351,1,351,1,352,1,352,1,352,
        1,352,1,353,1,353,1,353,1,354,1,354,1,354,1,355,1,355,1,355,1,355,
        1,356,1,356,1,356,1,356,1,357,1,357,1,358,1,358,1,358,1,359,1,359,
        3,359,2807,8,359,1,359,1,359,1,360,1,360,3,360,2813,8,360,1,360,
        1,360,1,361,1,361,1,361,5,361,2820,8,361,10,361,12,361,2823,9,361,
        1,362,3,362,2826,8,362,1,362,1,362,1,363,1,363,1,363,1,363,3,363,
        2834,8,363,1,364,1,364,1,364,1,364,1,364,3,364,2841,8,364,1,365,
        1,365,1,366,1,366,1,366,1,366,1,366,1,366,1,366,1,366,1,366,1,366,
        1,366,1,366,1,366,1,366,1,366,3,366,2860,8,366,1,367,1,367,1,368,
        1,368,1,368,3,368,2867,8,368,1,368,1,368,3,368,2871,8,368,1,368,
        1,368,3,368,2875,8,368,1,368,1,368,3,368,2879,8,368,1,368,1,368,
        3,368,2883,8,368,1,368,1,368,3,368,2887,8,368,1,368,1,368,1,368,
        1,368,1,368,1,368,3,368,2895,8,368,1,369,1,369,1,369,1,369,1,369,
        1,369,1,369,1,369,1,369,1,369,1,369,1,369,1,369,1,369,1,369,3,369,
        2912,8,369,1,370,1,370,1,370,1,370,3,370,2918,8,370,1,371,1,371,
        1,371,1,371,3,371,2924,8,371,1,372,1,372,1,372,3,372,2929,8,372,
        1,373,1,373,1,373,1,373,3,373,2935,8,373,1,374,1,374,1,374,3,374,
        2940,8,374,1,375,1,375,1,375,1,375,1,375,1,375,3,375,2948,8,375,
        1,376,1,376,1,376,1,376,1,376,1,376,1,376,1,376,1,376,1,376,1,376,
        1,376,1,376,3,376,2963,8,376,1,377,1,377,1,378,1,378,1,379,1,379,
        1,379,1,379,1,379,1,379,3,379,2975,8,379,1,380,1,380,1,380,1,380,
        1,380,1,380,1,380,1,380,1,380,1,380,3,380,2987,8,380,1,381,1,381,
        1,381,1,381,1,382,1,382,1,382,3,382,2996,8,382,1,382,1,382,1,383,
        1,383,1,383,1,383,1,383,3,383,3005,8,383,1,384,1,384,1,384,1,384,
        3,384,3011,8,384,1,385,1,385,1,385,1,385,1,385,1,385,1,385,1,385,
        1,385,1,385,1,385,1,385,1,385,1,385,1,385,1,385,1,385,3,385,3030,
        8,385,1,386,1,386,1,386,5,386,3035,8,386,10,386,12,386,3038,9,386,
        1,387,1,387,3,387,3042,8,387,1,388,1,388,3,388,3046,8,388,1,389,
        1,389,5,389,3050,8,389,10,389,12,389,3053,9,389,1,389,1,389,1,390,
        1,390,1,390,5,390,3060,8,390,10,390,12,390,3063,9,390,1,390,1,390,
        1,391,1,391,1,391,1,391,1,392,1,392,1,392,5,392,3074,8,392,10,392,
        12,392,3077,9,392,1,392,1,392,1,393,1,393,3,393,3083,8,393,1,394,
        1,394,5,394,3087,8,394,10,394,12,394,3090,9,394,1,394,1,394,1,395,
        1,395,1,396,1,396,3,396,3098,8,396,1,397,1,397,1,397,3,397,3103,
        8,397,1,398,1,398,3,398,3107,8,398,1,399,1,399,1,399,3,399,3112,
        8,399,1,400,1,400,1,400,1,400,1,401,3,401,3119,8,401,1,401,1,401,
        1,401,3,401,3124,8,401,1,402,1,402,1,402,1,402,1,402,3,402,3131,
        8,402,4,402,3133,8,402,11,402,12,402,3134,1,402,1,402,3,402,3139,
        8,402,1,403,4,403,3142,8,403,11,403,12,403,3143,1,404,1,404,1,404,
        3,404,3149,8,404,1,404,1,404,1,405,1,405,1,406,1,406,1,407,1,407,
        1,407,1,407,1,408,1,408,1,408,4,408,3164,8,408,11,408,12,408,3165,
        1,408,1,408,1,409,1,409,1,409,3,409,3173,8,409,1,410,3,410,3176,
        8,410,1,410,1,410,1,411,1,411,1,411,1,411,1,411,3,411,3185,8,411,
        1,411,1,411,1,411,1,411,1,411,1,411,3,411,3193,8,411,1,412,1,412,
        1,412,5,412,3198,8,412,10,412,12,412,3201,9,412,1,413,1,413,1,413,
        3,413,3206,8,413,1,413,1,413,1,414,1,414,1,415,1,415,1,416,1,416,
        1,416,3,416,3217,8,416,1,417,1,417,3,417,3221,8,417,1,417,1,417,
        1,417,1,418,1,418,1,418,1,418,1,419,1,419,1,419,1,419,4,419,3234,
        8,419,11,419,12,419,3235,1,419,1,419,1,420,1,420,3,420,3242,8,420,
        1,421,1,421,1,422,1,422,1,423,1,423,3,423,3250,8,423,1,424,1,424,
        1,425,1,425,1,426,1,426,1,426,5,426,3259,8,426,10,426,12,426,3262,
        9,426,1,427,1,427,1,427,1,427,1,427,1,427,1,427,1,427,1,427,1,427,
        1,427,3,427,3275,8,427,1,427,1,427,1,427,1,427,1,427,1,427,1,427,
        1,427,1,427,1,427,1,427,1,427,1,427,5,427,3290,8,427,10,427,12,427,
        3293,9,427,1,428,1,428,1,428,1,428,1,428,3,428,3300,8,428,1,429,
        1,429,3,429,3304,8,429,1,430,1,430,1,430,1,430,1,431,1,431,1,431,
        1,431,1,432,1,432,1,432,3,432,3317,8,432,1,433,1,433,1,433,1,433,
        1,433,1,433,1,433,1,433,1,433,1,433,1,433,3,433,3330,8,433,1,433,
        1,433,1,433,5,433,3335,8,433,10,433,12,433,3338,9,433,1,434,1,434,
        1,434,1,434,1,434,1,434,1,434,1,434,1,434,1,434,3,434,3350,8,434,
        1,434,1,434,1,434,5,434,3355,8,434,10,434,12,434,3358,9,434,1,435,
        1,435,1,435,3,435,3363,8,435,1,436,4,436,3366,8,436,11,436,12,436,
        3367,1,437,1,437,1,437,5,437,3373,8,437,10,437,12,437,3376,9,437,
        1,438,1,438,1,438,1,438,1,438,1,438,1,438,1,438,1,438,4,438,3387,
        8,438,11,438,12,438,3388,1,438,3,438,3392,8,438,1,438,1,438,1,438,
        5,438,3397,8,438,10,438,12,438,3400,9,438,1,438,1,438,1,438,1,438,
        1,438,1,438,3,438,3408,8,438,1,438,1,438,1,438,1,438,1,438,1,438,
        1,438,1,438,1,438,1,438,1,438,1,438,1,438,1,438,1,438,1,438,1,438,
        1,438,1,438,1,438,1,438,1,438,1,438,1,438,1,438,1,438,1,438,1,438,
        1,438,1,438,1,438,1,438,1,438,1,438,1,438,1,438,1,438,1,438,1,438,
        1,438,1,438,1,438,1,438,1,438,1,438,1,438,1,438,1,438,1,438,1,438,
        1,438,1,438,1,438,1,438,1,438,1,438,1,438,1,438,1,438,1,438,1,438,
        3,438,3471,8,438,5,438,3473,8,438,10,438,12,438,3476,9,438,1,439,
        4,439,3479,8,439,11,439,12,439,3480,1,439,3,439,3484,8,439,1,440,
        1,440,1,440,1,440,1,440,1,441,1,441,1,441,1,442,4,442,3495,8,442,
        11,442,12,442,3496,1,443,1,443,5,443,3501,8,443,10,443,12,443,3504,
        9,443,1,444,1,444,1,444,1,444,1,444,1,445,1,445,1,445,1,445,1,445,
        0,6,392,656,854,866,868,876,446,0,2,4,6,8,10,12,14,16,18,20,22,24,
        26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,
        70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,
        110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,
        142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,
        174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,
        206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,
        238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,
        270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,
        302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,
        334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,
        366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,
        398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,
        430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,460,
        462,464,466,468,470,472,474,476,478,480,482,484,486,488,490,492,
        494,496,498,500,502,504,506,508,510,512,514,516,518,520,522,524,
        526,528,530,532,534,536,538,540,542,544,546,548,550,552,554,556,
        558,560,562,564,566,568,570,572,574,576,578,580,582,584,586,588,
        590,592,594,596,598,600,602,604,606,608,610,612,614,616,618,620,
        622,624,626,628,630,632,634,636,638,640,642,644,646,648,650,652,
        654,656,658,660,662,664,666,668,670,672,674,676,678,680,682,684,
        686,688,690,692,694,696,698,700,702,704,706,708,710,712,714,716,
        718,720,722,724,726,728,730,732,734,736,738,740,742,744,746,748,
        750,752,754,756,758,760,762,764,766,768,770,772,774,776,778,780,
        782,784,786,788,790,792,794,796,798,800,802,804,806,808,810,812,
        814,816,818,820,822,824,826,828,830,832,834,836,838,840,842,844,
        846,848,850,852,854,856,858,860,862,864,866,868,870,872,874,876,
        878,880,882,884,886,888,890,0,48,1,0,415,416,1,0,43,45,3,0,330,330,
        482,482,484,484,3,0,328,329,370,370,475,475,3,0,65,65,76,76,114,
        114,2,0,33,35,145,146,1,0,321,327,1,0,142,143,1,0,321,322,1,0,330,
        339,1,0,326,327,1,0,340,342,1,0,150,152,1,0,155,156,1,0,153,154,
        1,0,161,164,1,0,343,344,1,0,345,352,3,0,33,35,144,149,353,364,1,
        0,365,369,1,0,379,388,1,0,370,373,1,0,370,371,2,0,370,370,372,372,
        1,0,389,393,1,0,395,414,1,0,170,175,1,0,176,183,1,0,184,190,1,0,
        198,204,1,0,191,197,1,0,205,210,1,0,211,214,1,0,215,218,1,0,219,
        220,1,0,221,226,1,0,227,235,1,0,236,241,1,0,242,253,4,0,297,297,
        300,300,303,303,306,306,1,0,165,169,1,0,254,255,2,0,424,424,438,
        438,3,0,429,429,431,431,433,433,2,0,127,133,486,486,1,0,440,447,
        7,0,254,255,257,275,277,292,298,299,301,302,304,305,307,308,1,0,
        134,139,3627,0,892,1,0,0,0,2,895,1,0,0,0,4,897,1,0,0,0,6,902,1,0,
        0,0,8,907,1,0,0,0,10,911,1,0,0,0,12,926,1,0,0,0,14,928,1,0,0,0,16,
        932,1,0,0,0,18,943,1,0,0,0,20,945,1,0,0,0,22,955,1,0,0,0,24,957,
        1,0,0,0,26,962,1,0,0,0,28,965,1,0,0,0,30,969,1,0,0,0,32,971,1,0,
        0,0,34,974,1,0,0,0,36,978,1,0,0,0,38,980,1,0,0,0,40,989,1,0,0,0,
        42,994,1,0,0,0,44,998,1,0,0,0,46,1001,1,0,0,0,48,1005,1,0,0,0,50,
        1010,1,0,0,0,52,1016,1,0,0,0,54,1024,1,0,0,0,56,1032,1,0,0,0,58,
        1040,1,0,0,0,60,1048,1,0,0,0,62,1056,1,0,0,0,64,1069,1,0,0,0,66,
        1074,1,0,0,0,68,1076,1,0,0,0,70,1080,1,0,0,0,72,1083,1,0,0,0,74,
        1088,1,0,0,0,76,1090,1,0,0,0,78,1095,1,0,0,0,80,1100,1,0,0,0,82,
        1110,1,0,0,0,84,1112,1,0,0,0,86,1116,1,0,0,0,88,1123,1,0,0,0,90,
        1128,1,0,0,0,92,1133,1,0,0,0,94,1141,1,0,0,0,96,1143,1,0,0,0,98,
        1145,1,0,0,0,100,1153,1,0,0,0,102,1155,1,0,0,0,104,1160,1,0,0,0,
        106,1165,1,0,0,0,108,1177,1,0,0,0,110,1179,1,0,0,0,112,1181,1,0,
        0,0,114,1188,1,0,0,0,116,1192,1,0,0,0,118,1196,1,0,0,0,120,1198,
        1,0,0,0,122,1205,1,0,0,0,124,1207,1,0,0,0,126,1209,1,0,0,0,128,1214,
        1,0,0,0,130,1219,1,0,0,0,132,1230,1,0,0,0,134,1232,1,0,0,0,136,1234,
        1,0,0,0,138,1241,1,0,0,0,140,1255,1,0,0,0,142,1260,1,0,0,0,144,1262,
        1,0,0,0,146,1275,1,0,0,0,148,1281,1,0,0,0,150,1283,1,0,0,0,152,1296,
        1,0,0,0,154,1299,1,0,0,0,156,1302,1,0,0,0,158,1308,1,0,0,0,160,1310,
        1,0,0,0,162,1316,1,0,0,0,164,1326,1,0,0,0,166,1330,1,0,0,0,168,1336,
        1,0,0,0,170,1345,1,0,0,0,172,1361,1,0,0,0,174,1363,1,0,0,0,176,1371,
        1,0,0,0,178,1377,1,0,0,0,180,1379,1,0,0,0,182,1381,1,0,0,0,184,1384,
        1,0,0,0,186,1386,1,0,0,0,188,1390,1,0,0,0,190,1397,1,0,0,0,192,1403,
        1,0,0,0,194,1426,1,0,0,0,196,1428,1,0,0,0,198,1430,1,0,0,0,200,1435,
        1,0,0,0,202,1440,1,0,0,0,204,1450,1,0,0,0,206,1452,1,0,0,0,208,1456,
        1,0,0,0,210,1463,1,0,0,0,212,1465,1,0,0,0,214,1470,1,0,0,0,216,1475,
        1,0,0,0,218,1486,1,0,0,0,220,1488,1,0,0,0,222,1492,1,0,0,0,224,1501,
        1,0,0,0,226,1507,1,0,0,0,228,1509,1,0,0,0,230,1514,1,0,0,0,232,1519,
        1,0,0,0,234,1530,1,0,0,0,236,1532,1,0,0,0,238,1538,1,0,0,0,240,1545,
        1,0,0,0,242,1551,1,0,0,0,244,1553,1,0,0,0,246,1558,1,0,0,0,248,1563,
        1,0,0,0,250,1574,1,0,0,0,252,1576,1,0,0,0,254,1582,1,0,0,0,256,1589,
        1,0,0,0,258,1595,1,0,0,0,260,1597,1,0,0,0,262,1605,1,0,0,0,264,1607,
        1,0,0,0,266,1617,1,0,0,0,268,1619,1,0,0,0,270,1629,1,0,0,0,272,1631,
        1,0,0,0,274,1640,1,0,0,0,276,1642,1,0,0,0,278,1654,1,0,0,0,280,1657,
        1,0,0,0,282,1663,1,0,0,0,284,1665,1,0,0,0,286,1675,1,0,0,0,288,1681,
        1,0,0,0,290,1683,1,0,0,0,292,1696,1,0,0,0,294,1700,1,0,0,0,296,1702,
        1,0,0,0,298,1705,1,0,0,0,300,1710,1,0,0,0,302,1721,1,0,0,0,304,1723,
        1,0,0,0,306,1731,1,0,0,0,308,1739,1,0,0,0,310,1741,1,0,0,0,312,1750,
        1,0,0,0,314,1752,1,0,0,0,316,1755,1,0,0,0,318,1760,1,0,0,0,320,1772,
        1,0,0,0,322,1774,1,0,0,0,324,1782,1,0,0,0,326,1784,1,0,0,0,328,1791,
        1,0,0,0,330,1795,1,0,0,0,332,1797,1,0,0,0,334,1807,1,0,0,0,336,1809,
        1,0,0,0,338,1811,1,0,0,0,340,1818,1,0,0,0,342,1820,1,0,0,0,344,1822,
        1,0,0,0,346,1837,1,0,0,0,348,1839,1,0,0,0,350,1842,1,0,0,0,352,1850,
        1,0,0,0,354,1858,1,0,0,0,356,1864,1,0,0,0,358,1866,1,0,0,0,360,1868,
        1,0,0,0,362,1878,1,0,0,0,364,1882,1,0,0,0,366,1893,1,0,0,0,368,1897,
        1,0,0,0,370,1899,1,0,0,0,372,1908,1,0,0,0,374,1910,1,0,0,0,376,1924,
        1,0,0,0,378,1928,1,0,0,0,380,1930,1,0,0,0,382,1942,1,0,0,0,384,1964,
        1,0,0,0,386,1966,1,0,0,0,388,1971,1,0,0,0,390,1984,1,0,0,0,392,1993,
        1,0,0,0,394,2013,1,0,0,0,396,2015,1,0,0,0,398,2022,1,0,0,0,400,2024,
        1,0,0,0,402,2028,1,0,0,0,404,2035,1,0,0,0,406,2047,1,0,0,0,408,2049,
        1,0,0,0,410,2052,1,0,0,0,412,2059,1,0,0,0,414,2066,1,0,0,0,416,2070,
        1,0,0,0,418,2074,1,0,0,0,420,2087,1,0,0,0,422,2089,1,0,0,0,424,2094,
        1,0,0,0,426,2099,1,0,0,0,428,2104,1,0,0,0,430,2109,1,0,0,0,432,2112,
        1,0,0,0,434,2116,1,0,0,0,436,2120,1,0,0,0,438,2123,1,0,0,0,440,2126,
        1,0,0,0,442,2132,1,0,0,0,444,2134,1,0,0,0,446,2139,1,0,0,0,448,2145,
        1,0,0,0,450,2152,1,0,0,0,452,2158,1,0,0,0,454,2160,1,0,0,0,456,2164,
        1,0,0,0,458,2166,1,0,0,0,460,2168,1,0,0,0,462,2178,1,0,0,0,464,2182,
        1,0,0,0,466,2187,1,0,0,0,468,2191,1,0,0,0,470,2200,1,0,0,0,472,2204,
        1,0,0,0,474,2209,1,0,0,0,476,2216,1,0,0,0,478,2221,1,0,0,0,480,2228,
        1,0,0,0,482,2237,1,0,0,0,484,2240,1,0,0,0,486,2245,1,0,0,0,488,2249,
        1,0,0,0,490,2253,1,0,0,0,492,2262,1,0,0,0,494,2265,1,0,0,0,496,2272,
        1,0,0,0,498,2281,1,0,0,0,500,2290,1,0,0,0,502,2293,1,0,0,0,504,2299,
        1,0,0,0,506,2303,1,0,0,0,508,2305,1,0,0,0,510,2312,1,0,0,0,512,2315,
        1,0,0,0,514,2318,1,0,0,0,516,2322,1,0,0,0,518,2331,1,0,0,0,520,2334,
        1,0,0,0,522,2338,1,0,0,0,524,2340,1,0,0,0,526,2345,1,0,0,0,528,2352,
        1,0,0,0,530,2358,1,0,0,0,532,2361,1,0,0,0,534,2371,1,0,0,0,536,2373,
        1,0,0,0,538,2375,1,0,0,0,540,2377,1,0,0,0,542,2379,1,0,0,0,544,2386,
        1,0,0,0,546,2427,1,0,0,0,548,2434,1,0,0,0,550,2439,1,0,0,0,552,2444,
        1,0,0,0,554,2450,1,0,0,0,556,2458,1,0,0,0,558,2466,1,0,0,0,560,2471,
        1,0,0,0,562,2476,1,0,0,0,564,2481,1,0,0,0,566,2486,1,0,0,0,568,2491,
        1,0,0,0,570,2496,1,0,0,0,572,2508,1,0,0,0,574,2510,1,0,0,0,576,2512,
        1,0,0,0,578,2514,1,0,0,0,580,2516,1,0,0,0,582,2518,1,0,0,0,584,2520,
        1,0,0,0,586,2522,1,0,0,0,588,2531,1,0,0,0,590,2533,1,0,0,0,592,2535,
        1,0,0,0,594,2537,1,0,0,0,596,2539,1,0,0,0,598,2541,1,0,0,0,600,2543,
        1,0,0,0,602,2545,1,0,0,0,604,2547,1,0,0,0,606,2549,1,0,0,0,608,2551,
        1,0,0,0,610,2553,1,0,0,0,612,2555,1,0,0,0,614,2557,1,0,0,0,616,2559,
        1,0,0,0,618,2561,1,0,0,0,620,2563,1,0,0,0,622,2565,1,0,0,0,624,2567,
        1,0,0,0,626,2572,1,0,0,0,628,2574,1,0,0,0,630,2576,1,0,0,0,632,2578,
        1,0,0,0,634,2595,1,0,0,0,636,2597,1,0,0,0,638,2609,1,0,0,0,640,2611,
        1,0,0,0,642,2618,1,0,0,0,644,2625,1,0,0,0,646,2635,1,0,0,0,648,2639,
        1,0,0,0,650,2643,1,0,0,0,652,2651,1,0,0,0,654,2656,1,0,0,0,656,2671,
        1,0,0,0,658,2691,1,0,0,0,660,2709,1,0,0,0,662,2715,1,0,0,0,664,2725,
        1,0,0,0,666,2731,1,0,0,0,668,2733,1,0,0,0,670,2742,1,0,0,0,672,2744,
        1,0,0,0,674,2746,1,0,0,0,676,2748,1,0,0,0,678,2750,1,0,0,0,680,2752,
        1,0,0,0,682,2754,1,0,0,0,684,2756,1,0,0,0,686,2758,1,0,0,0,688,2760,
        1,0,0,0,690,2765,1,0,0,0,692,2767,1,0,0,0,694,2769,1,0,0,0,696,2771,
        1,0,0,0,698,2773,1,0,0,0,700,2775,1,0,0,0,702,2777,1,0,0,0,704,2781,
        1,0,0,0,706,2785,1,0,0,0,708,2788,1,0,0,0,710,2791,1,0,0,0,712,2795,
        1,0,0,0,714,2799,1,0,0,0,716,2801,1,0,0,0,718,2804,1,0,0,0,720,2810,
        1,0,0,0,722,2816,1,0,0,0,724,2825,1,0,0,0,726,2833,1,0,0,0,728,2840,
        1,0,0,0,730,2842,1,0,0,0,732,2859,1,0,0,0,734,2861,1,0,0,0,736,2894,
        1,0,0,0,738,2911,1,0,0,0,740,2917,1,0,0,0,742,2923,1,0,0,0,744,2928,
        1,0,0,0,746,2934,1,0,0,0,748,2939,1,0,0,0,750,2947,1,0,0,0,752,2962,
        1,0,0,0,754,2964,1,0,0,0,756,2966,1,0,0,0,758,2974,1,0,0,0,760,2986,
        1,0,0,0,762,2988,1,0,0,0,764,2992,1,0,0,0,766,3004,1,0,0,0,768,3010,
        1,0,0,0,770,3029,1,0,0,0,772,3031,1,0,0,0,774,3041,1,0,0,0,776,3045,
        1,0,0,0,778,3047,1,0,0,0,780,3056,1,0,0,0,782,3066,1,0,0,0,784,3070,
        1,0,0,0,786,3082,1,0,0,0,788,3084,1,0,0,0,790,3093,1,0,0,0,792,3097,
        1,0,0,0,794,3099,1,0,0,0,796,3106,1,0,0,0,798,3111,1,0,0,0,800,3113,
        1,0,0,0,802,3123,1,0,0,0,804,3138,1,0,0,0,806,3141,1,0,0,0,808,3148,
        1,0,0,0,810,3152,1,0,0,0,812,3154,1,0,0,0,814,3156,1,0,0,0,816,3160,
        1,0,0,0,818,3169,1,0,0,0,820,3175,1,0,0,0,822,3192,1,0,0,0,824,3194,
        1,0,0,0,826,3205,1,0,0,0,828,3209,1,0,0,0,830,3211,1,0,0,0,832,3216,
        1,0,0,0,834,3218,1,0,0,0,836,3225,1,0,0,0,838,3229,1,0,0,0,840,3241,
        1,0,0,0,842,3243,1,0,0,0,844,3245,1,0,0,0,846,3249,1,0,0,0,848,3251,
        1,0,0,0,850,3253,1,0,0,0,852,3255,1,0,0,0,854,3274,1,0,0,0,856,3299,
        1,0,0,0,858,3303,1,0,0,0,860,3305,1,0,0,0,862,3309,1,0,0,0,864,3316,
        1,0,0,0,866,3329,1,0,0,0,868,3349,1,0,0,0,870,3362,1,0,0,0,872,3365,
        1,0,0,0,874,3369,1,0,0,0,876,3407,1,0,0,0,878,3478,1,0,0,0,880,3485,
        1,0,0,0,882,3490,1,0,0,0,884,3494,1,0,0,0,886,3498,1,0,0,0,888,3505,
        1,0,0,0,890,3510,1,0,0,0,892,893,3,20,10,0,893,894,3,2,1,0,894,1,
        1,0,0,0,895,896,3,8,4,0,896,3,1,0,0,0,897,898,3,12,6,0,898,5,1,0,
        0,0,899,903,3,0,0,0,900,903,3,2,1,0,901,903,3,4,2,0,902,899,1,0,
        0,0,902,900,1,0,0,0,902,901,1,0,0,0,903,7,1,0,0,0,904,905,3,12,6,
        0,905,906,5,457,0,0,906,908,1,0,0,0,907,904,1,0,0,0,908,909,1,0,
        0,0,909,907,1,0,0,0,909,910,1,0,0,0,910,9,1,0,0,0,911,912,5,457,
        0,0,912,913,5,2,0,0,913,918,3,12,6,0,914,915,5,457,0,0,915,917,3,
        12,6,0,916,914,1,0,0,0,917,920,1,0,0,0,918,916,1,0,0,0,918,919,1,
        0,0,0,919,921,1,0,0,0,920,918,1,0,0,0,921,922,5,3,0,0,922,11,1,0,
        0,0,923,927,3,14,7,0,924,927,3,16,8,0,925,927,3,18,9,0,926,923,1,
        0,0,0,926,924,1,0,0,0,926,925,1,0,0,0,927,13,1,0,0,0,928,929,3,22,
        11,0,929,930,5,457,0,0,930,931,3,12,6,0,931,15,1,0,0,0,932,933,3,
        22,11,0,933,934,3,10,5,0,934,17,1,0,0,0,935,936,5,452,0,0,936,944,
        3,18,9,0,937,938,5,451,0,0,938,944,3,18,9,0,939,944,3,64,32,0,940,
        944,3,140,70,0,941,944,3,384,192,0,942,944,1,0,0,0,943,935,1,0,0,
        0,943,937,1,0,0,0,943,939,1,0,0,0,943,940,1,0,0,0,943,941,1,0,0,
        0,943,942,1,0,0,0,944,19,1,0,0,0,945,946,5,453,0,0,946,948,5,450,
        0,0,947,949,3,876,438,0,948,947,1,0,0,0,948,949,1,0,0,0,949,950,
        1,0,0,0,950,951,5,457,0,0,951,21,1,0,0,0,952,956,3,24,12,0,953,956,
        3,26,13,0,954,956,3,30,15,0,955,952,1,0,0,0,955,953,1,0,0,0,955,
        954,1,0,0,0,956,23,1,0,0,0,957,958,5,453,0,0,958,960,5,415,0,0,959,
        961,3,874,437,0,960,959,1,0,0,0,960,961,1,0,0,0,961,25,1,0,0,0,962,
        963,5,454,0,0,963,964,3,28,14,0,964,27,1,0,0,0,965,966,3,874,437,
        0,966,29,1,0,0,0,967,970,3,32,16,0,968,970,3,34,17,0,969,967,1,0,
        0,0,969,968,1,0,0,0,970,31,1,0,0,0,971,972,5,455,0,0,972,973,3,12,
        6,0,973,33,1,0,0,0,974,975,5,456,0,0,975,976,3,8,4,0,976,977,5,456,
        0,0,977,35,1,0,0,0,978,979,5,415,0,0,979,37,1,0,0,0,980,985,5,415,
        0,0,981,982,5,472,0,0,982,984,5,415,0,0,983,981,1,0,0,0,984,987,
        1,0,0,0,985,983,1,0,0,0,985,986,1,0,0,0,986,39,1,0,0,0,987,985,1,
        0,0,0,988,990,3,144,72,0,989,988,1,0,0,0,989,990,1,0,0,0,990,991,
        1,0,0,0,991,992,5,415,0,0,992,41,1,0,0,0,993,995,3,144,72,0,994,
        993,1,0,0,0,994,995,1,0,0,0,995,996,1,0,0,0,996,997,3,656,328,0,
        997,43,1,0,0,0,998,999,3,40,20,0,999,1000,3,656,328,0,1000,45,1,
        0,0,0,1001,1003,3,40,20,0,1002,1004,3,656,328,0,1003,1002,1,0,0,
        0,1003,1004,1,0,0,0,1004,47,1,0,0,0,1005,1007,3,40,20,0,1006,1008,
        3,648,324,0,1007,1006,1,0,0,0,1007,1008,1,0,0,0,1008,49,1,0,0,0,
        1009,1011,3,144,72,0,1010,1009,1,0,0,0,1010,1011,1,0,0,0,1011,1012,
        1,0,0,0,1012,1014,3,38,19,0,1013,1015,3,648,324,0,1014,1013,1,0,
        0,0,1014,1015,1,0,0,0,1015,51,1,0,0,0,1016,1021,5,415,0,0,1017,1018,
        5,473,0,0,1018,1020,5,415,0,0,1019,1017,1,0,0,0,1020,1023,1,0,0,
        0,1021,1019,1,0,0,0,1021,1022,1,0,0,0,1022,53,1,0,0,0,1023,1021,
        1,0,0,0,1024,1029,3,38,19,0,1025,1026,5,473,0,0,1026,1028,3,38,19,
        0,1027,1025,1,0,0,0,1028,1031,1,0,0,0,1029,1027,1,0,0,0,1029,1030,
        1,0,0,0,1030,55,1,0,0,0,1031,1029,1,0,0,0,1032,1037,3,40,20,0,1033,
        1034,5,473,0,0,1034,1036,3,40,20,0,1035,1033,1,0,0,0,1036,1039,1,
        0,0,0,1037,1035,1,0,0,0,1037,1038,1,0,0,0,1038,57,1,0,0,0,1039,1037,
        1,0,0,0,1040,1045,3,42,21,0,1041,1042,5,473,0,0,1042,1044,3,42,21,
        0,1043,1041,1,0,0,0,1044,1047,1,0,0,0,1045,1043,1,0,0,0,1045,1046,
        1,0,0,0,1046,59,1,0,0,0,1047,1045,1,0,0,0,1048,1053,3,44,22,0,1049,
        1050,5,473,0,0,1050,1052,3,44,22,0,1051,1049,1,0,0,0,1052,1055,1,
        0,0,0,1053,1051,1,0,0,0,1053,1054,1,0,0,0,1054,61,1,0,0,0,1055,1053,
        1,0,0,0,1056,1061,3,46,23,0,1057,1058,5,473,0,0,1058,1060,3,46,23,
        0,1059,1057,1,0,0,0,1060,1063,1,0,0,0,1061,1059,1,0,0,0,1061,1062,
        1,0,0,0,1062,63,1,0,0,0,1063,1061,1,0,0,0,1064,1070,3,66,33,0,1065,
        1070,3,74,37,0,1066,1070,3,100,50,0,1067,1070,3,118,59,0,1068,1070,
        3,124,62,0,1069,1064,1,0,0,0,1069,1065,1,0,0,0,1069,1066,1,0,0,0,
        1069,1067,1,0,0,0,1069,1068,1,0,0,0,1070,65,1,0,0,0,1071,1075,3,
        68,34,0,1072,1075,3,70,35,0,1073,1075,3,72,36,0,1074,1071,1,0,0,
        0,1074,1072,1,0,0,0,1074,1073,1,0,0,0,1075,67,1,0,0,0,1076,1078,
        5,5,0,0,1077,1079,3,38,19,0,1078,1077,1,0,0,0,1078,1079,1,0,0,0,
        1079,69,1,0,0,0,1080,1081,5,4,0,0,1081,1082,3,38,19,0,1082,71,1,
        0,0,0,1083,1084,5,6,0,0,1084,1085,3,38,19,0,1085,73,1,0,0,0,1086,
        1089,3,76,38,0,1087,1089,3,88,44,0,1088,1086,1,0,0,0,1088,1087,1,
        0,0,0,1089,75,1,0,0,0,1090,1093,5,7,0,0,1091,1094,3,78,39,0,1092,
        1094,3,82,41,0,1093,1091,1,0,0,0,1093,1092,1,0,0,0,1094,77,1,0,0,
        0,1095,1096,5,457,0,0,1096,1097,5,2,0,0,1097,1098,3,80,40,0,1098,
        1099,5,3,0,0,1099,79,1,0,0,0,1100,1105,3,82,41,0,1101,1102,5,457,
        0,0,1102,1104,3,82,41,0,1103,1101,1,0,0,0,1104,1107,1,0,0,0,1105,
        1103,1,0,0,0,1105,1106,1,0,0,0,1106,81,1,0,0,0,1107,1105,1,0,0,0,
        1108,1111,3,84,42,0,1109,1111,3,86,43,0,1110,1108,1,0,0,0,1110,1109,
        1,0,0,0,1111,83,1,0,0,0,1112,1114,3,96,48,0,1113,1115,3,726,363,
        0,1114,1113,1,0,0,0,1114,1115,1,0,0,0,1115,85,1,0,0,0,1116,1119,
        3,84,42,0,1117,1118,5,473,0,0,1118,1120,3,84,42,0,1119,1117,1,0,
        0,0,1120,1121,1,0,0,0,1121,1119,1,0,0,0,1121,1122,1,0,0,0,1122,87,
        1,0,0,0,1123,1126,5,8,0,0,1124,1127,3,90,45,0,1125,1127,3,94,47,
        0,1126,1124,1,0,0,0,1126,1125,1,0,0,0,1127,89,1,0,0,0,1128,1129,
        5,457,0,0,1129,1130,5,2,0,0,1130,1131,3,92,46,0,1131,1132,5,3,0,
        0,1132,91,1,0,0,0,1133,1138,3,94,47,0,1134,1135,5,457,0,0,1135,1137,
        3,94,47,0,1136,1134,1,0,0,0,1137,1140,1,0,0,0,1138,1136,1,0,0,0,
        1138,1139,1,0,0,0,1139,93,1,0,0,0,1140,1138,1,0,0,0,1141,1142,3,
        98,49,0,1142,95,1,0,0,0,1143,1144,7,0,0,0,1144,97,1,0,0,0,1145,1150,
        3,96,48,0,1146,1147,5,473,0,0,1147,1149,3,96,48,0,1148,1146,1,0,
        0,0,1149,1152,1,0,0,0,1150,1148,1,0,0,0,1150,1151,1,0,0,0,1151,99,
        1,0,0,0,1152,1150,1,0,0,0,1153,1154,3,102,51,0,1154,101,1,0,0,0,
        1155,1158,5,9,0,0,1156,1159,3,104,52,0,1157,1159,3,108,54,0,1158,
        1156,1,0,0,0,1158,1157,1,0,0,0,1159,103,1,0,0,0,1160,1161,5,457,
        0,0,1161,1162,5,2,0,0,1162,1163,3,106,53,0,1163,1164,5,3,0,0,1164,
        105,1,0,0,0,1165,1170,3,108,54,0,1166,1167,5,457,0,0,1167,1169,3,
        108,54,0,1168,1166,1,0,0,0,1169,1172,1,0,0,0,1170,1168,1,0,0,0,1170,
        1171,1,0,0,0,1171,107,1,0,0,0,1172,1170,1,0,0,0,1173,1178,3,110,
        55,0,1174,1178,3,112,56,0,1175,1178,3,114,57,0,1176,1178,3,116,58,
        0,1177,1173,1,0,0,0,1177,1174,1,0,0,0,1177,1175,1,0,0,0,1177,1176,
        1,0,0,0,1178,109,1,0,0,0,1179,1180,3,38,19,0,1180,111,1,0,0,0,1181,
        1184,3,110,55,0,1182,1183,5,473,0,0,1183,1185,3,110,55,0,1184,1182,
        1,0,0,0,1185,1186,1,0,0,0,1186,1184,1,0,0,0,1186,1187,1,0,0,0,1187,
        113,1,0,0,0,1188,1189,3,38,19,0,1189,1190,5,10,0,0,1190,1191,5,415,
        0,0,1191,115,1,0,0,0,1192,1193,3,54,27,0,1193,1194,5,11,0,0,1194,
        1195,3,38,19,0,1195,117,1,0,0,0,1196,1197,3,120,60,0,1197,119,1,
        0,0,0,1198,1199,5,13,0,0,1199,1201,3,50,25,0,1200,1202,3,156,78,
        0,1201,1200,1,0,0,0,1201,1202,1,0,0,0,1202,1203,1,0,0,0,1203,1204,
        3,122,61,0,1204,121,1,0,0,0,1205,1206,3,10,5,0,1206,123,1,0,0,0,
        1207,1208,3,126,63,0,1208,125,1,0,0,0,1209,1212,5,12,0,0,1210,1213,
        3,128,64,0,1211,1213,3,132,66,0,1212,1210,1,0,0,0,1212,1211,1,0,
        0,0,1213,127,1,0,0,0,1214,1215,5,457,0,0,1215,1216,5,2,0,0,1216,
        1217,3,130,65,0,1217,1218,5,3,0,0,1218,129,1,0,0,0,1219,1224,3,132,
        66,0,1220,1221,5,457,0,0,1221,1223,3,132,66,0,1222,1220,1,0,0,0,
        1223,1226,1,0,0,0,1224,1222,1,0,0,0,1224,1225,1,0,0,0,1225,131,1,
        0,0,0,1226,1224,1,0,0,0,1227,1231,3,134,67,0,1228,1231,3,136,68,
        0,1229,1231,3,138,69,0,1230,1227,1,0,0,0,1230,1228,1,0,0,0,1230,
        1229,1,0,0,0,1231,133,1,0,0,0,1232,1233,3,770,385,0,1233,135,1,0,
        0,0,1234,1237,3,134,67,0,1235,1236,5,473,0,0,1236,1238,3,134,67,
        0,1237,1235,1,0,0,0,1238,1239,1,0,0,0,1239,1237,1,0,0,0,1239,1240,
        1,0,0,0,1240,137,1,0,0,0,1241,1242,3,772,386,0,1242,1243,5,10,0,
        0,1243,1244,3,46,23,0,1244,139,1,0,0,0,1245,1247,3,142,71,0,1246,
        1245,1,0,0,0,1247,1248,1,0,0,0,1248,1246,1,0,0,0,1248,1249,1,0,0,
        0,1249,1250,1,0,0,0,1250,1251,3,140,70,0,1251,1256,1,0,0,0,1252,
        1256,3,150,75,0,1253,1256,3,194,97,0,1254,1256,3,356,178,0,1255,
        1246,1,0,0,0,1255,1252,1,0,0,0,1255,1253,1,0,0,0,1255,1254,1,0,0,
        0,1256,141,1,0,0,0,1257,1261,3,144,72,0,1258,1261,3,146,73,0,1259,
        1261,3,148,74,0,1260,1257,1,0,0,0,1260,1258,1,0,0,0,1260,1259,1,
        0,0,0,1261,143,1,0,0,0,1262,1269,3,636,318,0,1263,1265,5,457,0,0,
        1264,1263,1,0,0,0,1264,1265,1,0,0,0,1265,1266,1,0,0,0,1266,1268,
        3,636,318,0,1267,1264,1,0,0,0,1268,1271,1,0,0,0,1269,1267,1,0,0,
        0,1269,1270,1,0,0,0,1270,1273,1,0,0,0,1271,1269,1,0,0,0,1272,1274,
        5,457,0,0,1273,1272,1,0,0,0,1273,1274,1,0,0,0,1274,145,1,0,0,0,1275,
        1276,5,340,0,0,1276,1277,3,650,325,0,1277,1279,5,341,0,0,1278,1280,
        5,457,0,0,1279,1278,1,0,0,0,1279,1280,1,0,0,0,1280,147,1,0,0,0,1281,
        1282,7,1,0,0,1282,149,1,0,0,0,1283,1284,3,148,74,0,1284,1285,5,457,
        0,0,1285,1286,5,2,0,0,1286,1291,3,140,70,0,1287,1288,5,457,0,0,1288,
        1290,3,140,70,0,1289,1287,1,0,0,0,1290,1293,1,0,0,0,1291,1289,1,
        0,0,0,1291,1292,1,0,0,0,1292,1294,1,0,0,0,1293,1291,1,0,0,0,1294,
        1295,5,3,0,0,1295,151,1,0,0,0,1296,1297,5,33,0,0,1297,1298,3,654,
        327,0,1298,153,1,0,0,0,1299,1300,5,34,0,0,1300,1301,3,654,327,0,
        1301,155,1,0,0,0,1302,1303,5,35,0,0,1303,1304,3,654,327,0,1304,157,
        1,0,0,0,1305,1309,5,42,0,0,1306,1307,5,41,0,0,1307,1309,3,654,327,
        0,1308,1305,1,0,0,0,1308,1306,1,0,0,0,1309,159,1,0,0,0,1310,1312,
        5,466,0,0,1311,1313,3,162,81,0,1312,1311,1,0,0,0,1312,1313,1,0,0,
        0,1313,1314,1,0,0,0,1314,1315,5,467,0,0,1315,161,1,0,0,0,1316,1321,
        3,164,82,0,1317,1318,5,473,0,0,1318,1320,3,164,82,0,1319,1317,1,
        0,0,0,1320,1323,1,0,0,0,1321,1319,1,0,0,0,1321,1322,1,0,0,0,1322,
        163,1,0,0,0,1323,1321,1,0,0,0,1324,1325,5,415,0,0,1325,1327,5,389,
        0,0,1326,1324,1,0,0,0,1326,1327,1,0,0,0,1327,1328,1,0,0,0,1328,1329,
        3,876,438,0,1329,165,1,0,0,0,1330,1332,5,466,0,0,1331,1333,3,168,
        84,0,1332,1331,1,0,0,0,1332,1333,1,0,0,0,1333,1334,1,0,0,0,1334,
        1335,5,467,0,0,1335,167,1,0,0,0,1336,1341,3,170,85,0,1337,1338,5,
        473,0,0,1338,1340,3,170,85,0,1339,1337,1,0,0,0,1340,1343,1,0,0,0,
        1341,1339,1,0,0,0,1341,1342,1,0,0,0,1342,169,1,0,0,0,1343,1341,1,
        0,0,0,1344,1346,3,144,72,0,1345,1344,1,0,0,0,1345,1346,1,0,0,0,1346,
        1348,1,0,0,0,1347,1349,3,172,86,0,1348,1347,1,0,0,0,1348,1349,1,
        0,0,0,1349,1350,1,0,0,0,1350,1355,5,415,0,0,1351,1353,3,174,87,0,
        1352,1351,1,0,0,0,1352,1353,1,0,0,0,1353,1354,1,0,0,0,1354,1356,
        3,656,328,0,1355,1352,1,0,0,0,1355,1356,1,0,0,0,1356,1359,1,0,0,
        0,1357,1358,5,389,0,0,1358,1360,3,876,438,0,1359,1357,1,0,0,0,1359,
        1360,1,0,0,0,1360,171,1,0,0,0,1361,1362,7,2,0,0,1362,173,1,0,0,0,
        1363,1364,7,3,0,0,1364,175,1,0,0,0,1365,1372,3,656,328,0,1366,1372,
        3,654,327,0,1367,1368,5,466,0,0,1368,1369,3,654,327,0,1369,1370,
        5,467,0,0,1370,1372,1,0,0,0,1371,1365,1,0,0,0,1371,1366,1,0,0,0,
        1371,1367,1,0,0,0,1372,177,1,0,0,0,1373,1378,3,182,91,0,1374,1378,
        3,186,93,0,1375,1378,3,188,94,0,1376,1378,3,180,90,0,1377,1373,1,
        0,0,0,1377,1374,1,0,0,0,1377,1375,1,0,0,0,1377,1376,1,0,0,0,1378,
        179,1,0,0,0,1379,1380,3,10,5,0,1380,181,1,0,0,0,1381,1382,5,475,
        0,0,1382,1383,3,184,92,0,1383,183,1,0,0,0,1384,1385,7,4,0,0,1385,
        185,1,0,0,0,1386,1387,5,376,0,0,1387,1388,3,876,438,0,1388,187,1,
        0,0,0,1389,1391,3,190,95,0,1390,1389,1,0,0,0,1391,1392,1,0,0,0,1392,
        1390,1,0,0,0,1392,1393,1,0,0,0,1393,1395,1,0,0,0,1394,1396,3,192,
        96,0,1395,1394,1,0,0,0,1395,1396,1,0,0,0,1396,189,1,0,0,0,1397,1398,
        5,457,0,0,1398,1399,5,485,0,0,1399,1400,3,874,437,0,1400,1401,5,
        376,0,0,1401,1402,3,876,438,0,1402,191,1,0,0,0,1403,1404,5,457,0,
        0,1404,1407,5,485,0,0,1405,1406,5,80,0,0,1406,1408,5,376,0,0,1407,
        1405,1,0,0,0,1407,1408,1,0,0,0,1408,1409,1,0,0,0,1409,1410,3,876,
        438,0,1410,193,1,0,0,0,1411,1427,3,196,98,0,1412,1427,3,210,105,
        0,1413,1427,3,226,113,0,1414,1427,3,242,121,0,1415,1427,3,258,129,
        0,1416,1427,3,262,131,0,1417,1427,3,266,133,0,1418,1427,3,270,135,
        0,1419,1427,3,274,137,0,1420,1427,3,282,141,0,1421,1427,3,288,144,
        0,1422,1427,3,308,154,0,1423,1427,3,330,165,0,1424,1427,3,336,168,
        0,1425,1427,3,342,171,0,1426,1411,1,0,0,0,1426,1412,1,0,0,0,1426,
        1413,1,0,0,0,1426,1414,1,0,0,0,1426,1415,1,0,0,0,1426,1416,1,0,0,
        0,1426,1417,1,0,0,0,1426,1418,1,0,0,0,1426,1419,1,0,0,0,1426,1420,
        1,0,0,0,1426,1421,1,0,0,0,1426,1422,1,0,0,0,1426,1423,1,0,0,0,1426,
        1424,1,0,0,0,1426,1425,1,0,0,0,1427,195,1,0,0,0,1428,1429,3,198,
        99,0,1429,197,1,0,0,0,1430,1433,5,20,0,0,1431,1434,3,200,100,0,1432,
        1434,3,204,102,0,1433,1431,1,0,0,0,1433,1432,1,0,0,0,1434,199,1,
        0,0,0,1435,1436,5,457,0,0,1436,1437,5,2,0,0,1437,1438,3,202,101,
        0,1438,1439,5,3,0,0,1439,201,1,0,0,0,1440,1445,3,204,102,0,1441,
        1442,5,457,0,0,1442,1444,3,204,102,0,1443,1441,1,0,0,0,1444,1447,
        1,0,0,0,1445,1443,1,0,0,0,1445,1446,1,0,0,0,1446,203,1,0,0,0,1447,
        1445,1,0,0,0,1448,1451,3,206,103,0,1449,1451,3,208,104,0,1450,1448,
        1,0,0,0,1450,1449,1,0,0,0,1451,205,1,0,0,0,1452,1453,3,48,24,0,1453,
        1454,7,5,0,0,1454,1455,3,656,328,0,1455,207,1,0,0,0,1456,1458,3,
        48,24,0,1457,1459,3,656,328,0,1458,1457,1,0,0,0,1458,1459,1,0,0,
        0,1459,1460,1,0,0,0,1460,1461,5,475,0,0,1461,1462,3,760,380,0,1462,
        209,1,0,0,0,1463,1464,3,212,106,0,1464,211,1,0,0,0,1465,1468,5,17,
        0,0,1466,1469,3,214,107,0,1467,1469,3,218,109,0,1468,1466,1,0,0,
        0,1468,1467,1,0,0,0,1469,213,1,0,0,0,1470,1471,5,457,0,0,1471,1472,
        5,2,0,0,1472,1473,3,216,108,0,1473,1474,5,3,0,0,1474,215,1,0,0,0,
        1475,1480,3,218,109,0,1476,1477,5,457,0,0,1477,1479,3,218,109,0,
        1478,1476,1,0,0,0,1479,1482,1,0,0,0,1480,1478,1,0,0,0,1480,1481,
        1,0,0,0,1481,217,1,0,0,0,1482,1480,1,0,0,0,1483,1487,3,220,110,0,
        1484,1487,3,222,111,0,1485,1487,3,224,112,0,1486,1483,1,0,0,0,1486,
        1484,1,0,0,0,1486,1485,1,0,0,0,1487,219,1,0,0,0,1488,1489,3,46,23,
        0,1489,1490,3,628,314,0,1490,1491,3,876,438,0,1491,221,1,0,0,0,1492,
        1497,3,220,110,0,1493,1494,5,473,0,0,1494,1495,3,220,110,0,1495,
        1496,5,2,0,0,1496,1498,1,0,0,0,1497,1493,1,0,0,0,1498,1499,1,0,0,
        0,1499,1497,1,0,0,0,1499,1500,1,0,0,0,1500,223,1,0,0,0,1501,1502,
        5,466,0,0,1502,1503,3,62,31,0,1503,1504,5,467,0,0,1504,1505,3,630,
        315,0,1505,1506,3,874,437,0,1506,225,1,0,0,0,1507,1508,3,228,114,
        0,1508,227,1,0,0,0,1509,1512,5,18,0,0,1510,1513,3,230,115,0,1511,
        1513,3,234,117,0,1512,1510,1,0,0,0,1512,1511,1,0,0,0,1513,229,1,
        0,0,0,1514,1515,5,457,0,0,1515,1516,5,2,0,0,1516,1517,3,232,116,
        0,1517,1518,5,3,0,0,1518,231,1,0,0,0,1519,1524,3,234,117,0,1520,
        1521,5,457,0,0,1521,1523,3,234,117,0,1522,1520,1,0,0,0,1523,1526,
        1,0,0,0,1524,1522,1,0,0,0,1524,1525,1,0,0,0,1525,233,1,0,0,0,1526,
        1524,1,0,0,0,1527,1531,3,236,118,0,1528,1531,3,238,119,0,1529,1531,
        3,240,120,0,1530,1527,1,0,0,0,1530,1528,1,0,0,0,1530,1529,1,0,0,
        0,1531,235,1,0,0,0,1532,1536,3,46,23,0,1533,1534,3,628,314,0,1534,
        1535,3,876,438,0,1535,1537,1,0,0,0,1536,1533,1,0,0,0,1536,1537,1,
        0,0,0,1537,237,1,0,0,0,1538,1541,3,236,118,0,1539,1540,5,473,0,0,
        1540,1542,3,236,118,0,1541,1539,1,0,0,0,1542,1543,1,0,0,0,1543,1541,
        1,0,0,0,1543,1544,1,0,0,0,1544,239,1,0,0,0,1545,1546,5,466,0,0,1546,
        1547,3,62,31,0,1547,1548,5,467,0,0,1548,1549,3,630,315,0,1549,1550,
        3,874,437,0,1550,241,1,0,0,0,1551,1552,3,244,122,0,1552,243,1,0,
        0,0,1553,1556,5,19,0,0,1554,1557,3,246,123,0,1555,1557,3,250,125,
        0,1556,1554,1,0,0,0,1556,1555,1,0,0,0,1557,245,1,0,0,0,1558,1559,
        5,457,0,0,1559,1560,5,2,0,0,1560,1561,3,248,124,0,1561,1562,5,3,
        0,0,1562,247,1,0,0,0,1563,1568,3,250,125,0,1564,1565,5,457,0,0,1565,
        1567,3,250,125,0,1566,1564,1,0,0,0,1567,1570,1,0,0,0,1568,1566,1,
        0,0,0,1568,1569,1,0,0,0,1569,249,1,0,0,0,1570,1568,1,0,0,0,1571,
        1575,3,252,126,0,1572,1575,3,254,127,0,1573,1575,3,256,128,0,1574,
        1571,1,0,0,0,1574,1572,1,0,0,0,1574,1573,1,0,0,0,1575,251,1,0,0,
        0,1576,1580,3,46,23,0,1577,1578,3,628,314,0,1578,1579,3,876,438,
        0,1579,1581,1,0,0,0,1580,1577,1,0,0,0,1580,1581,1,0,0,0,1581,253,
        1,0,0,0,1582,1585,3,252,126,0,1583,1584,5,473,0,0,1584,1586,3,252,
        126,0,1585,1583,1,0,0,0,1586,1587,1,0,0,0,1587,1585,1,0,0,0,1587,
        1588,1,0,0,0,1588,255,1,0,0,0,1589,1590,5,466,0,0,1590,1591,3,62,
        31,0,1591,1592,5,467,0,0,1592,1593,3,630,315,0,1593,1594,3,874,437,
        0,1594,257,1,0,0,0,1595,1596,3,260,130,0,1596,259,1,0,0,0,1597,1598,
        5,21,0,0,1598,1599,3,50,25,0,1599,1601,3,170,85,0,1600,1602,3,158,
        79,0,1601,1600,1,0,0,0,1601,1602,1,0,0,0,1602,1603,1,0,0,0,1603,
        1604,3,178,89,0,1604,261,1,0,0,0,1605,1606,3,264,132,0,1606,263,
        1,0,0,0,1607,1608,5,23,0,0,1608,1609,3,50,25,0,1609,1610,3,166,83,
        0,1610,1612,3,176,88,0,1611,1613,3,158,79,0,1612,1611,1,0,0,0,1612,
        1613,1,0,0,0,1613,1615,1,0,0,0,1614,1616,3,178,89,0,1615,1614,1,
        0,0,0,1615,1616,1,0,0,0,1616,265,1,0,0,0,1617,1618,3,268,134,0,1618,
        267,1,0,0,0,1619,1620,5,24,0,0,1620,1621,3,50,25,0,1621,1622,3,166,
        83,0,1622,1624,3,176,88,0,1623,1625,3,158,79,0,1624,1623,1,0,0,0,
        1624,1625,1,0,0,0,1625,1627,1,0,0,0,1626,1628,3,178,89,0,1627,1626,
        1,0,0,0,1627,1628,1,0,0,0,1628,269,1,0,0,0,1629,1630,3,272,136,0,
        1630,271,1,0,0,0,1631,1632,5,25,0,0,1632,1633,3,50,25,0,1633,1635,
        3,166,83,0,1634,1636,3,158,79,0,1635,1634,1,0,0,0,1635,1636,1,0,
        0,0,1636,1638,1,0,0,0,1637,1639,3,178,89,0,1638,1637,1,0,0,0,1638,
        1639,1,0,0,0,1639,273,1,0,0,0,1640,1641,3,276,138,0,1641,275,1,0,
        0,0,1642,1643,5,26,0,0,1643,1644,3,278,139,0,1644,1645,3,166,83,
        0,1645,1647,3,176,88,0,1646,1648,3,158,79,0,1647,1646,1,0,0,0,1647,
        1648,1,0,0,0,1648,1650,1,0,0,0,1649,1651,3,178,89,0,1650,1649,1,
        0,0,0,1650,1651,1,0,0,0,1651,277,1,0,0,0,1652,1655,3,50,25,0,1653,
        1655,3,280,140,0,1654,1652,1,0,0,0,1654,1653,1,0,0,0,1655,279,1,
        0,0,0,1656,1658,3,144,72,0,1657,1656,1,0,0,0,1657,1658,1,0,0,0,1658,
        1659,1,0,0,0,1659,1661,3,634,317,0,1660,1662,3,648,324,0,1661,1660,
        1,0,0,0,1661,1662,1,0,0,0,1662,281,1,0,0,0,1663,1664,3,284,142,0,
        1664,283,1,0,0,0,1665,1666,5,27,0,0,1666,1667,3,50,25,0,1667,1668,
        3,286,143,0,1668,1670,3,176,88,0,1669,1671,3,158,79,0,1670,1669,
        1,0,0,0,1670,1671,1,0,0,0,1671,1673,1,0,0,0,1672,1674,3,178,89,0,
        1673,1672,1,0,0,0,1673,1674,1,0,0,0,1674,285,1,0,0,0,1675,1677,5,
        468,0,0,1676,1678,3,168,84,0,1677,1676,1,0,0,0,1677,1678,1,0,0,0,
        1678,1679,1,0,0,0,1679,1680,5,469,0,0,1680,287,1,0,0,0,1681,1682,
        3,290,145,0,1682,289,1,0,0,0,1683,1684,5,22,0,0,1684,1686,3,50,25,
        0,1685,1687,3,166,83,0,1686,1685,1,0,0,0,1686,1687,1,0,0,0,1687,
        1689,1,0,0,0,1688,1690,3,292,146,0,1689,1688,1,0,0,0,1689,1690,1,
        0,0,0,1690,1692,1,0,0,0,1691,1693,3,156,78,0,1692,1691,1,0,0,0,1692,
        1693,1,0,0,0,1693,1694,1,0,0,0,1694,1695,3,294,147,0,1695,291,1,
        0,0,0,1696,1697,3,656,328,0,1697,293,1,0,0,0,1698,1701,3,296,148,
        0,1699,1701,3,298,149,0,1700,1698,1,0,0,0,1700,1699,1,0,0,0,1701,
        295,1,0,0,0,1702,1703,5,475,0,0,1703,1704,3,306,153,0,1704,297,1,
        0,0,0,1705,1706,5,457,0,0,1706,1707,5,2,0,0,1707,1708,3,300,150,
        0,1708,1709,5,3,0,0,1709,299,1,0,0,0,1710,1715,3,302,151,0,1711,
        1712,5,457,0,0,1712,1714,3,302,151,0,1713,1711,1,0,0,0,1714,1717,
        1,0,0,0,1715,1713,1,0,0,0,1715,1716,1,0,0,0,1716,301,1,0,0,0,1717,
        1715,1,0,0,0,1718,1722,3,12,6,0,1719,1722,3,304,152,0,1720,1722,
        3,306,153,0,1721,1718,1,0,0,0,1721,1719,1,0,0,0,1721,1720,1,0,0,
        0,1722,303,1,0,0,0,1723,1725,3,40,20,0,1724,1726,3,160,80,0,1725,
        1724,1,0,0,0,1725,1726,1,0,0,0,1726,1729,1,0,0,0,1727,1728,5,389,
        0,0,1728,1730,3,876,438,0,1729,1727,1,0,0,0,1729,1730,1,0,0,0,1730,
        305,1,0,0,0,1731,1736,3,304,152,0,1732,1733,5,473,0,0,1733,1735,
        3,304,152,0,1734,1732,1,0,0,0,1735,1738,1,0,0,0,1736,1734,1,0,0,
        0,1736,1737,1,0,0,0,1737,307,1,0,0,0,1738,1736,1,0,0,0,1739,1740,
        3,310,155,0,1740,309,1,0,0,0,1741,1742,5,28,0,0,1742,1744,3,50,25,
        0,1743,1745,3,156,78,0,1744,1743,1,0,0,0,1744,1745,1,0,0,0,1745,
        1746,1,0,0,0,1746,1747,3,312,156,0,1747,311,1,0,0,0,1748,1751,3,
        314,157,0,1749,1751,3,316,158,0,1750,1748,1,0,0,0,1750,1749,1,0,
        0,0,1751,313,1,0,0,0,1752,1753,5,475,0,0,1753,1754,3,326,163,0,1754,
        315,1,0,0,0,1755,1756,5,457,0,0,1756,1757,5,2,0,0,1757,1758,3,318,
        159,0,1758,1759,5,3,0,0,1759,317,1,0,0,0,1760,1765,3,320,160,0,1761,
        1762,5,457,0,0,1762,1764,3,320,160,0,1763,1761,1,0,0,0,1764,1767,
        1,0,0,0,1765,1763,1,0,0,0,1765,1766,1,0,0,0,1766,319,1,0,0,0,1767,
        1765,1,0,0,0,1768,1773,3,12,6,0,1769,1773,3,322,161,0,1770,1773,
        3,326,163,0,1771,1773,3,328,164,0,1772,1768,1,0,0,0,1772,1769,1,
        0,0,0,1772,1770,1,0,0,0,1772,1771,1,0,0,0,1773,321,1,0,0,0,1774,
        1776,3,46,23,0,1775,1777,3,324,162,0,1776,1775,1,0,0,0,1776,1777,
        1,0,0,0,1777,1780,1,0,0,0,1778,1779,5,389,0,0,1779,1781,3,876,438,
        0,1780,1778,1,0,0,0,1780,1781,1,0,0,0,1781,323,1,0,0,0,1782,1783,
        3,754,377,0,1783,325,1,0,0,0,1784,1787,3,322,161,0,1785,1786,5,473,
        0,0,1786,1788,3,322,161,0,1787,1785,1,0,0,0,1788,1789,1,0,0,0,1789,
        1787,1,0,0,0,1789,1790,1,0,0,0,1790,327,1,0,0,0,1791,1792,3,40,20,
        0,1792,1793,5,28,0,0,1793,1794,3,316,158,0,1794,329,1,0,0,0,1795,
        1796,3,332,166,0,1796,331,1,0,0,0,1797,1798,5,29,0,0,1798,1800,3,
        50,25,0,1799,1801,3,152,76,0,1800,1799,1,0,0,0,1800,1801,1,0,0,0,
        1801,1803,1,0,0,0,1802,1804,3,156,78,0,1803,1802,1,0,0,0,1803,1804,
        1,0,0,0,1804,1805,1,0,0,0,1805,1806,3,334,167,0,1806,333,1,0,0,0,
        1807,1808,3,10,5,0,1808,335,1,0,0,0,1809,1810,3,338,169,0,1810,337,
        1,0,0,0,1811,1812,5,30,0,0,1812,1814,3,50,25,0,1813,1815,3,156,78,
        0,1814,1813,1,0,0,0,1814,1815,1,0,0,0,1815,1816,1,0,0,0,1816,1817,
        3,340,170,0,1817,339,1,0,0,0,1818,1819,3,10,5,0,1819,341,1,0,0,0,
        1820,1821,3,344,172,0,1821,343,1,0,0,0,1822,1823,5,31,0,0,1823,1825,
        3,50,25,0,1824,1826,3,152,76,0,1825,1824,1,0,0,0,1825,1826,1,0,0,
        0,1826,1828,1,0,0,0,1827,1829,3,154,77,0,1828,1827,1,0,0,0,1828,
        1829,1,0,0,0,1829,1831,1,0,0,0,1830,1832,3,156,78,0,1831,1830,1,
        0,0,0,1831,1832,1,0,0,0,1832,1833,1,0,0,0,1833,1834,3,346,173,0,
        1834,345,1,0,0,0,1835,1838,3,348,174,0,1836,1838,3,354,177,0,1837,
        1835,1,0,0,0,1837,1836,1,0,0,0,1838,347,1,0,0,0,1839,1840,5,475,
        0,0,1840,1841,3,350,175,0,1841,349,1,0,0,0,1842,1847,3,352,176,0,
        1843,1844,5,473,0,0,1844,1846,3,352,176,0,1845,1843,1,0,0,0,1846,
        1849,1,0,0,0,1847,1845,1,0,0,0,1847,1848,1,0,0,0,1848,351,1,0,0,
        0,1849,1847,1,0,0,0,1850,1852,3,46,23,0,1851,1853,3,324,162,0,1852,
        1851,1,0,0,0,1852,1853,1,0,0,0,1853,1856,1,0,0,0,1854,1855,5,389,
        0,0,1855,1857,3,876,438,0,1856,1854,1,0,0,0,1856,1857,1,0,0,0,1857,
        353,1,0,0,0,1858,1859,3,10,5,0,1859,355,1,0,0,0,1860,1865,3,358,
        179,0,1861,1865,3,368,184,0,1862,1865,3,372,186,0,1863,1865,3,378,
        189,0,1864,1860,1,0,0,0,1864,1861,1,0,0,0,1864,1862,1,0,0,0,1864,
        1863,1,0,0,0,1865,357,1,0,0,0,1866,1867,3,360,180,0,1867,359,1,0,
        0,0,1868,1869,5,36,0,0,1869,1871,3,166,83,0,1870,1872,3,362,181,
        0,1871,1870,1,0,0,0,1871,1872,1,0,0,0,1872,1874,1,0,0,0,1873,1875,
        3,158,79,0,1874,1873,1,0,0,0,1874,1875,1,0,0,0,1875,1876,1,0,0,0,
        1876,1877,3,178,89,0,1877,361,1,0,0,0,1878,1879,5,470,0,0,1879,1880,
        3,364,182,0,1880,1881,5,471,0,0,1881,363,1,0,0,0,1882,1887,3,366,
        183,0,1883,1884,5,473,0,0,1884,1886,3,366,183,0,1885,1883,1,0,0,
        0,1886,1889,1,0,0,0,1887,1885,1,0,0,0,1887,1888,1,0,0,0,1888,365,
        1,0,0,0,1889,1887,1,0,0,0,1890,1891,3,38,19,0,1891,1892,5,475,0,
        0,1892,1894,1,0,0,0,1893,1890,1,0,0,0,1893,1894,1,0,0,0,1894,1895,
        1,0,0,0,1895,1896,3,876,438,0,1896,367,1,0,0,0,1897,1898,3,370,185,
        0,1898,369,1,0,0,0,1899,1901,5,37,0,0,1900,1902,3,166,83,0,1901,
        1900,1,0,0,0,1901,1902,1,0,0,0,1902,1904,1,0,0,0,1903,1905,3,158,
        79,0,1904,1903,1,0,0,0,1904,1905,1,0,0,0,1905,1906,1,0,0,0,1906,
        1907,3,178,89,0,1907,371,1,0,0,0,1908,1909,3,374,187,0,1909,373,
        1,0,0,0,1910,1911,5,38,0,0,1911,1913,3,50,25,0,1912,1914,3,656,328,
        0,1913,1912,1,0,0,0,1913,1914,1,0,0,0,1914,1916,1,0,0,0,1915,1917,
        3,324,162,0,1916,1915,1,0,0,0,1916,1917,1,0,0,0,1917,1920,1,0,0,
        0,1918,1919,5,389,0,0,1919,1921,3,876,438,0,1920,1918,1,0,0,0,1920,
        1921,1,0,0,0,1921,1922,1,0,0,0,1922,1923,3,376,188,0,1923,375,1,
        0,0,0,1924,1925,3,10,5,0,1925,377,1,0,0,0,1926,1929,3,380,190,0,
        1927,1929,3,382,191,0,1928,1926,1,0,0,0,1928,1927,1,0,0,0,1929,379,
        1,0,0,0,1930,1932,5,39,0,0,1931,1933,3,50,25,0,1932,1931,1,0,0,0,
        1932,1933,1,0,0,0,1933,1935,1,0,0,0,1934,1936,3,166,83,0,1935,1934,
        1,0,0,0,1935,1936,1,0,0,0,1936,1938,1,0,0,0,1937,1939,3,158,79,0,
        1938,1937,1,0,0,0,1938,1939,1,0,0,0,1939,1940,1,0,0,0,1940,1941,
        3,178,89,0,1941,381,1,0,0,0,1942,1944,5,40,0,0,1943,1945,3,50,25,
        0,1944,1943,1,0,0,0,1944,1945,1,0,0,0,1945,1947,1,0,0,0,1946,1948,
        3,166,83,0,1947,1946,1,0,0,0,1947,1948,1,0,0,0,1948,1950,1,0,0,0,
        1949,1951,3,158,79,0,1950,1949,1,0,0,0,1950,1951,1,0,0,0,1951,1952,
        1,0,0,0,1952,1953,3,178,89,0,1953,383,1,0,0,0,1954,1955,3,36,18,
        0,1955,1956,5,475,0,0,1956,1965,1,0,0,0,1957,1958,3,36,18,0,1958,
        1959,5,475,0,0,1959,1960,3,384,192,0,1960,1965,1,0,0,0,1961,1965,
        3,392,196,0,1962,1965,3,450,225,0,1963,1965,3,534,267,0,1964,1954,
        1,0,0,0,1964,1957,1,0,0,0,1964,1961,1,0,0,0,1964,1962,1,0,0,0,1964,
        1963,1,0,0,0,1965,385,1,0,0,0,1966,1967,5,457,0,0,1967,1968,5,2,
        0,0,1968,1969,3,388,194,0,1969,1970,5,3,0,0,1970,387,1,0,0,0,1971,
        1976,3,384,192,0,1972,1973,5,457,0,0,1973,1975,3,384,192,0,1974,
        1972,1,0,0,0,1975,1978,1,0,0,0,1976,1974,1,0,0,0,1976,1977,1,0,0,
        0,1977,389,1,0,0,0,1978,1976,1,0,0,0,1979,1980,5,376,0,0,1980,1985,
        3,876,438,0,1981,1982,5,91,0,0,1982,1985,3,392,196,0,1983,1985,3,
        386,193,0,1984,1979,1,0,0,0,1984,1981,1,0,0,0,1984,1983,1,0,0,0,
        1985,391,1,0,0,0,1986,1987,6,196,-1,0,1987,1994,3,398,199,0,1988,
        1994,3,406,203,0,1989,1994,3,420,210,0,1990,1994,3,442,221,0,1991,
        1994,3,394,197,0,1992,1994,3,396,198,0,1993,1986,1,0,0,0,1993,1988,
        1,0,0,0,1993,1989,1,0,0,0,1993,1990,1,0,0,0,1993,1991,1,0,0,0,1993,
        1992,1,0,0,0,1994,2010,1,0,0,0,1995,1996,10,10,0,0,1996,1997,3,618,
        309,0,1997,1998,3,384,192,0,1998,2009,1,0,0,0,1999,2000,10,9,0,0,
        2000,2001,5,86,0,0,2001,2009,3,384,192,0,2002,2003,10,8,0,0,2003,
        2004,5,87,0,0,2004,2009,3,876,438,0,2005,2006,10,7,0,0,2006,2007,
        5,88,0,0,2007,2009,3,876,438,0,2008,1995,1,0,0,0,2008,1999,1,0,0,
        0,2008,2002,1,0,0,0,2008,2005,1,0,0,0,2009,2012,1,0,0,0,2010,2008,
        1,0,0,0,2010,2011,1,0,0,0,2011,393,1,0,0,0,2012,2010,1,0,0,0,2013,
        2014,3,874,437,0,2014,395,1,0,0,0,2015,2016,5,328,0,0,2016,397,1,
        0,0,0,2017,2018,5,140,0,0,2018,2023,3,398,199,0,2019,2023,3,400,
        200,0,2020,2023,3,402,201,0,2021,2023,3,404,202,0,2022,2017,1,0,
        0,0,2022,2019,1,0,0,0,2022,2020,1,0,0,0,2022,2021,1,0,0,0,2023,399,
        1,0,0,0,2024,2025,3,854,427,0,2025,2026,3,628,314,0,2026,2027,3,
        876,438,0,2027,401,1,0,0,0,2028,2031,3,400,200,0,2029,2030,5,473,
        0,0,2030,2032,3,400,200,0,2031,2029,1,0,0,0,2032,2033,1,0,0,0,2033,
        2031,1,0,0,0,2033,2034,1,0,0,0,2034,403,1,0,0,0,2035,2036,3,852,
        426,0,2036,2037,3,630,315,0,2037,2038,3,874,437,0,2038,405,1,0,0,
        0,2039,2040,3,408,204,0,2040,2041,3,406,203,0,2041,2048,1,0,0,0,
        2042,2048,3,410,205,0,2043,2048,3,412,206,0,2044,2048,3,414,207,
        0,2045,2048,3,416,208,0,2046,2048,3,418,209,0,2047,2039,1,0,0,0,
        2047,2042,1,0,0,0,2047,2043,1,0,0,0,2047,2044,1,0,0,0,2047,2045,
        1,0,0,0,2047,2046,1,0,0,0,2048,407,1,0,0,0,2049,2050,5,118,0,0,2050,
        2051,3,874,437,0,2051,409,1,0,0,0,2052,2054,5,120,0,0,2053,2055,
        3,876,438,0,2054,2053,1,0,0,0,2054,2055,1,0,0,0,2055,2057,1,0,0,
        0,2056,2058,5,473,0,0,2057,2056,1,0,0,0,2057,2058,1,0,0,0,2058,411,
        1,0,0,0,2059,2061,5,119,0,0,2060,2062,3,876,438,0,2061,2060,1,0,
        0,0,2061,2062,1,0,0,0,2062,2064,1,0,0,0,2063,2065,5,473,0,0,2064,
        2063,1,0,0,0,2064,2065,1,0,0,0,2065,413,1,0,0,0,2066,2068,5,121,
        0,0,2067,2069,3,876,438,0,2068,2067,1,0,0,0,2068,2069,1,0,0,0,2069,
        415,1,0,0,0,2070,2072,5,122,0,0,2071,2073,3,876,438,0,2072,2071,
        1,0,0,0,2072,2073,1,0,0,0,2073,417,1,0,0,0,2074,2075,5,123,0,0,2075,
        2076,3,874,437,0,2076,419,1,0,0,0,2077,2088,3,422,211,0,2078,2088,
        3,424,212,0,2079,2088,3,426,213,0,2080,2088,3,428,214,0,2081,2088,
        3,430,215,0,2082,2088,3,432,216,0,2083,2088,3,434,217,0,2084,2088,
        3,436,218,0,2085,2088,3,438,219,0,2086,2088,3,440,220,0,2087,2077,
        1,0,0,0,2087,2078,1,0,0,0,2087,2079,1,0,0,0,2087,2080,1,0,0,0,2087,
        2081,1,0,0,0,2087,2082,1,0,0,0,2087,2083,1,0,0,0,2087,2084,1,0,0,
        0,2087,2085,1,0,0,0,2087,2086,1,0,0,0,2088,421,1,0,0,0,2089,2092,
        5,100,0,0,2090,2093,3,36,18,0,2091,2093,5,419,0,0,2092,2090,1,0,
        0,0,2092,2091,1,0,0,0,2092,2093,1,0,0,0,2093,423,1,0,0,0,2094,2097,
        5,101,0,0,2095,2098,3,36,18,0,2096,2098,5,419,0,0,2097,2095,1,0,
        0,0,2097,2096,1,0,0,0,2097,2098,1,0,0,0,2098,425,1,0,0,0,2099,2102,
        5,102,0,0,2100,2103,3,36,18,0,2101,2103,5,419,0,0,2102,2100,1,0,
        0,0,2102,2101,1,0,0,0,2102,2103,1,0,0,0,2103,427,1,0,0,0,2104,2107,
        5,83,0,0,2105,2108,3,36,18,0,2106,2108,5,419,0,0,2107,2105,1,0,0,
        0,2107,2106,1,0,0,0,2107,2108,1,0,0,0,2108,429,1,0,0,0,2109,2110,
        5,89,0,0,2110,2111,3,384,192,0,2111,431,1,0,0,0,2112,2114,5,115,
        0,0,2113,2115,3,36,18,0,2114,2113,1,0,0,0,2114,2115,1,0,0,0,2115,
        433,1,0,0,0,2116,2118,5,103,0,0,2117,2119,3,874,437,0,2118,2117,
        1,0,0,0,2118,2119,1,0,0,0,2119,435,1,0,0,0,2120,2121,5,104,0,0,2121,
        2122,3,874,437,0,2122,437,1,0,0,0,2123,2124,5,105,0,0,2124,2125,
        3,876,438,0,2125,439,1,0,0,0,2126,2127,5,106,0,0,2127,2128,3,876,
        438,0,2128,441,1,0,0,0,2129,2133,3,444,222,0,2130,2133,3,446,223,
        0,2131,2133,3,448,224,0,2132,2129,1,0,0,0,2132,2130,1,0,0,0,2132,
        2131,1,0,0,0,2133,443,1,0,0,0,2134,2135,5,77,0,0,2135,2136,3,876,
        438,0,2136,2137,5,78,0,0,2137,2138,3,384,192,0,2138,445,1,0,0,0,
        2139,2140,5,107,0,0,2140,2143,3,876,438,0,2141,2142,5,108,0,0,2142,
        2144,3,852,426,0,2143,2141,1,0,0,0,2143,2144,1,0,0,0,2144,447,1,
        0,0,0,2145,2146,5,111,0,0,2146,2147,3,874,437,0,2147,449,1,0,0,0,
        2148,2153,3,452,226,0,2149,2153,3,454,227,0,2150,2153,3,456,228,
        0,2151,2153,3,458,229,0,2152,2148,1,0,0,0,2152,2149,1,0,0,0,2152,
        2150,1,0,0,0,2152,2151,1,0,0,0,2153,451,1,0,0,0,2154,2159,3,460,
        230,0,2155,2159,3,468,234,0,2156,2159,3,474,237,0,2157,2159,3,480,
        240,0,2158,2154,1,0,0,0,2158,2155,1,0,0,0,2158,2156,1,0,0,0,2158,
        2157,1,0,0,0,2159,453,1,0,0,0,2160,2161,3,488,244,0,2161,455,1,0,
        0,0,2162,2165,3,516,258,0,2163,2165,3,522,261,0,2164,2162,1,0,0,
        0,2164,2163,1,0,0,0,2165,457,1,0,0,0,2166,2167,3,526,263,0,2167,
        459,1,0,0,0,2168,2172,3,462,231,0,2169,2171,3,464,232,0,2170,2169,
        1,0,0,0,2171,2174,1,0,0,0,2172,2170,1,0,0,0,2172,2173,1,0,0,0,2173,
        2176,1,0,0,0,2174,2172,1,0,0,0,2175,2177,3,466,233,0,2176,2175,1,
        0,0,0,2176,2177,1,0,0,0,2177,461,1,0,0,0,2178,2179,5,77,0,0,2179,
        2180,3,876,438,0,2180,2181,3,390,195,0,2181,463,1,0,0,0,2182,2183,
        5,457,0,0,2183,2184,5,79,0,0,2184,2185,3,876,438,0,2185,2186,3,390,
        195,0,2186,465,1,0,0,0,2187,2188,5,457,0,0,2188,2189,5,80,0,0,2189,
        2190,3,390,195,0,2190,467,1,0,0,0,2191,2193,3,470,235,0,2192,2194,
        3,472,236,0,2193,2192,1,0,0,0,2194,2195,1,0,0,0,2195,2193,1,0,0,
        0,2195,2196,1,0,0,0,2196,2198,1,0,0,0,2197,2199,3,466,233,0,2198,
        2197,1,0,0,0,2198,2199,1,0,0,0,2199,469,1,0,0,0,2200,2202,5,81,0,
        0,2201,2203,3,876,438,0,2202,2201,1,0,0,0,2202,2203,1,0,0,0,2203,
        471,1,0,0,0,2204,2205,5,457,0,0,2205,2206,5,82,0,0,2206,2207,3,874,
        437,0,2207,2208,3,390,195,0,2208,473,1,0,0,0,2209,2213,3,476,238,
        0,2210,2212,3,478,239,0,2211,2210,1,0,0,0,2212,2215,1,0,0,0,2213,
        2211,1,0,0,0,2213,2214,1,0,0,0,2214,475,1,0,0,0,2215,2213,1,0,0,
        0,2216,2217,5,84,0,0,2217,2219,3,874,437,0,2218,2220,3,390,195,0,
        2219,2218,1,0,0,0,2219,2220,1,0,0,0,2220,477,1,0,0,0,2221,2222,5,
        457,0,0,2222,2224,5,85,0,0,2223,2225,3,62,31,0,2224,2223,1,0,0,0,
        2224,2225,1,0,0,0,2225,2226,1,0,0,0,2226,2227,3,390,195,0,2227,479,
        1,0,0,0,2228,2230,3,482,241,0,2229,2231,3,484,242,0,2230,2229,1,
        0,0,0,2231,2232,1,0,0,0,2232,2230,1,0,0,0,2232,2233,1,0,0,0,2233,
        2235,1,0,0,0,2234,2236,3,486,243,0,2235,2234,1,0,0,0,2235,2236,1,
        0,0,0,2236,481,1,0,0,0,2237,2238,5,112,0,0,2238,2239,3,874,437,0,
        2239,483,1,0,0,0,2240,2241,5,457,0,0,2241,2242,5,113,0,0,2242,2243,
        3,874,437,0,2243,2244,3,390,195,0,2244,485,1,0,0,0,2245,2246,5,457,
        0,0,2246,2247,5,114,0,0,2247,2248,3,390,195,0,2248,487,1,0,0,0,2249,
        2251,3,490,245,0,2250,2252,3,514,257,0,2251,2250,1,0,0,0,2251,2252,
        1,0,0,0,2252,489,1,0,0,0,2253,2255,5,92,0,0,2254,2256,3,250,125,
        0,2255,2254,1,0,0,0,2255,2256,1,0,0,0,2256,2257,1,0,0,0,2257,2258,
        3,492,246,0,2258,491,1,0,0,0,2259,2263,3,494,247,0,2260,2263,3,496,
        248,0,2261,2263,3,498,249,0,2262,2259,1,0,0,0,2262,2260,1,0,0,0,
        2262,2261,1,0,0,0,2263,493,1,0,0,0,2264,2266,3,502,251,0,2265,2264,
        1,0,0,0,2265,2266,1,0,0,0,2266,2268,1,0,0,0,2267,2269,3,500,250,
        0,2268,2267,1,0,0,0,2268,2269,1,0,0,0,2269,2270,1,0,0,0,2270,2271,
        3,390,195,0,2271,495,1,0,0,0,2272,2274,3,504,252,0,2273,2275,3,502,
        251,0,2274,2273,1,0,0,0,2274,2275,1,0,0,0,2275,2277,1,0,0,0,2276,
        2278,3,500,250,0,2277,2276,1,0,0,0,2277,2278,1,0,0,0,2278,2279,1,
        0,0,0,2279,2280,3,390,195,0,2280,497,1,0,0,0,2281,2282,3,386,193,
        0,2282,2283,5,457,0,0,2283,2285,3,506,253,0,2284,2286,3,502,251,
        0,2285,2284,1,0,0,0,2285,2286,1,0,0,0,2286,2288,1,0,0,0,2287,2289,
        3,500,250,0,2288,2287,1,0,0,0,2288,2289,1,0,0,0,2289,499,1,0,0,0,
        2290,2291,5,99,0,0,2291,2292,3,392,196,0,2292,501,1,0,0,0,2293,2294,
        5,98,0,0,2294,2295,3,876,438,0,2295,503,1,0,0,0,2296,2300,3,508,
        254,0,2297,2300,3,510,255,0,2298,2300,3,512,256,0,2299,2296,1,0,
        0,0,2299,2297,1,0,0,0,2299,2298,1,0,0,0,2300,505,1,0,0,0,2301,2304,
        3,510,255,0,2302,2304,3,512,256,0,2303,2301,1,0,0,0,2303,2302,1,
        0,0,0,2304,507,1,0,0,0,2305,2306,3,52,26,0,2306,2307,5,94,0,0,2307,
        2310,3,874,437,0,2308,2309,5,95,0,0,2309,2311,3,876,438,0,2310,2308,
        1,0,0,0,2310,2311,1,0,0,0,2311,509,1,0,0,0,2312,2313,5,96,0,0,2313,
        2314,3,876,438,0,2314,511,1,0,0,0,2315,2316,5,97,0,0,2316,2317,3,
        876,438,0,2317,513,1,0,0,0,2318,2319,5,457,0,0,2319,2320,5,78,0,
        0,2320,2321,3,390,195,0,2321,515,1,0,0,0,2322,2326,3,518,259,0,2323,
        2325,3,478,239,0,2324,2323,1,0,0,0,2325,2328,1,0,0,0,2326,2324,1,
        0,0,0,2326,2327,1,0,0,0,2327,2329,1,0,0,0,2328,2326,1,0,0,0,2329,
        2330,3,520,260,0,2330,517,1,0,0,0,2331,2332,5,116,0,0,2332,2333,
        3,390,195,0,2333,519,1,0,0,0,2334,2335,5,457,0,0,2335,2336,5,117,
        0,0,2336,2337,3,390,195,0,2337,521,1,0,0,0,2338,2339,3,524,262,0,
        2339,523,1,0,0,0,2340,2341,5,90,0,0,2341,2343,3,874,437,0,2342,2344,
        3,390,195,0,2343,2342,1,0,0,0,2343,2344,1,0,0,0,2344,525,1,0,0,0,
        2345,2347,3,528,264,0,2346,2348,3,530,265,0,2347,2346,1,0,0,0,2347,
        2348,1,0,0,0,2348,2350,1,0,0,0,2349,2351,3,532,266,0,2350,2349,1,
        0,0,0,2350,2351,1,0,0,0,2351,527,1,0,0,0,2352,2354,5,109,0,0,2353,
        2355,3,40,20,0,2354,2353,1,0,0,0,2354,2355,1,0,0,0,2355,2356,1,0,
        0,0,2356,2357,3,386,193,0,2357,529,1,0,0,0,2358,2359,5,110,0,0,2359,
        2360,3,876,438,0,2360,531,1,0,0,0,2361,2362,5,93,0,0,2362,2363,3,
        52,26,0,2363,2364,5,94,0,0,2364,2367,3,874,437,0,2365,2366,5,95,
        0,0,2366,2368,3,876,438,0,2367,2365,1,0,0,0,2367,2368,1,0,0,0,2368,
        533,1,0,0,0,2369,2372,3,536,268,0,2370,2372,3,538,269,0,2371,2369,
        1,0,0,0,2371,2370,1,0,0,0,2372,535,1,0,0,0,2373,2374,3,540,270,0,
        2374,537,1,0,0,0,2375,2376,3,544,272,0,2376,539,1,0,0,0,2377,2378,
        3,542,271,0,2378,541,1,0,0,0,2379,2380,5,309,0,0,2380,2384,3,876,
        438,0,2381,2385,5,365,0,0,2382,2383,5,365,0,0,2383,2385,3,876,438,
        0,2384,2381,1,0,0,0,2384,2382,1,0,0,0,2384,2385,1,0,0,0,2385,543,
        1,0,0,0,2386,2389,3,546,273,0,2387,2388,5,457,0,0,2388,2390,3,548,
        274,0,2389,2387,1,0,0,0,2389,2390,1,0,0,0,2390,2393,1,0,0,0,2391,
        2392,5,457,0,0,2392,2394,3,550,275,0,2393,2391,1,0,0,0,2393,2394,
        1,0,0,0,2394,2397,1,0,0,0,2395,2396,5,457,0,0,2396,2398,3,552,276,
        0,2397,2395,1,0,0,0,2397,2398,1,0,0,0,2398,2401,1,0,0,0,2399,2400,
        5,457,0,0,2400,2402,3,558,279,0,2401,2399,1,0,0,0,2401,2402,1,0,
        0,0,2402,2405,1,0,0,0,2403,2404,5,457,0,0,2404,2406,3,560,280,0,
        2405,2403,1,0,0,0,2405,2406,1,0,0,0,2406,2409,1,0,0,0,2407,2408,
        5,457,0,0,2408,2410,3,562,281,0,2409,2407,1,0,0,0,2409,2410,1,0,
        0,0,2410,2413,1,0,0,0,2411,2412,5,457,0,0,2412,2414,3,564,282,0,
        2413,2411,1,0,0,0,2413,2414,1,0,0,0,2414,2417,1,0,0,0,2415,2416,
        5,457,0,0,2416,2418,3,566,283,0,2417,2415,1,0,0,0,2417,2418,1,0,
        0,0,2418,2421,1,0,0,0,2419,2420,5,457,0,0,2420,2422,3,568,284,0,
        2421,2419,1,0,0,0,2421,2422,1,0,0,0,2422,2425,1,0,0,0,2423,2424,
        5,457,0,0,2424,2426,3,570,285,0,2425,2423,1,0,0,0,2425,2426,1,0,
        0,0,2426,545,1,0,0,0,2427,2429,5,310,0,0,2428,2430,3,752,376,0,2429,
        2428,1,0,0,0,2429,2430,1,0,0,0,2430,2432,1,0,0,0,2431,2433,3,10,
        5,0,2432,2431,1,0,0,0,2432,2433,1,0,0,0,2433,547,1,0,0,0,2434,2437,
        5,311,0,0,2435,2438,3,874,437,0,2436,2438,3,10,5,0,2437,2435,1,0,
        0,0,2437,2436,1,0,0,0,2438,549,1,0,0,0,2439,2442,5,312,0,0,2440,
        2443,3,874,437,0,2441,2443,3,10,5,0,2442,2440,1,0,0,0,2442,2441,
        1,0,0,0,2443,551,1,0,0,0,2444,2445,5,313,0,0,2445,2446,5,457,0,0,
        2446,2447,5,2,0,0,2447,2448,3,554,277,0,2448,2449,5,3,0,0,2449,553,
        1,0,0,0,2450,2455,3,556,278,0,2451,2452,5,457,0,0,2452,2454,3,556,
        278,0,2453,2451,1,0,0,0,2454,2457,1,0,0,0,2455,2453,1,0,0,0,2455,
        2456,1,0,0,0,2456,555,1,0,0,0,2457,2455,1,0,0,0,2458,2463,3,876,
        438,0,2459,2460,5,485,0,0,2460,2462,3,876,438,0,2461,2459,1,0,0,
        0,2462,2465,1,0,0,0,2463,2461,1,0,0,0,2463,2464,1,0,0,0,2464,557,
        1,0,0,0,2465,2463,1,0,0,0,2466,2469,5,314,0,0,2467,2470,3,874,437,
        0,2468,2470,3,10,5,0,2469,2467,1,0,0,0,2469,2468,1,0,0,0,2470,559,
        1,0,0,0,2471,2474,5,315,0,0,2472,2475,3,874,437,0,2473,2475,3,10,
        5,0,2474,2472,1,0,0,0,2474,2473,1,0,0,0,2475,561,1,0,0,0,2476,2479,
        5,316,0,0,2477,2480,3,874,437,0,2478,2480,3,10,5,0,2479,2477,1,0,
        0,0,2479,2478,1,0,0,0,2480,563,1,0,0,0,2481,2484,5,317,0,0,2482,
        2485,3,874,437,0,2483,2485,3,10,5,0,2484,2482,1,0,0,0,2484,2483,
        1,0,0,0,2485,565,1,0,0,0,2486,2489,5,318,0,0,2487,2490,3,874,437,
        0,2488,2490,3,10,5,0,2489,2487,1,0,0,0,2489,2488,1,0,0,0,2490,567,
        1,0,0,0,2491,2494,5,319,0,0,2492,2495,3,874,437,0,2493,2495,3,10,
        5,0,2494,2492,1,0,0,0,2494,2493,1,0,0,0,2495,569,1,0,0,0,2496,2499,
        5,299,0,0,2497,2500,3,874,437,0,2498,2500,3,10,5,0,2499,2497,1,0,
        0,0,2499,2498,1,0,0,0,2500,571,1,0,0,0,2501,2509,3,574,287,0,2502,
        2509,3,580,290,0,2503,2509,3,576,288,0,2504,2509,3,578,289,0,2505,
        2509,3,582,291,0,2506,2509,3,584,292,0,2507,2509,3,586,293,0,2508,
        2501,1,0,0,0,2508,2502,1,0,0,0,2508,2503,1,0,0,0,2508,2504,1,0,0,
        0,2508,2505,1,0,0,0,2508,2506,1,0,0,0,2508,2507,1,0,0,0,2509,573,
        1,0,0,0,2510,2511,7,6,0,0,2511,575,1,0,0,0,2512,2513,5,157,0,0,2513,
        577,1,0,0,0,2514,2515,5,160,0,0,2515,579,1,0,0,0,2516,2517,5,328,
        0,0,2517,581,1,0,0,0,2518,2519,5,158,0,0,2519,583,1,0,0,0,2520,2521,
        5,159,0,0,2521,585,1,0,0,0,2522,2523,7,7,0,0,2523,587,1,0,0,0,2524,
        2532,3,590,295,0,2525,2532,3,592,296,0,2526,2532,3,594,297,0,2527,
        2532,3,596,298,0,2528,2532,3,598,299,0,2529,2532,3,600,300,0,2530,
        2532,3,602,301,0,2531,2524,1,0,0,0,2531,2525,1,0,0,0,2531,2526,1,
        0,0,0,2531,2527,1,0,0,0,2531,2528,1,0,0,0,2531,2529,1,0,0,0,2531,
        2530,1,0,0,0,2532,589,1,0,0,0,2533,2534,7,8,0,0,2534,591,1,0,0,0,
        2535,2536,7,9,0,0,2536,593,1,0,0,0,2537,2538,7,10,0,0,2538,595,1,
        0,0,0,2539,2540,7,11,0,0,2540,597,1,0,0,0,2541,2542,7,12,0,0,2542,
        599,1,0,0,0,2543,2544,7,13,0,0,2544,601,1,0,0,0,2545,2546,7,14,0,
        0,2546,603,1,0,0,0,2547,2548,7,15,0,0,2548,605,1,0,0,0,2549,2550,
        7,16,0,0,2550,607,1,0,0,0,2551,2552,7,17,0,0,2552,609,1,0,0,0,2553,
        2554,7,18,0,0,2554,611,1,0,0,0,2555,2556,5,377,0,0,2556,613,1,0,
        0,0,2557,2558,5,378,0,0,2558,615,1,0,0,0,2559,2560,7,19,0,0,2560,
        617,1,0,0,0,2561,2562,7,20,0,0,2562,619,1,0,0,0,2563,2564,7,21,0,
        0,2564,621,1,0,0,0,2565,2566,7,22,0,0,2566,623,1,0,0,0,2567,2568,
        7,23,0,0,2568,625,1,0,0,0,2569,2573,3,628,314,0,2570,2573,3,630,
        315,0,2571,2573,3,632,316,0,2572,2569,1,0,0,0,2572,2570,1,0,0,0,
        2572,2571,1,0,0,0,2573,627,1,0,0,0,2574,2575,7,24,0,0,2575,629,1,
        0,0,0,2576,2577,5,389,0,0,2577,631,1,0,0,0,2578,2579,7,25,0,0,2579,
        633,1,0,0,0,2580,2596,3,572,286,0,2581,2596,3,590,295,0,2582,2596,
        3,592,296,0,2583,2596,3,594,297,0,2584,2596,3,596,298,0,2585,2596,
        3,598,299,0,2586,2596,3,600,300,0,2587,2596,3,602,301,0,2588,2596,
        3,604,302,0,2589,2596,3,606,303,0,2590,2596,3,608,304,0,2591,2596,
        3,610,305,0,2592,2596,3,616,308,0,2593,2596,3,618,309,0,2594,2596,
        3,626,313,0,2595,2580,1,0,0,0,2595,2581,1,0,0,0,2595,2582,1,0,0,
        0,2595,2583,1,0,0,0,2595,2584,1,0,0,0,2595,2585,1,0,0,0,2595,2586,
        1,0,0,0,2595,2587,1,0,0,0,2595,2588,1,0,0,0,2595,2589,1,0,0,0,2595,
        2590,1,0,0,0,2595,2591,1,0,0,0,2595,2592,1,0,0,0,2595,2593,1,0,0,
        0,2595,2594,1,0,0,0,2596,635,1,0,0,0,2597,2604,3,638,319,0,2598,
        2600,5,473,0,0,2599,2598,1,0,0,0,2599,2600,1,0,0,0,2600,2601,1,0,
        0,0,2601,2603,3,638,319,0,2602,2599,1,0,0,0,2603,2606,1,0,0,0,2604,
        2602,1,0,0,0,2604,2605,1,0,0,0,2605,637,1,0,0,0,2606,2604,1,0,0,
        0,2607,2610,3,640,320,0,2608,2610,3,642,321,0,2609,2607,1,0,0,0,
        2609,2608,1,0,0,0,2610,639,1,0,0,0,2611,2615,5,416,0,0,2612,2614,
        3,644,322,0,2613,2612,1,0,0,0,2614,2617,1,0,0,0,2615,2613,1,0,0,
        0,2615,2616,1,0,0,0,2616,641,1,0,0,0,2617,2615,1,0,0,0,2618,2622,
        5,417,0,0,2619,2621,3,644,322,0,2620,2619,1,0,0,0,2621,2624,1,0,
        0,0,2622,2620,1,0,0,0,2622,2623,1,0,0,0,2623,643,1,0,0,0,2624,2622,
        1,0,0,0,2625,2630,3,646,323,0,2626,2627,5,473,0,0,2627,2629,3,646,
        323,0,2628,2626,1,0,0,0,2629,2632,1,0,0,0,2630,2628,1,0,0,0,2630,
        2631,1,0,0,0,2631,645,1,0,0,0,2632,2630,1,0,0,0,2633,2634,5,415,
        0,0,2634,2636,5,389,0,0,2635,2633,1,0,0,0,2635,2636,1,0,0,0,2636,
        2637,1,0,0,0,2637,2638,3,876,438,0,2638,647,1,0,0,0,2639,2640,5,
        349,0,0,2640,2641,3,650,325,0,2641,2642,5,351,0,0,2642,649,1,0,0,
        0,2643,2648,3,652,326,0,2644,2645,5,473,0,0,2645,2647,3,652,326,
        0,2646,2644,1,0,0,0,2647,2650,1,0,0,0,2648,2646,1,0,0,0,2648,2649,
        1,0,0,0,2649,651,1,0,0,0,2650,2648,1,0,0,0,2651,2654,3,656,328,0,
        2652,2653,7,5,0,0,2653,2655,3,656,328,0,2654,2652,1,0,0,0,2654,2655,
        1,0,0,0,2655,653,1,0,0,0,2656,2661,3,656,328,0,2657,2658,5,473,0,
        0,2658,2660,3,656,328,0,2659,2657,1,0,0,0,2660,2663,1,0,0,0,2661,
        2659,1,0,0,0,2661,2662,1,0,0,0,2662,655,1,0,0,0,2663,2661,1,0,0,
        0,2664,2665,6,328,-1,0,2665,2666,3,658,329,0,2666,2667,3,656,328,
        9,2667,2672,1,0,0,0,2668,2672,3,662,331,0,2669,2672,3,664,332,0,
        2670,2672,3,38,19,0,2671,2664,1,0,0,0,2671,2668,1,0,0,0,2671,2669,
        1,0,0,0,2671,2670,1,0,0,0,2672,2688,1,0,0,0,2673,2674,10,6,0,0,2674,
        2675,5,150,0,0,2675,2687,3,656,328,7,2676,2677,10,5,0,0,2677,2678,
        5,153,0,0,2678,2687,3,656,328,6,2679,2680,10,4,0,0,2680,2681,5,155,
        0,0,2681,2687,3,656,328,5,2682,2683,10,8,0,0,2683,2687,3,660,330,
        0,2684,2685,10,7,0,0,2685,2687,3,648,324,0,2686,2673,1,0,0,0,2686,
        2676,1,0,0,0,2686,2679,1,0,0,0,2686,2682,1,0,0,0,2686,2684,1,0,0,
        0,2687,2690,1,0,0,0,2688,2686,1,0,0,0,2688,2689,1,0,0,0,2689,657,
        1,0,0,0,2690,2688,1,0,0,0,2691,2692,5,468,0,0,2692,2693,3,874,437,
        0,2693,2694,5,469,0,0,2694,659,1,0,0,0,2695,2710,5,365,0,0,2696,
        2710,5,367,0,0,2697,2698,5,367,0,0,2698,2710,5,367,0,0,2699,2700,
        5,485,0,0,2700,2710,5,351,0,0,2701,2702,5,365,0,0,2702,2710,5,367,
        0,0,2703,2704,5,365,0,0,2704,2705,5,367,0,0,2705,2710,5,367,0,0,
        2706,2707,5,365,0,0,2707,2708,5,485,0,0,2708,2710,5,351,0,0,2709,
        2695,1,0,0,0,2709,2696,1,0,0,0,2709,2697,1,0,0,0,2709,2699,1,0,0,
        0,2709,2701,1,0,0,0,2709,2703,1,0,0,0,2709,2706,1,0,0,0,2710,661,
        1,0,0,0,2711,2716,3,666,333,0,2712,2716,3,690,345,0,2713,2716,3,
        698,349,0,2714,2716,3,700,350,0,2715,2711,1,0,0,0,2715,2712,1,0,
        0,0,2715,2713,1,0,0,0,2715,2714,1,0,0,0,2716,663,1,0,0,0,2717,2726,
        3,702,351,0,2718,2726,3,704,352,0,2719,2726,3,706,353,0,2720,2726,
        3,708,354,0,2721,2726,3,712,356,0,2722,2726,3,710,355,0,2723,2726,
        3,714,357,0,2724,2726,3,716,358,0,2725,2717,1,0,0,0,2725,2718,1,
        0,0,0,2725,2719,1,0,0,0,2725,2720,1,0,0,0,2725,2721,1,0,0,0,2725,
        2722,1,0,0,0,2725,2723,1,0,0,0,2725,2724,1,0,0,0,2726,665,1,0,0,
        0,2727,2732,3,668,334,0,2728,2732,3,670,335,0,2729,2732,3,686,343,
        0,2730,2732,3,688,344,0,2731,2727,1,0,0,0,2731,2728,1,0,0,0,2731,
        2729,1,0,0,0,2731,2730,1,0,0,0,2732,667,1,0,0,0,2733,2734,7,26,0,
        0,2734,669,1,0,0,0,2735,2743,3,672,336,0,2736,2743,3,674,337,0,2737,
        2743,3,678,339,0,2738,2743,3,676,338,0,2739,2743,3,680,340,0,2740,
        2743,3,682,341,0,2741,2743,3,684,342,0,2742,2735,1,0,0,0,2742,2736,
        1,0,0,0,2742,2737,1,0,0,0,2742,2738,1,0,0,0,2742,2739,1,0,0,0,2742,
        2740,1,0,0,0,2742,2741,1,0,0,0,2743,671,1,0,0,0,2744,2745,7,27,0,
        0,2745,673,1,0,0,0,2746,2747,7,28,0,0,2747,675,1,0,0,0,2748,2749,
        7,29,0,0,2749,677,1,0,0,0,2750,2751,7,30,0,0,2751,679,1,0,0,0,2752,
        2753,7,31,0,0,2753,681,1,0,0,0,2754,2755,7,32,0,0,2755,683,1,0,0,
        0,2756,2757,7,33,0,0,2757,685,1,0,0,0,2758,2759,7,34,0,0,2759,687,
        1,0,0,0,2760,2761,7,35,0,0,2761,689,1,0,0,0,2762,2766,3,692,346,
        0,2763,2766,3,694,347,0,2764,2766,3,696,348,0,2765,2762,1,0,0,0,
        2765,2763,1,0,0,0,2765,2764,1,0,0,0,2766,691,1,0,0,0,2767,2768,7,
        36,0,0,2768,693,1,0,0,0,2769,2770,7,37,0,0,2770,695,1,0,0,0,2771,
        2772,7,38,0,0,2772,697,1,0,0,0,2773,2774,7,39,0,0,2774,699,1,0,0,
        0,2775,2776,7,40,0,0,2776,701,1,0,0,0,2777,2778,5,23,0,0,2778,2779,
        3,718,359,0,2779,2780,3,176,88,0,2780,703,1,0,0,0,2781,2782,5,24,
        0,0,2782,2783,3,718,359,0,2783,2784,3,176,88,0,2784,705,1,0,0,0,
        2785,2786,5,25,0,0,2786,2787,3,718,359,0,2787,707,1,0,0,0,2788,2789,
        5,21,0,0,2789,2790,3,724,362,0,2790,709,1,0,0,0,2791,2792,5,26,0,
        0,2792,2793,3,718,359,0,2793,2794,3,176,88,0,2794,711,1,0,0,0,2795,
        2796,5,27,0,0,2796,2797,3,720,360,0,2797,2798,3,176,88,0,2798,713,
        1,0,0,0,2799,2800,5,39,0,0,2800,715,1,0,0,0,2801,2802,5,40,0,0,2802,
        2803,3,718,359,0,2803,717,1,0,0,0,2804,2806,5,466,0,0,2805,2807,
        3,722,361,0,2806,2805,1,0,0,0,2806,2807,1,0,0,0,2807,2808,1,0,0,
        0,2808,2809,5,467,0,0,2809,719,1,0,0,0,2810,2812,5,468,0,0,2811,
        2813,3,722,361,0,2812,2811,1,0,0,0,2812,2813,1,0,0,0,2813,2814,1,
        0,0,0,2814,2815,5,469,0,0,2815,721,1,0,0,0,2816,2821,3,724,362,0,
        2817,2818,5,473,0,0,2818,2820,3,724,362,0,2819,2817,1,0,0,0,2820,
        2823,1,0,0,0,2821,2819,1,0,0,0,2821,2822,1,0,0,0,2822,723,1,0,0,
        0,2823,2821,1,0,0,0,2824,2826,3,174,87,0,2825,2824,1,0,0,0,2825,
        2826,1,0,0,0,2826,2827,1,0,0,0,2827,2828,3,656,328,0,2828,725,1,
        0,0,0,2829,2834,3,728,364,0,2830,2834,3,740,370,0,2831,2834,3,750,
        375,0,2832,2834,3,832,416,0,2833,2829,1,0,0,0,2833,2830,1,0,0,0,
        2833,2831,1,0,0,0,2833,2832,1,0,0,0,2834,727,1,0,0,0,2835,2841,3,
        730,365,0,2836,2841,3,732,366,0,2837,2841,3,734,367,0,2838,2841,
        3,736,368,0,2839,2841,3,738,369,0,2840,2835,1,0,0,0,2840,2836,1,
        0,0,0,2840,2837,1,0,0,0,2840,2838,1,0,0,0,2840,2839,1,0,0,0,2841,
        729,1,0,0,0,2842,2843,7,41,0,0,2843,731,1,0,0,0,2844,2860,5,418,
        0,0,2845,2860,5,419,0,0,2846,2860,5,420,0,0,2847,2860,5,421,0,0,
        2848,2860,5,422,0,0,2849,2860,5,423,0,0,2850,2860,5,425,0,0,2851,
        2852,5,256,0,0,2852,2860,3,862,431,0,2853,2860,5,257,0,0,2854,2860,
        5,258,0,0,2855,2860,5,259,0,0,2856,2860,5,260,0,0,2857,2860,5,261,
        0,0,2858,2860,5,262,0,0,2859,2844,1,0,0,0,2859,2845,1,0,0,0,2859,
        2846,1,0,0,0,2859,2847,1,0,0,0,2859,2848,1,0,0,0,2859,2849,1,0,0,
        0,2859,2850,1,0,0,0,2859,2851,1,0,0,0,2859,2853,1,0,0,0,2859,2854,
        1,0,0,0,2859,2855,1,0,0,0,2859,2856,1,0,0,0,2859,2857,1,0,0,0,2859,
        2858,1,0,0,0,2860,733,1,0,0,0,2861,2862,7,42,0,0,2862,735,1,0,0,
        0,2863,2895,5,437,0,0,2864,2866,5,263,0,0,2865,2867,3,862,431,0,
        2866,2865,1,0,0,0,2866,2867,1,0,0,0,2867,2895,1,0,0,0,2868,2870,
        5,264,0,0,2869,2871,3,862,431,0,2870,2869,1,0,0,0,2870,2871,1,0,
        0,0,2871,2895,1,0,0,0,2872,2874,5,265,0,0,2873,2875,3,862,431,0,
        2874,2873,1,0,0,0,2874,2875,1,0,0,0,2875,2895,1,0,0,0,2876,2878,
        5,266,0,0,2877,2879,3,862,431,0,2878,2877,1,0,0,0,2878,2879,1,0,
        0,0,2879,2895,1,0,0,0,2880,2882,5,267,0,0,2881,2883,3,862,431,0,
        2882,2881,1,0,0,0,2882,2883,1,0,0,0,2883,2895,1,0,0,0,2884,2886,
        5,268,0,0,2885,2887,3,862,431,0,2886,2885,1,0,0,0,2886,2887,1,0,
        0,0,2887,2895,1,0,0,0,2888,2895,5,269,0,0,2889,2895,5,270,0,0,2890,
        2895,5,271,0,0,2891,2895,5,272,0,0,2892,2895,5,273,0,0,2893,2895,
        5,274,0,0,2894,2863,1,0,0,0,2894,2864,1,0,0,0,2894,2868,1,0,0,0,
        2894,2872,1,0,0,0,2894,2876,1,0,0,0,2894,2880,1,0,0,0,2894,2884,
        1,0,0,0,2894,2888,1,0,0,0,2894,2889,1,0,0,0,2894,2890,1,0,0,0,2894,
        2891,1,0,0,0,2894,2892,1,0,0,0,2894,2893,1,0,0,0,2895,737,1,0,0,
        0,2896,2912,5,427,0,0,2897,2912,5,428,0,0,2898,2899,5,275,0,0,2899,
        2912,3,862,431,0,2900,2901,5,277,0,0,2901,2912,3,862,431,0,2902,
        2903,5,278,0,0,2903,2912,3,862,431,0,2904,2905,5,279,0,0,2905,2912,
        3,862,431,0,2906,2907,5,280,0,0,2907,2912,3,862,431,0,2908,2909,
        5,281,0,0,2909,2912,3,862,431,0,2910,2912,5,282,0,0,2911,2896,1,
        0,0,0,2911,2897,1,0,0,0,2911,2898,1,0,0,0,2911,2900,1,0,0,0,2911,
        2902,1,0,0,0,2911,2904,1,0,0,0,2911,2906,1,0,0,0,2911,2908,1,0,0,
        0,2911,2910,1,0,0,0,2912,739,1,0,0,0,2913,2918,3,742,371,0,2914,
        2918,3,744,372,0,2915,2918,3,746,373,0,2916,2918,3,748,374,0,2917,
        2913,1,0,0,0,2917,2914,1,0,0,0,2917,2915,1,0,0,0,2917,2916,1,0,0,
        0,2918,741,1,0,0,0,2919,2920,5,298,0,0,2920,2924,3,862,431,0,2921,
        2922,5,299,0,0,2922,2924,3,862,431,0,2923,2919,1,0,0,0,2923,2921,
        1,0,0,0,2924,743,1,0,0,0,2925,2926,5,301,0,0,2926,2929,3,862,431,
        0,2927,2929,5,302,0,0,2928,2925,1,0,0,0,2928,2927,1,0,0,0,2929,745,
        1,0,0,0,2930,2931,5,304,0,0,2931,2935,3,862,431,0,2932,2933,5,305,
        0,0,2933,2935,3,862,431,0,2934,2930,1,0,0,0,2934,2932,1,0,0,0,2935,
        747,1,0,0,0,2936,2937,5,307,0,0,2937,2940,3,862,431,0,2938,2940,
        5,308,0,0,2939,2936,1,0,0,0,2939,2938,1,0,0,0,2940,749,1,0,0,0,2941,
        2948,3,752,376,0,2942,2948,3,756,378,0,2943,2948,3,758,379,0,2944,
        2948,3,774,387,0,2945,2948,3,802,401,0,2946,2948,3,820,410,0,2947,
        2941,1,0,0,0,2947,2942,1,0,0,0,2947,2943,1,0,0,0,2947,2944,1,0,0,
        0,2947,2945,1,0,0,0,2947,2946,1,0,0,0,2948,751,1,0,0,0,2949,2963,
        5,431,0,0,2950,2963,5,432,0,0,2951,2963,5,429,0,0,2952,2963,5,430,
        0,0,2953,2963,5,433,0,0,2954,2963,5,434,0,0,2955,2963,5,435,0,0,
        2956,2963,5,436,0,0,2957,2963,5,437,0,0,2958,2963,5,426,0,0,2959,
        2960,5,284,0,0,2960,2963,3,862,431,0,2961,2963,5,283,0,0,2962,2949,
        1,0,0,0,2962,2950,1,0,0,0,2962,2951,1,0,0,0,2962,2952,1,0,0,0,2962,
        2953,1,0,0,0,2962,2954,1,0,0,0,2962,2955,1,0,0,0,2962,2956,1,0,0,
        0,2962,2957,1,0,0,0,2962,2958,1,0,0,0,2962,2959,1,0,0,0,2962,2961,
        1,0,0,0,2963,753,1,0,0,0,2964,2965,7,43,0,0,2965,755,1,0,0,0,2966,
        2967,5,439,0,0,2967,757,1,0,0,0,2968,2975,3,760,380,0,2969,2975,
        3,762,381,0,2970,2975,3,764,382,0,2971,2975,3,766,383,0,2972,2975,
        3,768,384,0,2973,2975,3,770,385,0,2974,2968,1,0,0,0,2974,2969,1,
        0,0,0,2974,2970,1,0,0,0,2974,2971,1,0,0,0,2974,2972,1,0,0,0,2974,
        2973,1,0,0,0,2975,759,1,0,0,0,2976,2977,3,728,364,0,2977,2978,3,
        620,310,0,2978,2979,3,728,364,0,2979,2987,1,0,0,0,2980,2981,3,728,
        364,0,2981,2982,3,622,311,0,2982,2987,1,0,0,0,2983,2984,3,624,312,
        0,2984,2985,3,728,364,0,2985,2987,1,0,0,0,2986,2976,1,0,0,0,2986,
        2980,1,0,0,0,2986,2983,1,0,0,0,2987,761,1,0,0,0,2988,2989,3,728,
        364,0,2989,2990,5,475,0,0,2990,2991,3,876,438,0,2991,763,1,0,0,0,
        2992,2993,5,466,0,0,2993,2995,3,874,437,0,2994,2996,5,473,0,0,2995,
        2994,1,0,0,0,2995,2996,1,0,0,0,2996,2997,1,0,0,0,2997,2998,5,467,
        0,0,2998,765,1,0,0,0,2999,3005,5,437,0,0,3000,3001,5,295,0,0,3001,
        3005,3,862,431,0,3002,3003,5,296,0,0,3003,3005,3,862,431,0,3004,
        2999,1,0,0,0,3004,3000,1,0,0,0,3004,3002,1,0,0,0,3005,767,1,0,0,
        0,3006,3007,5,293,0,0,3007,3011,3,862,431,0,3008,3009,5,294,0,0,
        3009,3011,3,862,431,0,3010,3006,1,0,0,0,3010,3008,1,0,0,0,3011,769,
        1,0,0,0,3012,3030,5,449,0,0,3013,3030,5,448,0,0,3014,3015,5,285,
        0,0,3015,3030,3,862,431,0,3016,3017,5,286,0,0,3017,3030,3,862,431,
        0,3018,3019,5,287,0,0,3019,3030,3,862,431,0,3020,3021,5,288,0,0,
        3021,3030,3,862,431,0,3022,3023,5,289,0,0,3023,3030,3,862,431,0,
        3024,3025,5,290,0,0,3025,3030,3,862,431,0,3026,3027,5,291,0,0,3027,
        3030,3,862,431,0,3028,3030,5,292,0,0,3029,3012,1,0,0,0,3029,3013,
        1,0,0,0,3029,3014,1,0,0,0,3029,3016,1,0,0,0,3029,3018,1,0,0,0,3029,
        3020,1,0,0,0,3029,3022,1,0,0,0,3029,3024,1,0,0,0,3029,3026,1,0,0,
        0,3029,3028,1,0,0,0,3030,771,1,0,0,0,3031,3036,3,770,385,0,3032,
        3033,5,473,0,0,3033,3035,3,770,385,0,3034,3032,1,0,0,0,3035,3038,
        1,0,0,0,3036,3034,1,0,0,0,3036,3037,1,0,0,0,3037,773,1,0,0,0,3038,
        3036,1,0,0,0,3039,3042,3,776,388,0,3040,3042,3,786,393,0,3041,3039,
        1,0,0,0,3041,3040,1,0,0,0,3042,775,1,0,0,0,3043,3046,3,778,389,0,
        3044,3046,3,784,392,0,3045,3043,1,0,0,0,3045,3044,1,0,0,0,3046,777,
        1,0,0,0,3047,3051,3,780,390,0,3048,3050,3,798,399,0,3049,3048,1,
        0,0,0,3050,3053,1,0,0,0,3051,3049,1,0,0,0,3051,3052,1,0,0,0,3052,
        3054,1,0,0,0,3053,3051,1,0,0,0,3054,3055,3,782,391,0,3055,779,1,
        0,0,0,3056,3057,5,349,0,0,3057,3061,3,792,396,0,3058,3060,3,794,
        397,0,3059,3058,1,0,0,0,3060,3063,1,0,0,0,3061,3059,1,0,0,0,3061,
        3062,1,0,0,0,3062,3064,1,0,0,0,3063,3061,1,0,0,0,3064,3065,5,351,
        0,0,3065,781,1,0,0,0,3066,3067,5,494,0,0,3067,3068,3,792,396,0,3068,
        3069,5,351,0,0,3069,783,1,0,0,0,3070,3071,5,349,0,0,3071,3075,3,
        792,396,0,3072,3074,3,794,397,0,3073,3072,1,0,0,0,3074,3077,1,0,
        0,0,3075,3073,1,0,0,0,3075,3076,1,0,0,0,3076,3078,1,0,0,0,3077,3075,
        1,0,0,0,3078,3079,5,495,0,0,3079,785,1,0,0,0,3080,3083,3,788,394,
        0,3081,3083,3,790,395,0,3082,3080,1,0,0,0,3082,3081,1,0,0,0,3083,
        787,1,0,0,0,3084,3088,5,496,0,0,3085,3087,3,798,399,0,3086,3085,
        1,0,0,0,3087,3090,1,0,0,0,3088,3086,1,0,0,0,3088,3089,1,0,0,0,3089,
        3091,1,0,0,0,3090,3088,1,0,0,0,3091,3092,5,497,0,0,3092,789,1,0,
        0,0,3093,3094,5,497,0,0,3094,791,1,0,0,0,3095,3098,5,415,0,0,3096,
        3098,3,38,19,0,3097,3095,1,0,0,0,3097,3096,1,0,0,0,3098,793,1,0,
        0,0,3099,3102,3,792,396,0,3100,3101,5,389,0,0,3101,3103,3,796,398,
        0,3102,3100,1,0,0,0,3102,3103,1,0,0,0,3103,795,1,0,0,0,3104,3107,
        3,726,363,0,3105,3107,3,800,400,0,3106,3104,1,0,0,0,3106,3105,1,
        0,0,0,3107,797,1,0,0,0,3108,3112,3,776,388,0,3109,3112,3,800,400,
        0,3110,3112,5,1,0,0,3111,3108,1,0,0,0,3111,3109,1,0,0,0,3111,3110,
        1,0,0,0,3112,799,1,0,0,0,3113,3114,5,470,0,0,3114,3115,3,876,438,
        0,3115,3116,5,471,0,0,3116,801,1,0,0,0,3117,3119,3,656,328,0,3118,
        3117,1,0,0,0,3118,3119,1,0,0,0,3119,3120,1,0,0,0,3120,3124,3,804,
        402,0,3121,3124,3,814,407,0,3122,3124,3,816,408,0,3123,3118,1,0,
        0,0,3123,3121,1,0,0,0,3123,3122,1,0,0,0,3124,803,1,0,0,0,3125,3126,
        5,468,0,0,3126,3139,5,469,0,0,3127,3132,5,468,0,0,3128,3130,3,806,
        403,0,3129,3131,5,473,0,0,3130,3129,1,0,0,0,3130,3131,1,0,0,0,3131,
        3133,1,0,0,0,3132,3128,1,0,0,0,3133,3134,1,0,0,0,3134,3132,1,0,0,
        0,3134,3135,1,0,0,0,3135,3136,1,0,0,0,3136,3137,5,469,0,0,3137,3139,
        1,0,0,0,3138,3125,1,0,0,0,3138,3127,1,0,0,0,3139,805,1,0,0,0,3140,
        3142,3,808,404,0,3141,3140,1,0,0,0,3142,3143,1,0,0,0,3143,3141,1,
        0,0,0,3143,3144,1,0,0,0,3144,807,1,0,0,0,3145,3146,3,810,405,0,3146,
        3147,5,475,0,0,3147,3149,1,0,0,0,3148,3145,1,0,0,0,3148,3149,1,0,
        0,0,3149,3150,1,0,0,0,3150,3151,3,812,406,0,3151,809,1,0,0,0,3152,
        3153,3,876,438,0,3153,811,1,0,0,0,3154,3155,3,876,438,0,3155,813,
        1,0,0,0,3156,3157,5,468,0,0,3157,3158,5,469,0,0,3158,3159,3,876,
        438,0,3159,815,1,0,0,0,3160,3161,5,468,0,0,3161,3163,3,874,437,0,
        3162,3164,3,818,409,0,3163,3162,1,0,0,0,3164,3165,1,0,0,0,3165,3163,
        1,0,0,0,3165,3166,1,0,0,0,3166,3167,1,0,0,0,3167,3168,5,469,0,0,
        3168,817,1,0,0,0,3169,3172,3,532,266,0,3170,3171,5,77,0,0,3171,3173,
        3,876,438,0,3172,3170,1,0,0,0,3172,3173,1,0,0,0,3173,819,1,0,0,0,
        3174,3176,3,656,328,0,3175,3174,1,0,0,0,3175,3176,1,0,0,0,3176,3177,
        1,0,0,0,3177,3178,3,822,411,0,3178,821,1,0,0,0,3179,3180,5,470,0,
        0,3180,3193,5,471,0,0,3181,3182,5,470,0,0,3182,3184,3,824,412,0,
        3183,3185,5,473,0,0,3184,3183,1,0,0,0,3184,3185,1,0,0,0,3185,3186,
        1,0,0,0,3186,3187,5,471,0,0,3187,3193,1,0,0,0,3188,3189,5,470,0,
        0,3189,3190,3,10,5,0,3190,3191,5,471,0,0,3191,3193,1,0,0,0,3192,
        3179,1,0,0,0,3192,3181,1,0,0,0,3192,3188,1,0,0,0,3193,823,1,0,0,
        0,3194,3199,3,826,413,0,3195,3196,5,473,0,0,3196,3198,3,826,413,
        0,3197,3195,1,0,0,0,3198,3201,1,0,0,0,3199,3197,1,0,0,0,3199,3200,
        1,0,0,0,3200,825,1,0,0,0,3201,3199,1,0,0,0,3202,3203,3,828,414,0,
        3203,3204,5,475,0,0,3204,3206,1,0,0,0,3205,3202,1,0,0,0,3205,3206,
        1,0,0,0,3206,3207,1,0,0,0,3207,3208,3,830,415,0,3208,827,1,0,0,0,
        3209,3210,3,46,23,0,3210,829,1,0,0,0,3211,3212,3,876,438,0,3212,
        831,1,0,0,0,3213,3217,3,834,417,0,3214,3217,3,836,418,0,3215,3217,
        3,838,419,0,3216,3213,1,0,0,0,3216,3214,1,0,0,0,3216,3215,1,0,0,
        0,3217,833,1,0,0,0,3218,3220,5,141,0,0,3219,3221,3,168,84,0,3220,
        3219,1,0,0,0,3220,3221,1,0,0,0,3221,3222,1,0,0,0,3222,3223,5,475,
        0,0,3223,3224,3,874,437,0,3224,835,1,0,0,0,3225,3226,5,487,0,0,3226,
        3227,3,388,194,0,3227,3228,5,467,0,0,3228,837,1,0,0,0,3229,3230,
        3,588,294,0,3230,3231,5,487,0,0,3231,3233,3,876,438,0,3232,3234,
        3,818,409,0,3233,3232,1,0,0,0,3234,3235,1,0,0,0,3235,3233,1,0,0,
        0,3235,3236,1,0,0,0,3236,3237,1,0,0,0,3237,3238,5,467,0,0,3238,839,
        1,0,0,0,3239,3242,3,842,421,0,3240,3242,3,844,422,0,3241,3239,1,
        0,0,0,3241,3240,1,0,0,0,3242,841,1,0,0,0,3243,3244,7,44,0,0,3244,
        843,1,0,0,0,3245,3246,7,45,0,0,3246,845,1,0,0,0,3247,3250,3,848,
        424,0,3248,3250,3,850,425,0,3249,3247,1,0,0,0,3249,3248,1,0,0,0,
        3250,847,1,0,0,0,3251,3252,7,46,0,0,3252,849,1,0,0,0,3253,3254,7,
        47,0,0,3254,851,1,0,0,0,3255,3260,3,854,427,0,3256,3257,5,473,0,
        0,3257,3259,3,854,427,0,3258,3256,1,0,0,0,3259,3262,1,0,0,0,3260,
        3258,1,0,0,0,3260,3261,1,0,0,0,3261,853,1,0,0,0,3262,3260,1,0,0,
        0,3263,3264,6,427,-1,0,3264,3275,3,856,428,0,3265,3275,3,860,430,
        0,3266,3275,3,862,431,0,3267,3268,3,572,286,0,3268,3269,3,854,427,
        4,3269,3275,1,0,0,0,3270,3271,3,858,429,0,3271,3272,3,854,427,2,
        3272,3275,1,0,0,0,3273,3275,3,872,436,0,3274,3263,1,0,0,0,3274,3265,
        1,0,0,0,3274,3266,1,0,0,0,3274,3267,1,0,0,0,3274,3270,1,0,0,0,3274,
        3273,1,0,0,0,3275,3291,1,0,0,0,3276,3277,10,6,0,0,3277,3278,5,472,
        0,0,3278,3290,3,854,427,7,3279,3280,10,7,0,0,3280,3281,5,468,0,0,
        3281,3282,3,864,432,0,3282,3283,5,469,0,0,3283,3290,1,0,0,0,3284,
        3285,10,5,0,0,3285,3290,3,160,80,0,3286,3287,10,3,0,0,3287,3288,
        5,474,0,0,3288,3290,3,870,435,0,3289,3276,1,0,0,0,3289,3279,1,0,
        0,0,3289,3284,1,0,0,0,3289,3286,1,0,0,0,3290,3293,1,0,0,0,3291,3289,
        1,0,0,0,3291,3292,1,0,0,0,3292,855,1,0,0,0,3293,3291,1,0,0,0,3294,
        3300,3,840,420,0,3295,3300,3,726,363,0,3296,3300,5,415,0,0,3297,
        3300,3,38,19,0,3298,3300,3,656,328,0,3299,3294,1,0,0,0,3299,3295,
        1,0,0,0,3299,3296,1,0,0,0,3299,3297,1,0,0,0,3299,3298,1,0,0,0,3300,
        857,1,0,0,0,3301,3304,3,846,423,0,3302,3304,3,38,19,0,3303,3301,
        1,0,0,0,3303,3302,1,0,0,0,3304,859,1,0,0,0,3305,3306,5,466,0,0,3306,
        3307,3,384,192,0,3307,3308,5,467,0,0,3308,861,1,0,0,0,3309,3310,
        5,466,0,0,3310,3311,3,876,438,0,3311,3312,5,467,0,0,3312,863,1,0,
        0,0,3313,3317,3,874,437,0,3314,3317,3,866,433,0,3315,3317,3,868,
        434,0,3316,3313,1,0,0,0,3316,3314,1,0,0,0,3316,3315,1,0,0,0,3317,
        865,1,0,0,0,3318,3319,6,433,-1,0,3319,3320,3,876,438,0,3320,3321,
        3,620,310,0,3321,3322,3,876,438,0,3322,3330,1,0,0,0,3323,3324,3,
        876,438,0,3324,3325,3,622,311,0,3325,3330,1,0,0,0,3326,3327,3,624,
        312,0,3327,3328,3,876,438,0,3328,3330,1,0,0,0,3329,3318,1,0,0,0,
        3329,3323,1,0,0,0,3329,3326,1,0,0,0,3330,3336,1,0,0,0,3331,3332,
        10,1,0,0,3332,3333,5,370,0,0,3333,3335,3,876,438,0,3334,3331,1,0,
        0,0,3335,3338,1,0,0,0,3336,3334,1,0,0,0,3336,3337,1,0,0,0,3337,867,
        1,0,0,0,3338,3336,1,0,0,0,3339,3340,6,434,-1,0,3340,3341,3,876,438,
        0,3341,3342,5,475,0,0,3342,3343,3,876,438,0,3343,3350,1,0,0,0,3344,
        3345,5,475,0,0,3345,3350,3,876,438,0,3346,3347,3,876,438,0,3347,
        3348,5,475,0,0,3348,3350,1,0,0,0,3349,3339,1,0,0,0,3349,3344,1,0,
        0,0,3349,3346,1,0,0,0,3350,3356,1,0,0,0,3351,3352,10,1,0,0,3352,
        3353,5,475,0,0,3353,3355,3,876,438,0,3354,3351,1,0,0,0,3355,3358,
        1,0,0,0,3356,3354,1,0,0,0,3356,3357,1,0,0,0,3357,869,1,0,0,0,3358,
        3356,1,0,0,0,3359,3363,3,656,328,0,3360,3363,5,416,0,0,3361,3363,
        3,754,377,0,3362,3359,1,0,0,0,3362,3360,1,0,0,0,3362,3361,1,0,0,
        0,3363,871,1,0,0,0,3364,3366,3,752,376,0,3365,3364,1,0,0,0,3366,
        3367,1,0,0,0,3367,3365,1,0,0,0,3367,3368,1,0,0,0,3368,873,1,0,0,
        0,3369,3374,3,876,438,0,3370,3371,5,473,0,0,3371,3373,3,876,438,
        0,3372,3370,1,0,0,0,3373,3376,1,0,0,0,3374,3372,1,0,0,0,3374,3375,
        1,0,0,0,3375,875,1,0,0,0,3376,3374,1,0,0,0,3377,3378,6,438,-1,0,
        3378,3408,3,854,427,0,3379,3408,3,878,439,0,3380,3408,3,884,442,
        0,3381,3408,3,888,444,0,3382,3408,3,890,445,0,3383,3386,3,854,427,
        0,3384,3385,5,375,0,0,3385,3387,3,858,429,0,3386,3384,1,0,0,0,3387,
        3388,1,0,0,0,3388,3386,1,0,0,0,3388,3389,1,0,0,0,3389,3391,1,0,0,
        0,3390,3392,3,876,438,0,3391,3390,1,0,0,0,3391,3392,1,0,0,0,3392,
        3408,1,0,0,0,3393,3398,3,858,429,0,3394,3395,5,375,0,0,3395,3397,
        3,858,429,0,3396,3394,1,0,0,0,3397,3400,1,0,0,0,3398,3396,1,0,0,
        0,3398,3399,1,0,0,0,3399,3401,1,0,0,0,3400,3398,1,0,0,0,3401,3402,
        3,874,437,0,3402,3408,1,0,0,0,3403,3404,3,854,427,0,3404,3405,3,
        160,80,0,3405,3406,3,832,416,0,3406,3408,1,0,0,0,3407,3377,1,0,0,
        0,3407,3379,1,0,0,0,3407,3380,1,0,0,0,3407,3381,1,0,0,0,3407,3382,
        1,0,0,0,3407,3383,1,0,0,0,3407,3393,1,0,0,0,3407,3403,1,0,0,0,3408,
        3474,1,0,0,0,3409,3410,10,22,0,0,3410,3411,3,590,295,0,3411,3412,
        3,876,438,23,3412,3473,1,0,0,0,3413,3414,10,21,0,0,3414,3415,3,592,
        296,0,3415,3416,3,876,438,22,3416,3473,1,0,0,0,3417,3418,10,20,0,
        0,3418,3419,3,596,298,0,3419,3420,3,876,438,21,3420,3473,1,0,0,0,
        3421,3422,10,19,0,0,3422,3423,3,594,297,0,3423,3424,3,876,438,20,
        3424,3473,1,0,0,0,3425,3426,10,18,0,0,3426,3427,3,604,302,0,3427,
        3428,3,876,438,19,3428,3473,1,0,0,0,3429,3430,10,17,0,0,3430,3431,
        3,606,303,0,3431,3432,3,876,438,18,3432,3473,1,0,0,0,3433,3434,10,
        16,0,0,3434,3435,3,608,304,0,3435,3436,3,876,438,17,3436,3473,1,
        0,0,0,3437,3438,10,15,0,0,3438,3439,3,610,305,0,3439,3440,3,876,
        438,16,3440,3473,1,0,0,0,3441,3442,10,14,0,0,3442,3443,3,598,299,
        0,3443,3444,3,876,438,15,3444,3473,1,0,0,0,3445,3446,10,13,0,0,3446,
        3447,3,600,300,0,3447,3448,3,876,438,14,3448,3473,1,0,0,0,3449,3450,
        10,12,0,0,3450,3451,3,602,301,0,3451,3452,3,876,438,13,3452,3473,
        1,0,0,0,3453,3454,10,11,0,0,3454,3455,3,612,306,0,3455,3456,3,876,
        438,12,3456,3473,1,0,0,0,3457,3458,10,10,0,0,3458,3459,3,614,307,
        0,3459,3460,3,876,438,11,3460,3473,1,0,0,0,3461,3462,10,8,0,0,3462,
        3463,5,77,0,0,3463,3464,3,876,438,0,3464,3465,5,80,0,0,3465,3466,
        3,876,438,9,3466,3473,1,0,0,0,3467,3468,10,9,0,0,3468,3470,3,616,
        308,0,3469,3471,3,876,438,0,3470,3469,1,0,0,0,3470,3471,1,0,0,0,
        3471,3473,1,0,0,0,3472,3409,1,0,0,0,3472,3413,1,0,0,0,3472,3417,
        1,0,0,0,3472,3421,1,0,0,0,3472,3425,1,0,0,0,3472,3429,1,0,0,0,3472,
        3433,1,0,0,0,3472,3437,1,0,0,0,3472,3441,1,0,0,0,3472,3445,1,0,0,
        0,3472,3449,1,0,0,0,3472,3453,1,0,0,0,3472,3457,1,0,0,0,3472,3461,
        1,0,0,0,3472,3467,1,0,0,0,3473,3476,1,0,0,0,3474,3472,1,0,0,0,3474,
        3475,1,0,0,0,3475,877,1,0,0,0,3476,3474,1,0,0,0,3477,3479,3,880,
        440,0,3478,3477,1,0,0,0,3479,3480,1,0,0,0,3480,3478,1,0,0,0,3480,
        3481,1,0,0,0,3481,3483,1,0,0,0,3482,3484,3,882,441,0,3483,3482,1,
        0,0,0,3483,3484,1,0,0,0,3484,879,1,0,0,0,3485,3486,5,485,0,0,3486,
        3487,3,876,438,0,3487,3488,5,376,0,0,3488,3489,3,876,438,0,3489,
        881,1,0,0,0,3490,3491,5,485,0,0,3491,3492,3,876,438,0,3492,883,1,
        0,0,0,3493,3495,3,886,443,0,3494,3493,1,0,0,0,3495,3496,1,0,0,0,
        3496,3494,1,0,0,0,3496,3497,1,0,0,0,3497,885,1,0,0,0,3498,3502,3,
        38,19,0,3499,3501,3,876,438,0,3500,3499,1,0,0,0,3501,3504,1,0,0,
        0,3502,3500,1,0,0,0,3502,3503,1,0,0,0,3503,887,1,0,0,0,3504,3502,
        1,0,0,0,3505,3506,3,770,385,0,3506,3507,5,470,0,0,3507,3508,3,388,
        194,0,3508,3509,5,471,0,0,3509,889,1,0,0,0,3510,3511,3,854,427,0,
        3511,3512,3,626,313,0,3512,3513,3,876,438,0,3513,891,1,0,0,0,331,
        902,909,918,926,943,948,955,960,969,985,989,994,1003,1007,1010,1014,
        1021,1029,1037,1045,1053,1061,1069,1074,1078,1088,1093,1105,1110,
        1114,1121,1126,1138,1150,1158,1170,1177,1186,1201,1212,1224,1230,
        1239,1248,1255,1260,1264,1269,1273,1279,1291,1308,1312,1321,1326,
        1332,1341,1345,1348,1352,1355,1359,1371,1377,1392,1395,1407,1426,
        1433,1445,1450,1458,1468,1480,1486,1499,1512,1524,1530,1536,1543,
        1556,1568,1574,1580,1587,1601,1612,1615,1624,1627,1635,1638,1647,
        1650,1654,1657,1661,1670,1673,1677,1686,1689,1692,1700,1715,1721,
        1725,1729,1736,1744,1750,1765,1772,1776,1780,1789,1800,1803,1814,
        1825,1828,1831,1837,1847,1852,1856,1864,1871,1874,1887,1893,1901,
        1904,1913,1916,1920,1928,1932,1935,1938,1944,1947,1950,1964,1976,
        1984,1993,2008,2010,2022,2033,2047,2054,2057,2061,2064,2068,2072,
        2087,2092,2097,2102,2107,2114,2118,2132,2143,2152,2158,2164,2172,
        2176,2195,2198,2202,2213,2219,2224,2232,2235,2251,2255,2262,2265,
        2268,2274,2277,2285,2288,2299,2303,2310,2326,2343,2347,2350,2354,
        2367,2371,2384,2389,2393,2397,2401,2405,2409,2413,2417,2421,2425,
        2429,2432,2437,2442,2455,2463,2469,2474,2479,2484,2489,2494,2499,
        2508,2531,2572,2595,2599,2604,2609,2615,2622,2630,2635,2648,2654,
        2661,2671,2686,2688,2709,2715,2725,2731,2742,2765,2806,2812,2821,
        2825,2833,2840,2859,2866,2870,2874,2878,2882,2886,2894,2911,2917,
        2923,2928,2934,2939,2947,2962,2974,2986,2995,3004,3010,3029,3036,
        3041,3045,3051,3061,3075,3082,3088,3097,3102,3106,3111,3118,3123,
        3130,3134,3138,3143,3148,3165,3172,3175,3184,3192,3199,3205,3216,
        3220,3235,3241,3249,3260,3274,3289,3291,3299,3303,3316,3329,3336,
        3349,3356,3362,3367,3374,3388,3391,3398,3407,3470,3472,3474,3480,
        3483,3496,3502
    ]

class NeoBasicParser ( Parser ):

    grammarFileName = "NeoBasicParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "'>>>>'", "'<<<<'", "'module'", 
                     "'applet'", "'notabene'", "'define'", "'undef'", "'use'", 
                     "'as'", "'of'", "'include'", "'interface'", "'extern'", 
                     "'rproc'", "'foreign'", "'const'", "'ival'", "'var'", 
                     "'type'", "'fact'", "'enum'", "'func'", "'feed'", "'sub'", 
                     "'operator'", "'event'", "'struct'", "'proto'", "'trait'", 
                     "'class'", "'object'", "'extends'", "'implements'", 
                     "'mixes'", "'construct'", "'destruct'", "'property'", 
                     "'get'", "'set'", "'raises'", "'nopanic'", "'public'", 
                     "'protected'", "'private'", "'comptime'", "'inline'", 
                     "'curry'", "'static'", "'linear'", "'shared'", "'volatile'", 
                     "'local'", "'atomic'", "'mutable'", "'transient'", 
                     "'synchro'", "'dim'", "'method'", "'override'", "'final'", 
                     "'off'", "'async'", "'unique'", "'abstract'", "'sealed'", 
                     "'singleton'", "'record'", "'dynamic'", "'callback'", 
                     "'monad'", "'prefix'", "'infix'", "'postfix'", "'explicit'", 
                     "'delete'", "'if'", "'then'", "'elif'", "'else'", "'match'", 
                     "'case'", "'fallthrough'", "'try'", "'catch'", "'otherwise'", 
                     "'unless'", "'till'", "'defer'", "'with'", "'do'", 
                     "'loop'", "'for'", "'each'", "'step'", "'while'", "'until'", 
                     "'upto'", "'next'", "'redo'", "'continue'", "'break'", 
                     "'return'", "'yield'", "'raise'", "'panic'", "'go'", 
                     "'into'", "'gosub'", "'fork'", "'await'", "'switch'", 
                     "'when'", "'default'", "'resume'", "'begin'", "'end'", 
                     "'at'", "'scan'", "'echo'", "'alert'", "'entry'", "'play'", 
                     "'since'", "'timely'", "'cancel'", "'this'", "'iota'", 
                     "'nth'", "'it'", "'self'", "'super'", "'parent'", "'all'", 
                     "'any'", "'lot'", "'nil'", "'one'", "'two'", "'let'", 
                     "'lambda'", "'typeof'", "'sizeof'", "'instanceof'", 
                     "'ancestorof'", "'is'", "'in'", "'between'", "'like'", 
                     "'and'", "'andn'", "'nand'", "'or'", "'nor'", "'xor'", 
                     "'nxor'", "'not'", "'new'", "'nab'", "'del'", "'union'", 
                     "'unite'", "'inter'", "'minus'", "'atom'", "'auto'", 
                     "'span'", "'view'", "'void'", "'bool8'", "'bool16'", 
                     "'bool32'", "'bool64'", "'bool128'", "'bool'", "'byte'", 
                     "'nat8'", "'nat16'", "'nat32'", "'nat64'", "'nat128'", 
                     "'nat'", "'bignat'", "'int8'", "'int16'", "'int32'", 
                     "'int64'", "'int128'", "'int'", "'bigint'", "'real8'", 
                     "'real16'", "'real32'", "'real64'", "'real128'", "'real'", 
                     "'bigreal'", "'decimal8'", "'decimal16'", "'decimal32'", 
                     "'decimal64'", "'decimal128'", "'decimal'", "'money'", 
                     "'ratio8'", "'ratio16'", "'ratio32'", "'ratio64'", 
                     "'ratio128'", "'ratio'", "'complex32'", "'complex64'", 
                     "'complex128'", "'complex'", "'quatern32'", "'quatern64'", 
                     "'quatern128'", "'quatern'", "'date'", "'elapse'", 
                     "'ascii'", "'char8'", "'char16'", "'char32'", "'char'", 
                     "'wchar'", "'ansi'", "'str8'", "'str16'", "'str32'", 
                     "'str'", "'cstr'", "'wstr'", "'regex'", "'binary'", 
                     "'inet'", "'path'", "'uri'", "'range'", "'pair'", "'tuple'", 
                     "'Array'", "'List'", "'Map'", "'Channel'", "'Vector'", 
                     "'Matrix'", "'Set'", "'Queue'", "'Deque'", "'Xml'", 
                     "'Table'", "'Memo'", "'True'", "'False'", "'Nonzero'", 
                     "'Zero'", "'MinValue'", "'MaxValue'", "'NaN'", "'PositiveInfinity'", 
                     "'NegativeInfinity'", "'LocalDate'", "'LocalDateTime'", 
                     "'OffsetDate'", "'OffsetDateTime'", "'ZonedDate'", 
                     "'ZonedDateTime'", "'Tomorrow'", "'Today'", "'Now'", 
                     "'Yesterday'", "'Eon'", "'Epoch'", "'Letter'", "'Mark'", 
                     "'Digit'", "'Punctuation'", "'Symbol'", "'Separator'", 
                     "'NonPrintable'", "'Null'", "'Blank'", "'Nonblank'", 
                     "'Folder'", "'File'", "'LinkFile'", "'PipeFile'", "'SocketFile'", 
                     "'BlockDevice'", "'charDevice'", "'NullDevice'", "'Url'", 
                     "'Urn'", "'Ipv4'", "'Ipv6'", "'Result'", "'Okay'", 
                     "'Fail'", "'Maybe'", "'Some'", "'None'", "'Either'", 
                     "'Yea'", "'Nay'", "'Stream'", "'Datum'", "'EoT'", "'assert'", 
                     "'unit'", "'from'", "'once'", "'data'", "'call'", "'hide'", 
                     "'show'", "'stay'", "'pass'", "'past'", "'fail'", "'^'", 
                     "'^/'", "'*!'", "'++'", "'--'", "'+'", "'-'", "'...'", 
                     "'**'", "'*'", "'/'", "'\\u00F7'", "'%'", "'%%'", "'%/'", 
                     "'%*'", "'%+'", "'%-'", "'%^'", "'<<'", "'>>'", "'>>>'", 
                     "'?:'", "'<=>'", "'=='", "'!='", "'~=='", "'~!='", 
                     "'<'", "'<='", "'>'", "'>='", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'?%'", "'!%'", "'!'", "'!!'", "'?'", "'??'", "'!?'", 
                     "'..'", "'>..'", "'..<'", "'>..<'", "':-'", "'->'", 
                     "'=>'", "'=>>'", "'|>'", "'||'", "'&&'", "'?&'", "'!&'", 
                     "'&>'", "'&>>'", "'&1>'", "'&1>>'", "'&2>'", "'&2>>'", 
                     "'='", "':='", "'<-'", "'<<-'", "'<|'", "'~='", "'^='", 
                     "'^/='", "'*='", "'/='", "'\\u00F7='", "'%='", "'%%='", 
                     "'%/='", "'%*='", "'%+='", "'%-='", "'%^='", "'+='", 
                     "'-='", "'<<='", "'>>='", "'>>>='", "'??='", "'&&='", 
                     "'||='", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'$*'", "'$?'", "'$!'", "'$$?'", "'$$!'", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'#!'", "'#$'", "'#?'", "'##?'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'('", "')'", 
                     "'['", "']'", "'{'", "'}'", "'.'", "','", "';'", "':'", 
                     "'''", "'\"'", "'`'", "'@'", "'#'", "'$'", "'&'", "'\\'", 
                     "'~'", "'|'", "'_'", "'(\\'", "'[['", "']]'", "'{{'", 
                     "'}}'", "'::'", "';;'", "'</'", "'/>'", "'<>'", "'</>'" ]

    symbolicNames = [ "<INVALID>", "XML_CONTENT", "INDENT", "DEDENT", "MODULE", 
                      "APPLET", "NOTABENE", "DEFINE", "UNDEF", "USE", "AS", 
                      "OF", "INCLUDE", "INTERFACE", "EXTERN", "RPROC", "FOREIGN", 
                      "CONST", "IVAL", "VAR", "TYPE", "FACT", "ENUM", "FUNC", 
                      "FEED", "SUB", "OPERATOR", "EVENT", "STRUCT", "PROTO", 
                      "TRAIT", "CLASS", "OBJECT", "EXTENDS", "IMPLEMENTS", 
                      "MIXES", "CONSTRUCT", "DESTRUCT", "PROPERTY", "GETTER", 
                      "SETTER", "RAISES", "NOPANIC", "PUBLIC", "PROTECTED", 
                      "PRIVATE", "COMPTIME", "INLINE", "CURRY", "STATIC", 
                      "LINEAR", "SHARED", "VOLATILE", "LOCAL", "ATOMIC", 
                      "MUTABLE", "TRANSIENT", "SYNCHRO", "DIM", "METHOD", 
                      "OVERRIDE", "FINAL", "OFF", "ASYNC", "UNIQUE", "ABSTRACT", 
                      "SEALED", "SINGLETON", "RECORD", "DYNAMIC", "CALLBACK", 
                      "MONAD", "PREFIX", "INFIX", "POSTFIX", "EXPLICIT", 
                      "DELETE", "IF", "THEN", "ELIF", "ELSE", "MATCH", "CASE", 
                      "FALLTHROUGH", "TRY", "CATCH", "OTHERWISE", "UNLESS", 
                      "TILL", "DEFER", "WITH", "DO", "LOOP", "FOR", "EACH", 
                      "STEP", "WHILE", "UNTIL", "UPTO", "NEXT", "REDO", 
                      "CONTINUE", "BREAK", "RETURN", "YIELD", "RAISE", "PANIC", 
                      "GO", "INTO", "GOSUB", "FORK", "AWAIT", "SWITCH", 
                      "WHEN", "DEFAULT", "RESUME", "BEGIN", "END", "AT", 
                      "SCAN", "ECHO", "ALERT", "ENTRY", "PLAY", "SINCE", 
                      "TIMELY", "CANCEL", "THIS", "IOTA", "NTH", "IT", "SELF", 
                      "SUPER", "PARENT", "ALL", "ANY", "LOT", "NIL", "ONE", 
                      "TWO", "LET", "LAMBDA", "TYPEOF", "SIZEOF", "INSTANCEOF", 
                      "ANCESTOROF", "IS", "IN", "BETWEEN", "LIKE", "AND", 
                      "ANDN", "NAND", "OR", "NOR", "XOR", "NXOR", "NOT", 
                      "NEW", "NAB", "DEL", "UNION", "UNITE", "INTER", "MINUS", 
                      "ATOM", "AUTO", "SPAN", "VIEW", "VOID", "BOOL8", "BOOL16", 
                      "BOOL32", "BOOL64", "BOOL128", "BOOL", "BYTE", "NAT8", 
                      "NAT16", "NAT32", "NAT64", "NAT128", "NAT", "BIGNAT", 
                      "INT8", "INT16", "INT32", "INT64", "INT128", "INT", 
                      "BIGINT", "REAL8", "REAL16", "REAL32", "REAL64", "REAL128", 
                      "REAL", "BIGREAL", "DECIMAL8", "DECIMAL16", "DECIMAL32", 
                      "DECIMAL64", "DECIMAL128", "DECIMAL", "MONEY", "RATIO8", 
                      "RATIO16", "RATIO32", "RATIO64", "RATIO128", "RATIO", 
                      "COMPLEX32", "COMPLEX64", "COMPLEX128", "COMPLEX", 
                      "QUATERN32", "QUATERN64", "QUATERN128", "QUATERN", 
                      "DATE", "ELAPSE", "ASCII", "CHAR8", "CHAR16", "CHAR32", 
                      "CHAR", "WCHAR", "ANSI", "STR8", "STR16", "STR32", 
                      "STR", "CSTR", "WSTR", "REGEX", "BINARY", "INET", 
                      "PATH", "URI", "RANGE", "PAIR", "TUPLE", "ARRAY", 
                      "LIST", "MAP", "CHANNEL", "VECTOR", "MATRIX", "SET", 
                      "QUEUE", "DEQUE", "XML", "TABLE", "MEMO", "TRUE", 
                      "FALSE", "NONZERO", "ZERO", "MINVALUE", "MAXVALUE", 
                      "NAN", "POSITIVEINFINITY", "NEGATIVEINFINITY", "LOCALDATE", 
                      "LOCALDATETIME", "OFFSETDATE", "OFFSETDATETIME", "ZONEDDATE", 
                      "ZONEDDATETIME", "TOMORROW", "TODAY", "NOW", "YESTERDAY", 
                      "EON", "EPOCH", "LETTER", "MARK", "DIGIT", "PUNCTUATION", 
                      "SYMBOL", "SEPARATOR", "NONPRINTABLE", "NULL", "BLANK", 
                      "NONBLANK", "FOLDER", "FILE", "LINKLINKFILE", "PIPEFILE", 
                      "SOCKETFILE", "BLOCKDEVICE", "CHARDEVICE", "NULLDEVICE", 
                      "URL", "URN", "IPV4", "IPV6", "RESULT", "OKAY", "FAIL", 
                      "MAYBE", "SOME", "NONE", "EITHER", "YEA", "NAY", "STREAM", 
                      "DATUM", "EOT", "ASSERT", "UNIT", "FROM", "ONCE", 
                      "DATA", "CALL", "HIDE", "SHOW", "STAY", "PASS", "PAST", 
                      "TFAIL", "CARET", "SQUARE_ROOT", "FACTORIAL", "INCREMENT", 
                      "DECREMENT", "PLUS", "HYPHEN", "ELLIPSIS", "NAMED_ARGUMENTS", 
                      "ASTERISK", "SLASH", "DIVISION", "PERCENT", "QUOTIENT", 
                      "PERCENTAGE_RATE", "PERCENTAGE_AMOUNT", "PERCENTAGE_INCREASE", 
                      "PERCENTAGE_DECREASE", "PERCENTAGE_VARIATION", "DOUBLE_LEFT_ANGLE", 
                      "DOUBLE_RIGHT_ANGLE", "UNSIGNED_RIGHT_SHIFT", "ELVIS_TEST", 
                      "THREE_WAY_TEST", "STRICT_EQUALITY", "STRICT_INEQUALITY", 
                      "LOOSE_EQUALITY", "LOOSE_INEQUALITY", "LEFT_ANGLE", 
                      "LESS_OR_EQUALS", "RIGHT_ANGLE", "GREATER_OR_EQUALS", 
                      "IS_NOT", "NOT_IS", "NOT_IN", "NOT_BETWEEN", "NOT_LIKE", 
                      "NOT_INSTANCEOF", "NOT_ANCESTOROF", "NOT_EXTENDS", 
                      "NOT_IMPLEMENTS", "NOT_MIXES", "DIVISIBLE_BY", "NOT_DIVISIBLE_BY", 
                      "EXCLAMATION", "DOUBLE_EXCLAMATION", "QUESTION", "DOUBLE_QUESTION", 
                      "ERROR_NONE_COALESCING", "INTERVAL_INCLUSIVE", "INTERVAL_LEFT_EXCLUSIVE", 
                      "INTERVAL_RIGHT_EXCLUSIVE", "INTERVAL_EXCLUSIVE", 
                      "NECK_RULE", "FUNCTOR", "IMPLICIT_RETURN", "MONAD_BIND", 
                      "PIPELINE", "EXECUTE_BACKGROUND", "EXECUTE_SEQUENCE", 
                      "EXECUTE_SEQUENCE_OKAY", "EXECUTE_SEQUENCE_FAIL", 
                      "OUTPUT_REDIRECTION", "APPEND_OUTPUT_REDIRECTION", 
                      "STDOUT_REDIRECTION", "APPEND_STDOUT_REDIRECTION", 
                      "STDERR_REDIRECTION", "APPEND_STDERR_REDIRECTION", 
                      "EQUAL", "DERIVED_ASSIGNMENT", "POP_ONE_ASSIGNMENT", 
                      "PULL_ALL_ASSIGNMENT", "PIPE_ASSIGNMENT", "SPECIAL_ASSIGNMENT", 
                      "NTH_POWER_ASSIGNMENT", "NTH_ROOT_ASSIGNMENT", "MULTIPLICATION_ASSIGNMENT", 
                      "REAL_DIVISION_ASSIGNMENT", "INTEGER_DIVISION_ASSIGNMENT", 
                      "MODULO_ASSIGNMENT", "QUOTIENT_ASSIGNMENT", "PERCENTAGE_RATE_ASSIGNMENT", 
                      "PERCENTAGE_AMOUNT_ASSIGNMENT", "PERCENTAGE_INCREASE_ASSIGNMENT", 
                      "PERCENTAGE_DECREASE_ASSIGNMENT", "PERCENTAGE_VARIATION_ASSIGNMENT", 
                      "ADDITION_ASSIGNMENT", "SUBTRACTION_ASSIGNMENT", "LEFT_SHIFT_ASSIGNMENT", 
                      "SIGNED_RIGHT_SHIFT_ASSIGNMENT", "UNSIGNED_RIGHT_SHIFT_ASSIGNMENT", 
                      "NONE_COALESCING_ASSIGNMENT", "SHELL_PID_ASSIGNMENT", 
                      "SHELL_BKG_PID_ASSIGNMENT", "IDENTIFIER", "ATOM_IDENTIFIER", 
                      "ASPECT_IDENTIFIER", "NATURAL_LIT", "INTEGER_LIT", 
                      "DECIMAL_LIT", "REAL_LIT", "RATIO_LIT", "IMAGINARY_LIT", 
                      "ELAPSE_LIT", "TERM_LIT", "BINARY_LIT", "ASCII_LIT", 
                      "CHAR_LIT", "VERBATIM_SINGLELINE_STRING_LIT", "VERBATIM_MULTILINE_STRING_LIT", 
                      "TEMPLATE_SINGLELINE_STRING_LIT", "TEMPLATE_MULTILINE_STRING_LIT", 
                      "TRANSLATABLE_SINGLELINE_STRING_LIT", "TRANSLATABLE_MULTILINE_STRING_LIT", 
                      "HEREDOC_STRING_LIT", "REGULAR_EXPRESSION_LIT", "ATOM_DOT_LIT", 
                      "ATOM_ELAPSE_LIT", "ATOM_MUSIC_LIT", "SHELL_CURRENT_OPTIONS", 
                      "SHELL_EXIT_STATUS", "SHELL_ERROR_LEVEL", "SHELL_BKG_EXIT_STATUS", 
                      "SHELL_BKG_ERROR_LEVEL", "SHELL_FILE_DESCRIPTOR", 
                      "SHELL_CMD_ARGUMENT", "SHELL_ENV_VARIABLE", "SHELL_STRING_PATH", 
                      "SHELL_PATH", "ABSOLUTE_PATH", "RUBBERDUCK", "SONGBIRD", 
                      "SHEBANG", "SHERLOCK", "WOODSTOCK_LINE", "WOODSTOCK_BLOCK", 
                      "EOS", "ELC", "EOL", "HASHTAG", "LINE_COMMENT", "BLOCK_COMMENT", 
                      "CELL_COMMENT", "BOM", "WSP", "LEFT_PARENTHESIS", 
                      "RIGHT_PARENTHESIS", "LEFT_BRACKET", "RIGHT_BRACKET", 
                      "LEFT_CURLY", "RIGHT_CURLY", "DOT", "COMMA", "SEMICOLON", 
                      "COLON", "APOSTROPHE", "QUOTE", "BACKTICK", "AT_SIGN", 
                      "HASH", "DOLLAR", "AMPERSAND", "BACKSLASH", "TILDE", 
                      "PIPE", "UNDERSCORE", "LAMBDA_PARENTHESIS", "DOUBLE_LEFT_BRACKET", 
                      "DOUBLE_RIGHT_BRACKET", "DOUBLE_LEFT_CURLY", "DOUBLE_RIGHT_CURLY", 
                      "DOUBLE_COLON", "DOUBLE_SEMICOLON", "XML_CLOSING_TAG", 
                      "XML_SELFCLOSING_TAG", "XML_OPENING_FRAGMENT", "XML_CLOSING_FRAGMENT", 
                      "UnexpectedCharacter" ]

    RULE_scriptProgram = 0
    RULE_sourceCodeProgram = 1
    RULE_oneLinerProgram = 2
    RULE_neoBasic = 3
    RULE_logicalInstructions = 4
    RULE_logicalInstructionSuite = 5
    RULE_logicalInstruction = 6
    RULE_directiveInstructionLiner = 7
    RULE_directiveInstructionSuite = 8
    RULE_instructionSentence = 9
    RULE_shebangInterpreter = 10
    RULE_directiveSentence = 11
    RULE_compilerPragmaDirective = 12
    RULE_shellLookupDirective = 13
    RULE_lookupStatement = 14
    RULE_canaryTestingDirective = 15
    RULE_testingLine = 16
    RULE_testingBlock = 17
    RULE_labelIdentifier = 18
    RULE_qualifiedIdentifier = 19
    RULE_decoratedIdentifier = 20
    RULE_decoratedType = 21
    RULE_typedDecoratedIdentifier = 22
    RULE_inferredDecoratedIdentifier = 23
    RULE_genericDecoratedIdentifier = 24
    RULE_declarationIdentifier = 25
    RULE_identifiers = 26
    RULE_qualifiedIdentifiers = 27
    RULE_decoratedIdentifiers = 28
    RULE_decoratedTypes = 29
    RULE_typedDecoratedIdentifiers = 30
    RULE_inferredDecoratedIdentifiers = 31
    RULE_topLevelSentence = 32
    RULE_identificationSentence = 33
    RULE_appletClause = 34
    RULE_moduleClause = 35
    RULE_notabeneClause = 36
    RULE_deflagSentence = 37
    RULE_defineClause = 38
    RULE_defineSuite = 39
    RULE_defineDeclareBlock = 40
    RULE_defineDeclare = 41
    RULE_defineDeclareSingle = 42
    RULE_defineDeclareMultiple = 43
    RULE_undefClause = 44
    RULE_undefSuite = 45
    RULE_undefDeclareBlock = 46
    RULE_undefDeclare = 47
    RULE_defIdentifier = 48
    RULE_defIdentifiers = 49
    RULE_useSentence = 50
    RULE_useClause = 51
    RULE_useSuite = 52
    RULE_useDeclareBlock = 53
    RULE_useDeclare = 54
    RULE_useDeclareSingle = 55
    RULE_useDeclareMultiple = 56
    RULE_useDeclareAs = 57
    RULE_useDeclareOf = 58
    RULE_interfaceSentence = 59
    RULE_interfaceClause = 60
    RULE_interfaceBody = 61
    RULE_includeSentence = 62
    RULE_includeClause = 63
    RULE_includeSuite = 64
    RULE_includeDeclareBlock = 65
    RULE_includeDeclare = 66
    RULE_includeDeclareSingle = 67
    RULE_includeDeclareMultiple = 68
    RULE_includeDeclareAs = 69
    RULE_declarationSentence = 70
    RULE_adhocMetadata = 71
    RULE_metadataDecorators = 72
    RULE_metadataGenerics = 73
    RULE_visibilityModifier = 74
    RULE_visibilityLabelSuite = 75
    RULE_extendsClause = 76
    RULE_implementsClause = 77
    RULE_mixesClause = 78
    RULE_raisesClause = 79
    RULE_parenthesizedArguments = 80
    RULE_namedArguments = 81
    RULE_namedArgument = 82
    RULE_parenthesizedParameters = 83
    RULE_procParameters = 84
    RULE_procParameter = 85
    RULE_prefixParameterName = 86
    RULE_prefixParameterType = 87
    RULE_procResultType = 88
    RULE_procBody = 89
    RULE_procSuite = 90
    RULE_procSemex = 91
    RULE_procSpecifier = 92
    RULE_procImplicitReturn = 93
    RULE_procPatternGuards = 94
    RULE_guardBranchClause = 95
    RULE_guardElseClause = 96
    RULE_outerDeclareSentence = 97
    RULE_typeSentence = 98
    RULE_typeClause = 99
    RULE_typeSuite = 100
    RULE_typeDeclareBlock = 101
    RULE_typeDeclare = 102
    RULE_typeDeclareSingle = 103
    RULE_typeDeclareSubrange = 104
    RULE_constSentence = 105
    RULE_constClause = 106
    RULE_constSuite = 107
    RULE_constDeclareBlock = 108
    RULE_constDeclare = 109
    RULE_constDeclareSingle = 110
    RULE_constDeclareMultiple = 111
    RULE_constDeclareParallel = 112
    RULE_ivalSentence = 113
    RULE_ivalClause = 114
    RULE_ivalSuite = 115
    RULE_ivalDeclareBlock = 116
    RULE_ivalDeclare = 117
    RULE_ivalDeclareSingle = 118
    RULE_ivalDeclareMultiple = 119
    RULE_ivalDeclareParallel = 120
    RULE_varSentence = 121
    RULE_varClause = 122
    RULE_varSuite = 123
    RULE_varDeclareBlock = 124
    RULE_varDeclare = 125
    RULE_varDeclareSingle = 126
    RULE_varDeclareMultiple = 127
    RULE_varDeclareParallel = 128
    RULE_factSentence = 129
    RULE_factClause = 130
    RULE_funcSentence = 131
    RULE_funcClause = 132
    RULE_feedSentence = 133
    RULE_feedClause = 134
    RULE_subSentence = 135
    RULE_subClause = 136
    RULE_operatorSentence = 137
    RULE_operatorClause = 138
    RULE_operatorIdentifier = 139
    RULE_declarationOperator = 140
    RULE_eventSentence = 141
    RULE_eventClause = 142
    RULE_bracketedParameters = 143
    RULE_enumSentence = 144
    RULE_enumClause = 145
    RULE_enumType = 146
    RULE_enumBody = 147
    RULE_enumSemex = 148
    RULE_enumSuite = 149
    RULE_enumMembersBlock = 150
    RULE_enumMember = 151
    RULE_enumFieldSingle = 152
    RULE_enumFieldMultiple = 153
    RULE_structSentence = 154
    RULE_structClause = 155
    RULE_structBody = 156
    RULE_structSemex = 157
    RULE_structSuite = 158
    RULE_structMembersBlock = 159
    RULE_structMember = 160
    RULE_structFieldSingle = 161
    RULE_attributeTag = 162
    RULE_structFieldMultiple = 163
    RULE_structMemberEmbedded = 164
    RULE_protoSentence = 165
    RULE_protoClause = 166
    RULE_protoBody = 167
    RULE_traitSentence = 168
    RULE_traitClause = 169
    RULE_traitBody = 170
    RULE_classSentence = 171
    RULE_classClause = 172
    RULE_classBody = 173
    RULE_classSemex = 174
    RULE_classFieldMultiple = 175
    RULE_classFieldSimple = 176
    RULE_classSuite = 177
    RULE_innerDeclareSentence = 178
    RULE_constructSentence = 179
    RULE_constructClause = 180
    RULE_classInitializer = 181
    RULE_classInitializingMembers = 182
    RULE_classInitializingMember = 183
    RULE_destructSentence = 184
    RULE_destructClause = 185
    RULE_propertySentence = 186
    RULE_propertyClause = 187
    RULE_propertyBody = 188
    RULE_propertyAccessorSentence = 189
    RULE_propertyGetterClause = 190
    RULE_propertySetterClause = 191
    RULE_statementSentence = 192
    RULE_statementSuite = 193
    RULE_statementBlock = 194
    RULE_clauseStatement = 195
    RULE_simpleStatement = 196
    RULE_expressionStatement = 197
    RULE_emptyStatement = 198
    RULE_assignmentStatement = 199
    RULE_assignmentSingle = 200
    RULE_assignmentMultiple = 201
    RULE_assignmentParallel = 202
    RULE_consoleStatement = 203
    RULE_atClause = 204
    RULE_echoCommand = 205
    RULE_scanCommand = 206
    RULE_alertCommand = 207
    RULE_entryCommand = 208
    RULE_playCommand = 209
    RULE_deterministicStatement = 210
    RULE_redoSentence = 211
    RULE_continueSentence = 212
    RULE_breakSentence = 213
    RULE_fallthroughSentence = 214
    RULE_deferSentence = 215
    RULE_resumeSentence = 216
    RULE_returnSentence = 217
    RULE_yieldSentence = 218
    RULE_raiseSentence = 219
    RULE_panicSentence = 220
    RULE_nondeterministicStatement = 221
    RULE_ifThenSentence = 222
    RULE_goSentence = 223
    RULE_awaitSentence = 224
    RULE_compoundStatement = 225
    RULE_conditionalStatement = 226
    RULE_iterationStatement = 227
    RULE_controlFlowStatement = 228
    RULE_concurrencyStatement = 229
    RULE_ifSentence = 230
    RULE_ifClause = 231
    RULE_elifClause = 232
    RULE_elseClause = 233
    RULE_matchSentence = 234
    RULE_matchClause = 235
    RULE_caseClause = 236
    RULE_trySentence = 237
    RULE_tryClause = 238
    RULE_catchClause = 239
    RULE_switchSentence = 240
    RULE_switchClause = 241
    RULE_whenClause = 242
    RULE_defaultClause = 243
    RULE_loopSentence = 244
    RULE_loopClause = 245
    RULE_loopBody = 246
    RULE_loopNoCheck = 247
    RULE_loopCheckFirst = 248
    RULE_loopCheckLast = 249
    RULE_nextClause = 250
    RULE_uptoClause = 251
    RULE_pretestClause = 252
    RULE_posttestClause = 253
    RULE_loopEachClause = 254
    RULE_loopWhileClause = 255
    RULE_loopUntilClause = 256
    RULE_thenClause = 257
    RULE_beginSentence = 258
    RULE_beginClause = 259
    RULE_endClause = 260
    RULE_withSentence = 261
    RULE_withClause = 262
    RULE_gosubSentence = 263
    RULE_gosubClause = 264
    RULE_forkClause = 265
    RULE_forEachClause = 266
    RULE_testingStatement = 267
    RULE_simpleTestStatement = 268
    RULE_compoundTestStatement = 269
    RULE_assertTestStatement = 270
    RULE_assertClause = 271
    RULE_unitTestStatement = 272
    RULE_unitClause = 273
    RULE_fromClause = 274
    RULE_onceClause = 275
    RULE_dataClause = 276
    RULE_dataTable = 277
    RULE_dataRow = 278
    RULE_callClause = 279
    RULE_hideClause = 280
    RULE_showClause = 281
    RULE_stayClause = 282
    RULE_passClause = 283
    RULE_pastClause = 284
    RULE_failClause = 285
    RULE_prefixUnaryOperator = 286
    RULE_unaryArithmeticOperator = 287
    RULE_unaryLogicalOperator = 288
    RULE_unaryArrayOperator = 289
    RULE_unarySpreadOperator = 290
    RULE_unaryCloneOperator = 291
    RULE_unaryMoveOperator = 292
    RULE_unaryMetaOperator = 293
    RULE_binaryArithmeticOperator = 294
    RULE_binaryExponentialOperator = 295
    RULE_binaryMultiplicativeOperator = 296
    RULE_binaryAdditiveOperator = 297
    RULE_bitShiftOperator = 298
    RULE_binaryConjunctionOperator = 299
    RULE_binaryExclusiveDisjunctionOperator = 300
    RULE_binaryDisjunctionOperator = 301
    RULE_binaryArrayOperator = 302
    RULE_binaryComparisonOperator = 303
    RULE_binaryRelationalOperator = 304
    RULE_binaryConditionalOperator = 305
    RULE_binaryMonadBindOperator = 306
    RULE_binaryPipelineOperator = 307
    RULE_coalescingOperator = 308
    RULE_executionFlowOperator = 309
    RULE_intervalOperator = 310
    RULE_leftIntervalOperator = 311
    RULE_rightIntervalOperator = 312
    RULE_assignmentOperator = 313
    RULE_singleAssignmentOperator = 314
    RULE_unpackingAssignmentOperator = 315
    RULE_compoundAssignmentOperator = 316
    RULE_overloadableOperator = 317
    RULE_symbolDecorators = 318
    RULE_symbolDecorator = 319
    RULE_annotationDecorator = 320
    RULE_aspectDecorator = 321
    RULE_taggedValuePairs = 322
    RULE_taggedValuePair = 323
    RULE_genericTypeParameters = 324
    RULE_typeParameters = 325
    RULE_typeParameter = 326
    RULE_types = 327
    RULE_type = 328
    RULE_prefixTypeModifier = 329
    RULE_postfixTypeWrapper = 330
    RULE_nativeType = 331
    RULE_procType = 332
    RULE_escalarType = 333
    RULE_booleanType = 334
    RULE_numericType = 335
    RULE_numericNatural = 336
    RULE_numericInteger = 337
    RULE_numericDecimal = 338
    RULE_numericReal = 339
    RULE_numericRatio = 340
    RULE_numericComplex = 341
    RULE_numericQuaternion = 342
    RULE_temporalType = 343
    RULE_characterType = 344
    RULE_compoundType = 345
    RULE_sequenceType = 346
    RULE_compositeType = 347
    RULE_collectionType = 348
    RULE_optionType = 349
    RULE_metaType = 350
    RULE_funcType = 351
    RULE_feedType = 352
    RULE_subType = 353
    RULE_factType = 354
    RULE_operatorType = 355
    RULE_eventType = 356
    RULE_getterType = 357
    RULE_setterType = 358
    RULE_parenthesizedParameterTypes = 359
    RULE_bracketedParameterTypes = 360
    RULE_procParameterTypes = 361
    RULE_procParameterType = 362
    RULE_literal = 363
    RULE_escalarLiteral = 364
    RULE_booleanLiteral = 365
    RULE_numericLiteral = 366
    RULE_elapseLiteral = 367
    RULE_dateLiteral = 368
    RULE_characterLiteral = 369
    RULE_optionLiteral = 370
    RULE_resultLiteral = 371
    RULE_maybeLiteral = 372
    RULE_eitherLiteral = 373
    RULE_streamLiteral = 374
    RULE_compoundLiteral = 375
    RULE_sequenceLiteral = 376
    RULE_stringLiteral = 377
    RULE_musicalLiteral = 378
    RULE_compositeLiteral = 379
    RULE_rangeLiteral = 380
    RULE_pairLiteral = 381
    RULE_tupleLiteral = 382
    RULE_inetLiteral = 383
    RULE_uriLiteral = 384
    RULE_shellPathLiteral = 385
    RULE_shellPathLiterals = 386
    RULE_xmlDocLiteral = 387
    RULE_xmlDocElement = 388
    RULE_xmlElementPaired = 389
    RULE_xmlOpeningElement = 390
    RULE_xmlClosingElement = 391
    RULE_xmlElementSelfClosed = 392
    RULE_xmlDocFragment = 393
    RULE_xmlFragmentPaired = 394
    RULE_xmlFragmentSelfClosed = 395
    RULE_xmlTagName = 396
    RULE_xmlAttributes = 397
    RULE_xmlAttributeValue = 398
    RULE_xmlChildren = 399
    RULE_expressionPlaceholder = 400
    RULE_collectionLiteral = 401
    RULE_collectionLiteralValue = 402
    RULE_elements = 403
    RULE_element = 404
    RULE_elementKey = 405
    RULE_elementValue = 406
    RULE_arrayAosToSoaLiteral = 407
    RULE_listComprehension = 408
    RULE_comprehensionClause = 409
    RULE_objectLiteral = 410
    RULE_objectLiteralValue = 411
    RULE_objectMembers = 412
    RULE_objectMember = 413
    RULE_memberName = 414
    RULE_memberValue = 415
    RULE_lambdaLiteral = 416
    RULE_lambdaClause = 417
    RULE_lambdaStatement = 418
    RULE_arithmeticComprehension = 419
    RULE_predeclaredValue = 420
    RULE_predefinedIdentifier = 421
    RULE_predefinedShellValue = 422
    RULE_predeclaredFunctor = 423
    RULE_predeclaredFact = 424
    RULE_predeclaredFmap = 425
    RULE_primaryExpressions = 426
    RULE_primaryExpression = 427
    RULE_primaryOperand = 428
    RULE_primaryFunctor = 429
    RULE_sos_Expression = 430
    RULE_parenthesizedExpression = 431
    RULE_arrayIndexing = 432
    RULE_intervalExpression = 433
    RULE_sliceExpression = 434
    RULE_formatType = 435
    RULE_juxtapositionExpression = 436
    RULE_expressions = 437
    RULE_expression = 438
    RULE_guardsExpression = 439
    RULE_guardClause = 440
    RULE_guardDefault = 441
    RULE_macroExpression = 442
    RULE_macroCall = 443
    RULE_shellProcess = 444
    RULE_assignmentExpression = 445

    ruleNames =  [ "scriptProgram", "sourceCodeProgram", "oneLinerProgram", 
                   "neoBasic", "logicalInstructions", "logicalInstructionSuite", 
                   "logicalInstruction", "directiveInstructionLiner", "directiveInstructionSuite", 
                   "instructionSentence", "shebangInterpreter", "directiveSentence", 
                   "compilerPragmaDirective", "shellLookupDirective", "lookupStatement", 
                   "canaryTestingDirective", "testingLine", "testingBlock", 
                   "labelIdentifier", "qualifiedIdentifier", "decoratedIdentifier", 
                   "decoratedType", "typedDecoratedIdentifier", "inferredDecoratedIdentifier", 
                   "genericDecoratedIdentifier", "declarationIdentifier", 
                   "identifiers", "qualifiedIdentifiers", "decoratedIdentifiers", 
                   "decoratedTypes", "typedDecoratedIdentifiers", "inferredDecoratedIdentifiers", 
                   "topLevelSentence", "identificationSentence", "appletClause", 
                   "moduleClause", "notabeneClause", "deflagSentence", "defineClause", 
                   "defineSuite", "defineDeclareBlock", "defineDeclare", 
                   "defineDeclareSingle", "defineDeclareMultiple", "undefClause", 
                   "undefSuite", "undefDeclareBlock", "undefDeclare", "defIdentifier", 
                   "defIdentifiers", "useSentence", "useClause", "useSuite", 
                   "useDeclareBlock", "useDeclare", "useDeclareSingle", 
                   "useDeclareMultiple", "useDeclareAs", "useDeclareOf", 
                   "interfaceSentence", "interfaceClause", "interfaceBody", 
                   "includeSentence", "includeClause", "includeSuite", "includeDeclareBlock", 
                   "includeDeclare", "includeDeclareSingle", "includeDeclareMultiple", 
                   "includeDeclareAs", "declarationSentence", "adhocMetadata", 
                   "metadataDecorators", "metadataGenerics", "visibilityModifier", 
                   "visibilityLabelSuite", "extendsClause", "implementsClause", 
                   "mixesClause", "raisesClause", "parenthesizedArguments", 
                   "namedArguments", "namedArgument", "parenthesizedParameters", 
                   "procParameters", "procParameter", "prefixParameterName", 
                   "prefixParameterType", "procResultType", "procBody", 
                   "procSuite", "procSemex", "procSpecifier", "procImplicitReturn", 
                   "procPatternGuards", "guardBranchClause", "guardElseClause", 
                   "outerDeclareSentence", "typeSentence", "typeClause", 
                   "typeSuite", "typeDeclareBlock", "typeDeclare", "typeDeclareSingle", 
                   "typeDeclareSubrange", "constSentence", "constClause", 
                   "constSuite", "constDeclareBlock", "constDeclare", "constDeclareSingle", 
                   "constDeclareMultiple", "constDeclareParallel", "ivalSentence", 
                   "ivalClause", "ivalSuite", "ivalDeclareBlock", "ivalDeclare", 
                   "ivalDeclareSingle", "ivalDeclareMultiple", "ivalDeclareParallel", 
                   "varSentence", "varClause", "varSuite", "varDeclareBlock", 
                   "varDeclare", "varDeclareSingle", "varDeclareMultiple", 
                   "varDeclareParallel", "factSentence", "factClause", "funcSentence", 
                   "funcClause", "feedSentence", "feedClause", "subSentence", 
                   "subClause", "operatorSentence", "operatorClause", "operatorIdentifier", 
                   "declarationOperator", "eventSentence", "eventClause", 
                   "bracketedParameters", "enumSentence", "enumClause", 
                   "enumType", "enumBody", "enumSemex", "enumSuite", "enumMembersBlock", 
                   "enumMember", "enumFieldSingle", "enumFieldMultiple", 
                   "structSentence", "structClause", "structBody", "structSemex", 
                   "structSuite", "structMembersBlock", "structMember", 
                   "structFieldSingle", "attributeTag", "structFieldMultiple", 
                   "structMemberEmbedded", "protoSentence", "protoClause", 
                   "protoBody", "traitSentence", "traitClause", "traitBody", 
                   "classSentence", "classClause", "classBody", "classSemex", 
                   "classFieldMultiple", "classFieldSimple", "classSuite", 
                   "innerDeclareSentence", "constructSentence", "constructClause", 
                   "classInitializer", "classInitializingMembers", "classInitializingMember", 
                   "destructSentence", "destructClause", "propertySentence", 
                   "propertyClause", "propertyBody", "propertyAccessorSentence", 
                   "propertyGetterClause", "propertySetterClause", "statementSentence", 
                   "statementSuite", "statementBlock", "clauseStatement", 
                   "simpleStatement", "expressionStatement", "emptyStatement", 
                   "assignmentStatement", "assignmentSingle", "assignmentMultiple", 
                   "assignmentParallel", "consoleStatement", "atClause", 
                   "echoCommand", "scanCommand", "alertCommand", "entryCommand", 
                   "playCommand", "deterministicStatement", "redoSentence", 
                   "continueSentence", "breakSentence", "fallthroughSentence", 
                   "deferSentence", "resumeSentence", "returnSentence", 
                   "yieldSentence", "raiseSentence", "panicSentence", "nondeterministicStatement", 
                   "ifThenSentence", "goSentence", "awaitSentence", "compoundStatement", 
                   "conditionalStatement", "iterationStatement", "controlFlowStatement", 
                   "concurrencyStatement", "ifSentence", "ifClause", "elifClause", 
                   "elseClause", "matchSentence", "matchClause", "caseClause", 
                   "trySentence", "tryClause", "catchClause", "switchSentence", 
                   "switchClause", "whenClause", "defaultClause", "loopSentence", 
                   "loopClause", "loopBody", "loopNoCheck", "loopCheckFirst", 
                   "loopCheckLast", "nextClause", "uptoClause", "pretestClause", 
                   "posttestClause", "loopEachClause", "loopWhileClause", 
                   "loopUntilClause", "thenClause", "beginSentence", "beginClause", 
                   "endClause", "withSentence", "withClause", "gosubSentence", 
                   "gosubClause", "forkClause", "forEachClause", "testingStatement", 
                   "simpleTestStatement", "compoundTestStatement", "assertTestStatement", 
                   "assertClause", "unitTestStatement", "unitClause", "fromClause", 
                   "onceClause", "dataClause", "dataTable", "dataRow", "callClause", 
                   "hideClause", "showClause", "stayClause", "passClause", 
                   "pastClause", "failClause", "prefixUnaryOperator", "unaryArithmeticOperator", 
                   "unaryLogicalOperator", "unaryArrayOperator", "unarySpreadOperator", 
                   "unaryCloneOperator", "unaryMoveOperator", "unaryMetaOperator", 
                   "binaryArithmeticOperator", "binaryExponentialOperator", 
                   "binaryMultiplicativeOperator", "binaryAdditiveOperator", 
                   "bitShiftOperator", "binaryConjunctionOperator", "binaryExclusiveDisjunctionOperator", 
                   "binaryDisjunctionOperator", "binaryArrayOperator", "binaryComparisonOperator", 
                   "binaryRelationalOperator", "binaryConditionalOperator", 
                   "binaryMonadBindOperator", "binaryPipelineOperator", 
                   "coalescingOperator", "executionFlowOperator", "intervalOperator", 
                   "leftIntervalOperator", "rightIntervalOperator", "assignmentOperator", 
                   "singleAssignmentOperator", "unpackingAssignmentOperator", 
                   "compoundAssignmentOperator", "overloadableOperator", 
                   "symbolDecorators", "symbolDecorator", "annotationDecorator", 
                   "aspectDecorator", "taggedValuePairs", "taggedValuePair", 
                   "genericTypeParameters", "typeParameters", "typeParameter", 
                   "types", "type", "prefixTypeModifier", "postfixTypeWrapper", 
                   "nativeType", "procType", "escalarType", "booleanType", 
                   "numericType", "numericNatural", "numericInteger", "numericDecimal", 
                   "numericReal", "numericRatio", "numericComplex", "numericQuaternion", 
                   "temporalType", "characterType", "compoundType", "sequenceType", 
                   "compositeType", "collectionType", "optionType", "metaType", 
                   "funcType", "feedType", "subType", "factType", "operatorType", 
                   "eventType", "getterType", "setterType", "parenthesizedParameterTypes", 
                   "bracketedParameterTypes", "procParameterTypes", "procParameterType", 
                   "literal", "escalarLiteral", "booleanLiteral", "numericLiteral", 
                   "elapseLiteral", "dateLiteral", "characterLiteral", "optionLiteral", 
                   "resultLiteral", "maybeLiteral", "eitherLiteral", "streamLiteral", 
                   "compoundLiteral", "sequenceLiteral", "stringLiteral", 
                   "musicalLiteral", "compositeLiteral", "rangeLiteral", 
                   "pairLiteral", "tupleLiteral", "inetLiteral", "uriLiteral", 
                   "shellPathLiteral", "shellPathLiterals", "xmlDocLiteral", 
                   "xmlDocElement", "xmlElementPaired", "xmlOpeningElement", 
                   "xmlClosingElement", "xmlElementSelfClosed", "xmlDocFragment", 
                   "xmlFragmentPaired", "xmlFragmentSelfClosed", "xmlTagName", 
                   "xmlAttributes", "xmlAttributeValue", "xmlChildren", 
                   "expressionPlaceholder", "collectionLiteral", "collectionLiteralValue", 
                   "elements", "element", "elementKey", "elementValue", 
                   "arrayAosToSoaLiteral", "listComprehension", "comprehensionClause", 
                   "objectLiteral", "objectLiteralValue", "objectMembers", 
                   "objectMember", "memberName", "memberValue", "lambdaLiteral", 
                   "lambdaClause", "lambdaStatement", "arithmeticComprehension", 
                   "predeclaredValue", "predefinedIdentifier", "predefinedShellValue", 
                   "predeclaredFunctor", "predeclaredFact", "predeclaredFmap", 
                   "primaryExpressions", "primaryExpression", "primaryOperand", 
                   "primaryFunctor", "sos_Expression", "parenthesizedExpression", 
                   "arrayIndexing", "intervalExpression", "sliceExpression", 
                   "formatType", "juxtapositionExpression", "expressions", 
                   "expression", "guardsExpression", "guardClause", "guardDefault", 
                   "macroExpression", "macroCall", "shellProcess", "assignmentExpression" ]

    EOF = Token.EOF
    XML_CONTENT=1
    INDENT=2
    DEDENT=3
    MODULE=4
    APPLET=5
    NOTABENE=6
    DEFINE=7
    UNDEF=8
    USE=9
    AS=10
    OF=11
    INCLUDE=12
    INTERFACE=13
    EXTERN=14
    RPROC=15
    FOREIGN=16
    CONST=17
    IVAL=18
    VAR=19
    TYPE=20
    FACT=21
    ENUM=22
    FUNC=23
    FEED=24
    SUB=25
    OPERATOR=26
    EVENT=27
    STRUCT=28
    PROTO=29
    TRAIT=30
    CLASS=31
    OBJECT=32
    EXTENDS=33
    IMPLEMENTS=34
    MIXES=35
    CONSTRUCT=36
    DESTRUCT=37
    PROPERTY=38
    GETTER=39
    SETTER=40
    RAISES=41
    NOPANIC=42
    PUBLIC=43
    PROTECTED=44
    PRIVATE=45
    COMPTIME=46
    INLINE=47
    CURRY=48
    STATIC=49
    LINEAR=50
    SHARED=51
    VOLATILE=52
    LOCAL=53
    ATOMIC=54
    MUTABLE=55
    TRANSIENT=56
    SYNCHRO=57
    DIM=58
    METHOD=59
    OVERRIDE=60
    FINAL=61
    OFF=62
    ASYNC=63
    UNIQUE=64
    ABSTRACT=65
    SEALED=66
    SINGLETON=67
    RECORD=68
    DYNAMIC=69
    CALLBACK=70
    MONAD=71
    PREFIX=72
    INFIX=73
    POSTFIX=74
    EXPLICIT=75
    DELETE=76
    IF=77
    THEN=78
    ELIF=79
    ELSE=80
    MATCH=81
    CASE=82
    FALLTHROUGH=83
    TRY=84
    CATCH=85
    OTHERWISE=86
    UNLESS=87
    TILL=88
    DEFER=89
    WITH=90
    DO=91
    LOOP=92
    FOR=93
    EACH=94
    STEP=95
    WHILE=96
    UNTIL=97
    UPTO=98
    NEXT=99
    REDO=100
    CONTINUE=101
    BREAK=102
    RETURN=103
    YIELD=104
    RAISE=105
    PANIC=106
    GO=107
    INTO=108
    GOSUB=109
    FORK=110
    AWAIT=111
    SWITCH=112
    WHEN=113
    DEFAULT=114
    RESUME=115
    BEGIN=116
    END=117
    AT=118
    SCAN=119
    ECHO=120
    ALERT=121
    ENTRY=122
    PLAY=123
    SINCE=124
    TIMELY=125
    CANCEL=126
    THIS=127
    IOTA=128
    NTH=129
    IT=130
    SELF=131
    SUPER=132
    PARENT=133
    ALL=134
    ANY=135
    LOT=136
    NIL=137
    ONE=138
    TWO=139
    LET=140
    LAMBDA=141
    TYPEOF=142
    SIZEOF=143
    INSTANCEOF=144
    ANCESTOROF=145
    IS=146
    IN=147
    BETWEEN=148
    LIKE=149
    AND=150
    ANDN=151
    NAND=152
    OR=153
    NOR=154
    XOR=155
    NXOR=156
    NOT=157
    NEW=158
    NAB=159
    DEL=160
    UNION=161
    UNITE=162
    INTER=163
    MINUS=164
    ATOM=165
    AUTO=166
    SPAN=167
    VIEW=168
    VOID=169
    BOOL8=170
    BOOL16=171
    BOOL32=172
    BOOL64=173
    BOOL128=174
    BOOL=175
    BYTE=176
    NAT8=177
    NAT16=178
    NAT32=179
    NAT64=180
    NAT128=181
    NAT=182
    BIGNAT=183
    INT8=184
    INT16=185
    INT32=186
    INT64=187
    INT128=188
    INT=189
    BIGINT=190
    REAL8=191
    REAL16=192
    REAL32=193
    REAL64=194
    REAL128=195
    REAL=196
    BIGREAL=197
    DECIMAL8=198
    DECIMAL16=199
    DECIMAL32=200
    DECIMAL64=201
    DECIMAL128=202
    DECIMAL=203
    MONEY=204
    RATIO8=205
    RATIO16=206
    RATIO32=207
    RATIO64=208
    RATIO128=209
    RATIO=210
    COMPLEX32=211
    COMPLEX64=212
    COMPLEX128=213
    COMPLEX=214
    QUATERN32=215
    QUATERN64=216
    QUATERN128=217
    QUATERN=218
    DATE=219
    ELAPSE=220
    ASCII=221
    CHAR8=222
    CHAR16=223
    CHAR32=224
    CHAR=225
    WCHAR=226
    ANSI=227
    STR8=228
    STR16=229
    STR32=230
    STR=231
    CSTR=232
    WSTR=233
    REGEX=234
    BINARY=235
    INET=236
    PATH=237
    URI=238
    RANGE=239
    PAIR=240
    TUPLE=241
    ARRAY=242
    LIST=243
    MAP=244
    CHANNEL=245
    VECTOR=246
    MATRIX=247
    SET=248
    QUEUE=249
    DEQUE=250
    XML=251
    TABLE=252
    MEMO=253
    TRUE=254
    FALSE=255
    NONZERO=256
    ZERO=257
    MINVALUE=258
    MAXVALUE=259
    NAN=260
    POSITIVEINFINITY=261
    NEGATIVEINFINITY=262
    LOCALDATE=263
    LOCALDATETIME=264
    OFFSETDATE=265
    OFFSETDATETIME=266
    ZONEDDATE=267
    ZONEDDATETIME=268
    TOMORROW=269
    TODAY=270
    NOW=271
    YESTERDAY=272
    EON=273
    EPOCH=274
    LETTER=275
    MARK=276
    DIGIT=277
    PUNCTUATION=278
    SYMBOL=279
    SEPARATOR=280
    NONPRINTABLE=281
    NULL=282
    BLANK=283
    NONBLANK=284
    FOLDER=285
    FILE=286
    LINKLINKFILE=287
    PIPEFILE=288
    SOCKETFILE=289
    BLOCKDEVICE=290
    CHARDEVICE=291
    NULLDEVICE=292
    URL=293
    URN=294
    IPV4=295
    IPV6=296
    RESULT=297
    OKAY=298
    FAIL=299
    MAYBE=300
    SOME=301
    NONE=302
    EITHER=303
    YEA=304
    NAY=305
    STREAM=306
    DATUM=307
    EOT=308
    ASSERT=309
    UNIT=310
    FROM=311
    ONCE=312
    DATA=313
    CALL=314
    HIDE=315
    SHOW=316
    STAY=317
    PASS=318
    PAST=319
    TFAIL=320
    CARET=321
    SQUARE_ROOT=322
    FACTORIAL=323
    INCREMENT=324
    DECREMENT=325
    PLUS=326
    HYPHEN=327
    ELLIPSIS=328
    NAMED_ARGUMENTS=329
    ASTERISK=330
    SLASH=331
    DIVISION=332
    PERCENT=333
    QUOTIENT=334
    PERCENTAGE_RATE=335
    PERCENTAGE_AMOUNT=336
    PERCENTAGE_INCREASE=337
    PERCENTAGE_DECREASE=338
    PERCENTAGE_VARIATION=339
    DOUBLE_LEFT_ANGLE=340
    DOUBLE_RIGHT_ANGLE=341
    UNSIGNED_RIGHT_SHIFT=342
    ELVIS_TEST=343
    THREE_WAY_TEST=344
    STRICT_EQUALITY=345
    STRICT_INEQUALITY=346
    LOOSE_EQUALITY=347
    LOOSE_INEQUALITY=348
    LEFT_ANGLE=349
    LESS_OR_EQUALS=350
    RIGHT_ANGLE=351
    GREATER_OR_EQUALS=352
    IS_NOT=353
    NOT_IS=354
    NOT_IN=355
    NOT_BETWEEN=356
    NOT_LIKE=357
    NOT_INSTANCEOF=358
    NOT_ANCESTOROF=359
    NOT_EXTENDS=360
    NOT_IMPLEMENTS=361
    NOT_MIXES=362
    DIVISIBLE_BY=363
    NOT_DIVISIBLE_BY=364
    EXCLAMATION=365
    DOUBLE_EXCLAMATION=366
    QUESTION=367
    DOUBLE_QUESTION=368
    ERROR_NONE_COALESCING=369
    INTERVAL_INCLUSIVE=370
    INTERVAL_LEFT_EXCLUSIVE=371
    INTERVAL_RIGHT_EXCLUSIVE=372
    INTERVAL_EXCLUSIVE=373
    NECK_RULE=374
    FUNCTOR=375
    IMPLICIT_RETURN=376
    MONAD_BIND=377
    PIPELINE=378
    EXECUTE_BACKGROUND=379
    EXECUTE_SEQUENCE=380
    EXECUTE_SEQUENCE_OKAY=381
    EXECUTE_SEQUENCE_FAIL=382
    OUTPUT_REDIRECTION=383
    APPEND_OUTPUT_REDIRECTION=384
    STDOUT_REDIRECTION=385
    APPEND_STDOUT_REDIRECTION=386
    STDERR_REDIRECTION=387
    APPEND_STDERR_REDIRECTION=388
    EQUAL=389
    DERIVED_ASSIGNMENT=390
    POP_ONE_ASSIGNMENT=391
    PULL_ALL_ASSIGNMENT=392
    PIPE_ASSIGNMENT=393
    SPECIAL_ASSIGNMENT=394
    NTH_POWER_ASSIGNMENT=395
    NTH_ROOT_ASSIGNMENT=396
    MULTIPLICATION_ASSIGNMENT=397
    REAL_DIVISION_ASSIGNMENT=398
    INTEGER_DIVISION_ASSIGNMENT=399
    MODULO_ASSIGNMENT=400
    QUOTIENT_ASSIGNMENT=401
    PERCENTAGE_RATE_ASSIGNMENT=402
    PERCENTAGE_AMOUNT_ASSIGNMENT=403
    PERCENTAGE_INCREASE_ASSIGNMENT=404
    PERCENTAGE_DECREASE_ASSIGNMENT=405
    PERCENTAGE_VARIATION_ASSIGNMENT=406
    ADDITION_ASSIGNMENT=407
    SUBTRACTION_ASSIGNMENT=408
    LEFT_SHIFT_ASSIGNMENT=409
    SIGNED_RIGHT_SHIFT_ASSIGNMENT=410
    UNSIGNED_RIGHT_SHIFT_ASSIGNMENT=411
    NONE_COALESCING_ASSIGNMENT=412
    SHELL_PID_ASSIGNMENT=413
    SHELL_BKG_PID_ASSIGNMENT=414
    IDENTIFIER=415
    ATOM_IDENTIFIER=416
    ASPECT_IDENTIFIER=417
    NATURAL_LIT=418
    INTEGER_LIT=419
    DECIMAL_LIT=420
    REAL_LIT=421
    RATIO_LIT=422
    IMAGINARY_LIT=423
    ELAPSE_LIT=424
    TERM_LIT=425
    BINARY_LIT=426
    ASCII_LIT=427
    CHAR_LIT=428
    VERBATIM_SINGLELINE_STRING_LIT=429
    VERBATIM_MULTILINE_STRING_LIT=430
    TEMPLATE_SINGLELINE_STRING_LIT=431
    TEMPLATE_MULTILINE_STRING_LIT=432
    TRANSLATABLE_SINGLELINE_STRING_LIT=433
    TRANSLATABLE_MULTILINE_STRING_LIT=434
    HEREDOC_STRING_LIT=435
    REGULAR_EXPRESSION_LIT=436
    ATOM_DOT_LIT=437
    ATOM_ELAPSE_LIT=438
    ATOM_MUSIC_LIT=439
    SHELL_CURRENT_OPTIONS=440
    SHELL_EXIT_STATUS=441
    SHELL_ERROR_LEVEL=442
    SHELL_BKG_EXIT_STATUS=443
    SHELL_BKG_ERROR_LEVEL=444
    SHELL_FILE_DESCRIPTOR=445
    SHELL_CMD_ARGUMENT=446
    SHELL_ENV_VARIABLE=447
    SHELL_STRING_PATH=448
    SHELL_PATH=449
    ABSOLUTE_PATH=450
    RUBBERDUCK=451
    SONGBIRD=452
    SHEBANG=453
    SHERLOCK=454
    WOODSTOCK_LINE=455
    WOODSTOCK_BLOCK=456
    EOS=457
    ELC=458
    EOL=459
    HASHTAG=460
    LINE_COMMENT=461
    BLOCK_COMMENT=462
    CELL_COMMENT=463
    BOM=464
    WSP=465
    LEFT_PARENTHESIS=466
    RIGHT_PARENTHESIS=467
    LEFT_BRACKET=468
    RIGHT_BRACKET=469
    LEFT_CURLY=470
    RIGHT_CURLY=471
    DOT=472
    COMMA=473
    SEMICOLON=474
    COLON=475
    APOSTROPHE=476
    QUOTE=477
    BACKTICK=478
    AT_SIGN=479
    HASH=480
    DOLLAR=481
    AMPERSAND=482
    BACKSLASH=483
    TILDE=484
    PIPE=485
    UNDERSCORE=486
    LAMBDA_PARENTHESIS=487
    DOUBLE_LEFT_BRACKET=488
    DOUBLE_RIGHT_BRACKET=489
    DOUBLE_LEFT_CURLY=490
    DOUBLE_RIGHT_CURLY=491
    DOUBLE_COLON=492
    DOUBLE_SEMICOLON=493
    XML_CLOSING_TAG=494
    XML_SELFCLOSING_TAG=495
    XML_OPENING_FRAGMENT=496
    XML_CLOSING_FRAGMENT=497
    UnexpectedCharacter=498

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ScriptProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shebangInterpreter(self):
            return self.getTypedRuleContext(NeoBasicParser.ShebangInterpreterContext,0)


        def sourceCodeProgram(self):
            return self.getTypedRuleContext(NeoBasicParser.SourceCodeProgramContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_scriptProgram

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScriptProgram" ):
                listener.enterScriptProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScriptProgram" ):
                listener.exitScriptProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitScriptProgram" ):
                return visitor.visitScriptProgram(self)
            else:
                return visitor.visitChildren(self)




    def scriptProgram(self):

        localctx = NeoBasicParser.ScriptProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_scriptProgram)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 892
            self.shebangInterpreter()
            self.state = 893
            self.sourceCodeProgram()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SourceCodeProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalInstructions(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_sourceCodeProgram

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSourceCodeProgram" ):
                listener.enterSourceCodeProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSourceCodeProgram" ):
                listener.exitSourceCodeProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSourceCodeProgram" ):
                return visitor.visitSourceCodeProgram(self)
            else:
                return visitor.visitChildren(self)




    def sourceCodeProgram(self):

        localctx = NeoBasicParser.SourceCodeProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_sourceCodeProgram)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 895
            self.logicalInstructions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OneLinerProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalInstruction(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_oneLinerProgram

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOneLinerProgram" ):
                listener.enterOneLinerProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOneLinerProgram" ):
                listener.exitOneLinerProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOneLinerProgram" ):
                return visitor.visitOneLinerProgram(self)
            else:
                return visitor.visitChildren(self)




    def oneLinerProgram(self):

        localctx = NeoBasicParser.OneLinerProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_oneLinerProgram)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 897
            self.logicalInstruction()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NeoBasicContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def scriptProgram(self):
            return self.getTypedRuleContext(NeoBasicParser.ScriptProgramContext,0)


        def sourceCodeProgram(self):
            return self.getTypedRuleContext(NeoBasicParser.SourceCodeProgramContext,0)


        def oneLinerProgram(self):
            return self.getTypedRuleContext(NeoBasicParser.OneLinerProgramContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_neoBasic

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNeoBasic" ):
                listener.enterNeoBasic(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNeoBasic" ):
                listener.exitNeoBasic(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNeoBasic" ):
                return visitor.visitNeoBasic(self)
            else:
                return visitor.visitChildren(self)




    def neoBasic(self):

        localctx = NeoBasicParser.NeoBasicContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_neoBasic)
        try:
            self.state = 902
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 899
                self.scriptProgram()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 900
                self.sourceCodeProgram()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 901
                self.oneLinerProgram()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalInstructionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalInstruction(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.LogicalInstructionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_logicalInstructions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalInstructions" ):
                listener.enterLogicalInstructions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalInstructions" ):
                listener.exitLogicalInstructions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalInstructions" ):
                return visitor.visitLogicalInstructions(self)
            else:
                return visitor.visitChildren(self)




    def logicalInstructions(self):

        localctx = NeoBasicParser.LogicalInstructionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_logicalInstructions)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 907 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 904
                    self.logicalInstruction()
                    self.state = 905
                    self.match(NeoBasicParser.EOS)

                else:
                    raise NoViableAltException(self)
                self.state = 909 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,1,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalInstructionSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def logicalInstruction(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.LogicalInstructionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionContext,i)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_logicalInstructionSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalInstructionSuite" ):
                listener.enterLogicalInstructionSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalInstructionSuite" ):
                listener.exitLogicalInstructionSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalInstructionSuite" ):
                return visitor.visitLogicalInstructionSuite(self)
            else:
                return visitor.visitChildren(self)




    def logicalInstructionSuite(self):

        localctx = NeoBasicParser.LogicalInstructionSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_logicalInstructionSuite)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 911
            self.match(NeoBasicParser.EOS)
            self.state = 912
            self.match(NeoBasicParser.INDENT)
            self.state = 913
            self.logicalInstruction()
            self.state = 918
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==457:
                self.state = 914
                self.match(NeoBasicParser.EOS)
                self.state = 915
                self.logicalInstruction()
                self.state = 920
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 921
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalInstructionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def directiveInstructionLiner(self):
            return self.getTypedRuleContext(NeoBasicParser.DirectiveInstructionLinerContext,0)


        def directiveInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.DirectiveInstructionSuiteContext,0)


        def instructionSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.InstructionSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_logicalInstruction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalInstruction" ):
                listener.enterLogicalInstruction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalInstruction" ):
                listener.exitLogicalInstruction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalInstruction" ):
                return visitor.visitLogicalInstruction(self)
            else:
                return visitor.visitChildren(self)




    def logicalInstruction(self):

        localctx = NeoBasicParser.LogicalInstructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_logicalInstruction)
        try:
            self.state = 926
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 923
                self.directiveInstructionLiner()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 924
                self.directiveInstructionSuite()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 925
                self.instructionSentence()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DirectiveInstructionLinerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def directiveSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.DirectiveSentenceContext,0)


        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def logicalInstruction(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_directiveInstructionLiner

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirectiveInstructionLiner" ):
                listener.enterDirectiveInstructionLiner(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirectiveInstructionLiner" ):
                listener.exitDirectiveInstructionLiner(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDirectiveInstructionLiner" ):
                return visitor.visitDirectiveInstructionLiner(self)
            else:
                return visitor.visitChildren(self)




    def directiveInstructionLiner(self):

        localctx = NeoBasicParser.DirectiveInstructionLinerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_directiveInstructionLiner)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 928
            self.directiveSentence()
            self.state = 929
            self.match(NeoBasicParser.EOS)
            self.state = 930
            self.logicalInstruction()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DirectiveInstructionSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def directiveSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.DirectiveSentenceContext,0)


        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_directiveInstructionSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirectiveInstructionSuite" ):
                listener.enterDirectiveInstructionSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirectiveInstructionSuite" ):
                listener.exitDirectiveInstructionSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDirectiveInstructionSuite" ):
                return visitor.visitDirectiveInstructionSuite(self)
            else:
                return visitor.visitChildren(self)




    def directiveInstructionSuite(self):

        localctx = NeoBasicParser.DirectiveInstructionSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_directiveInstructionSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 932
            self.directiveSentence()
            self.state = 933
            self.logicalInstructionSuite()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InstructionSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SONGBIRD(self):
            return self.getToken(NeoBasicParser.SONGBIRD, 0)

        def instructionSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.InstructionSentenceContext,0)


        def RUBBERDUCK(self):
            return self.getToken(NeoBasicParser.RUBBERDUCK, 0)

        def topLevelSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.TopLevelSentenceContext,0)


        def declarationSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationSentenceContext,0)


        def statementSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_instructionSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstructionSentence" ):
                listener.enterInstructionSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstructionSentence" ):
                listener.exitInstructionSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInstructionSentence" ):
                return visitor.visitInstructionSentence(self)
            else:
                return visitor.visitChildren(self)




    def instructionSentence(self):

        localctx = NeoBasicParser.InstructionSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_instructionSentence)
        try:
            self.state = 943
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 935
                self.match(NeoBasicParser.SONGBIRD)
                self.state = 936
                self.instructionSentence()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 937
                self.match(NeoBasicParser.RUBBERDUCK)
                self.state = 938
                self.instructionSentence()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 939
                self.topLevelSentence()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 940
                self.declarationSentence()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 941
                self.statementSentence()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShebangInterpreterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHEBANG(self):
            return self.getToken(NeoBasicParser.SHEBANG, 0)

        def ABSOLUTE_PATH(self):
            return self.getToken(NeoBasicParser.ABSOLUTE_PATH, 0)

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_shebangInterpreter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShebangInterpreter" ):
                listener.enterShebangInterpreter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShebangInterpreter" ):
                listener.exitShebangInterpreter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShebangInterpreter" ):
                return visitor.visitShebangInterpreter(self)
            else:
                return visitor.visitChildren(self)




    def shebangInterpreter(self):

        localctx = NeoBasicParser.ShebangInterpreterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_shebangInterpreter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 945
            self.match(NeoBasicParser.SHEBANG)
            self.state = 946
            self.match(NeoBasicParser.ABSOLUTE_PATH)
            self.state = 948
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1649529585664) != 0) or ((((_la - 127)) & ~0x3f) == 0 and ((1 << (_la - 127)) & -257706303489) != 0) or ((((_la - 191)) & ~0x3f) == 0 and ((1 << (_la - 191)) & -1) != 0) or ((((_la - 255)) & ~0x3f) == 0 and ((1 << (_la - 255)) & 18014398507384831) != 0) or ((((_la - 321)) & ~0x3f) == 0 and ((1 << (_la - 321)) & 2814750039736063) != 0) or ((((_la - 415)) & ~0x3f) == 0 and ((1 << (_la - 415)) & 47287830447128569) != 0) or ((((_la - 485)) & ~0x3f) == 0 and ((1 << (_la - 485)) & 6151) != 0):
                self.state = 947
                self.expression(0)


            self.state = 950
            self.match(NeoBasicParser.EOS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DirectiveSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def compilerPragmaDirective(self):
            return self.getTypedRuleContext(NeoBasicParser.CompilerPragmaDirectiveContext,0)


        def shellLookupDirective(self):
            return self.getTypedRuleContext(NeoBasicParser.ShellLookupDirectiveContext,0)


        def canaryTestingDirective(self):
            return self.getTypedRuleContext(NeoBasicParser.CanaryTestingDirectiveContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_directiveSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirectiveSentence" ):
                listener.enterDirectiveSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirectiveSentence" ):
                listener.exitDirectiveSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDirectiveSentence" ):
                return visitor.visitDirectiveSentence(self)
            else:
                return visitor.visitChildren(self)




    def directiveSentence(self):

        localctx = NeoBasicParser.DirectiveSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_directiveSentence)
        try:
            self.state = 955
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [453]:
                self.enterOuterAlt(localctx, 1)
                self.state = 952
                self.compilerPragmaDirective()
                pass
            elif token in [454]:
                self.enterOuterAlt(localctx, 2)
                self.state = 953
                self.shellLookupDirective()
                pass
            elif token in [455, 456]:
                self.enterOuterAlt(localctx, 3)
                self.state = 954
                self.canaryTestingDirective()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompilerPragmaDirectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHEBANG(self):
            return self.getToken(NeoBasicParser.SHEBANG, 0)

        def IDENTIFIER(self):
            return self.getToken(NeoBasicParser.IDENTIFIER, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_compilerPragmaDirective

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompilerPragmaDirective" ):
                listener.enterCompilerPragmaDirective(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompilerPragmaDirective" ):
                listener.exitCompilerPragmaDirective(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompilerPragmaDirective" ):
                return visitor.visitCompilerPragmaDirective(self)
            else:
                return visitor.visitChildren(self)




    def compilerPragmaDirective(self):

        localctx = NeoBasicParser.CompilerPragmaDirectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_compilerPragmaDirective)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 957
            self.match(NeoBasicParser.SHEBANG)
            self.state = 958
            self.match(NeoBasicParser.IDENTIFIER)
            self.state = 960
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1649529585664) != 0) or ((((_la - 127)) & ~0x3f) == 0 and ((1 << (_la - 127)) & -257706303489) != 0) or ((((_la - 191)) & ~0x3f) == 0 and ((1 << (_la - 191)) & -1) != 0) or ((((_la - 255)) & ~0x3f) == 0 and ((1 << (_la - 255)) & 18014398507384831) != 0) or ((((_la - 321)) & ~0x3f) == 0 and ((1 << (_la - 321)) & 2814750039736063) != 0) or ((((_la - 415)) & ~0x3f) == 0 and ((1 << (_la - 415)) & 47287830447128569) != 0) or ((((_la - 485)) & ~0x3f) == 0 and ((1 << (_la - 485)) & 6151) != 0):
                self.state = 959
                self.expressions()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShellLookupDirectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHERLOCK(self):
            return self.getToken(NeoBasicParser.SHERLOCK, 0)

        def lookupStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.LookupStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_shellLookupDirective

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShellLookupDirective" ):
                listener.enterShellLookupDirective(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShellLookupDirective" ):
                listener.exitShellLookupDirective(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShellLookupDirective" ):
                return visitor.visitShellLookupDirective(self)
            else:
                return visitor.visitChildren(self)




    def shellLookupDirective(self):

        localctx = NeoBasicParser.ShellLookupDirectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_shellLookupDirective)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 962
            self.match(NeoBasicParser.SHERLOCK)
            self.state = 963
            self.lookupStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LookupStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_lookupStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLookupStatement" ):
                listener.enterLookupStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLookupStatement" ):
                listener.exitLookupStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLookupStatement" ):
                return visitor.visitLookupStatement(self)
            else:
                return visitor.visitChildren(self)




    def lookupStatement(self):

        localctx = NeoBasicParser.LookupStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_lookupStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 965
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CanaryTestingDirectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def testingLine(self):
            return self.getTypedRuleContext(NeoBasicParser.TestingLineContext,0)


        def testingBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.TestingBlockContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_canaryTestingDirective

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCanaryTestingDirective" ):
                listener.enterCanaryTestingDirective(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCanaryTestingDirective" ):
                listener.exitCanaryTestingDirective(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCanaryTestingDirective" ):
                return visitor.visitCanaryTestingDirective(self)
            else:
                return visitor.visitChildren(self)




    def canaryTestingDirective(self):

        localctx = NeoBasicParser.CanaryTestingDirectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_canaryTestingDirective)
        try:
            self.state = 969
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [455]:
                self.enterOuterAlt(localctx, 1)
                self.state = 967
                self.testingLine()
                pass
            elif token in [456]:
                self.enterOuterAlt(localctx, 2)
                self.state = 968
                self.testingBlock()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TestingLineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WOODSTOCK_LINE(self):
            return self.getToken(NeoBasicParser.WOODSTOCK_LINE, 0)

        def logicalInstruction(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_testingLine

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTestingLine" ):
                listener.enterTestingLine(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTestingLine" ):
                listener.exitTestingLine(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTestingLine" ):
                return visitor.visitTestingLine(self)
            else:
                return visitor.visitChildren(self)




    def testingLine(self):

        localctx = NeoBasicParser.TestingLineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_testingLine)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 971
            self.match(NeoBasicParser.WOODSTOCK_LINE)
            self.state = 972
            self.logicalInstruction()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TestingBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WOODSTOCK_BLOCK(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.WOODSTOCK_BLOCK)
            else:
                return self.getToken(NeoBasicParser.WOODSTOCK_BLOCK, i)

        def logicalInstructions(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_testingBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTestingBlock" ):
                listener.enterTestingBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTestingBlock" ):
                listener.exitTestingBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTestingBlock" ):
                return visitor.visitTestingBlock(self)
            else:
                return visitor.visitChildren(self)




    def testingBlock(self):

        localctx = NeoBasicParser.TestingBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_testingBlock)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 974
            self.match(NeoBasicParser.WOODSTOCK_BLOCK)
            self.state = 975
            self.logicalInstructions()
            self.state = 976
            self.match(NeoBasicParser.WOODSTOCK_BLOCK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(NeoBasicParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_labelIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelIdentifier" ):
                listener.enterLabelIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelIdentifier" ):
                listener.exitLabelIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabelIdentifier" ):
                return visitor.visitLabelIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def labelIdentifier(self):

        localctx = NeoBasicParser.LabelIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_labelIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 978
            self.match(NeoBasicParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QualifiedIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.IDENTIFIER)
            else:
                return self.getToken(NeoBasicParser.IDENTIFIER, i)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.DOT)
            else:
                return self.getToken(NeoBasicParser.DOT, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_qualifiedIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQualifiedIdentifier" ):
                listener.enterQualifiedIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQualifiedIdentifier" ):
                listener.exitQualifiedIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQualifiedIdentifier" ):
                return visitor.visitQualifiedIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def qualifiedIdentifier(self):

        localctx = NeoBasicParser.QualifiedIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_qualifiedIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 980
            self.match(NeoBasicParser.IDENTIFIER)
            self.state = 985
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 981
                    self.match(NeoBasicParser.DOT)
                    self.state = 982
                    self.match(NeoBasicParser.IDENTIFIER) 
                self.state = 987
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecoratedIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(NeoBasicParser.IDENTIFIER, 0)

        def metadataDecorators(self):
            return self.getTypedRuleContext(NeoBasicParser.MetadataDecoratorsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_decoratedIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecoratedIdentifier" ):
                listener.enterDecoratedIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecoratedIdentifier" ):
                listener.exitDecoratedIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDecoratedIdentifier" ):
                return visitor.visitDecoratedIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def decoratedIdentifier(self):

        localctx = NeoBasicParser.DecoratedIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_decoratedIdentifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 989
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==416 or _la==417:
                self.state = 988
                self.metadataDecorators()


            self.state = 991
            self.match(NeoBasicParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecoratedTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def metadataDecorators(self):
            return self.getTypedRuleContext(NeoBasicParser.MetadataDecoratorsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_decoratedType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecoratedType" ):
                listener.enterDecoratedType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecoratedType" ):
                listener.exitDecoratedType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDecoratedType" ):
                return visitor.visitDecoratedType(self)
            else:
                return visitor.visitChildren(self)




    def decoratedType(self):

        localctx = NeoBasicParser.DecoratedTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_decoratedType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 994
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==416 or _la==417:
                self.state = 993
                self.metadataDecorators()


            self.state = 996
            self.type_(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypedDecoratedIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def decoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DecoratedIdentifierContext,0)


        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_typedDecoratedIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypedDecoratedIdentifier" ):
                listener.enterTypedDecoratedIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypedDecoratedIdentifier" ):
                listener.exitTypedDecoratedIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypedDecoratedIdentifier" ):
                return visitor.visitTypedDecoratedIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def typedDecoratedIdentifier(self):

        localctx = NeoBasicParser.TypedDecoratedIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_typedDecoratedIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 998
            self.decoratedIdentifier()
            self.state = 999
            self.type_(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InferredDecoratedIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def decoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DecoratedIdentifierContext,0)


        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_inferredDecoratedIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInferredDecoratedIdentifier" ):
                listener.enterInferredDecoratedIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInferredDecoratedIdentifier" ):
                listener.exitInferredDecoratedIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInferredDecoratedIdentifier" ):
                return visitor.visitInferredDecoratedIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def inferredDecoratedIdentifier(self):

        localctx = NeoBasicParser.InferredDecoratedIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_inferredDecoratedIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1001
            self.decoratedIdentifier()
            self.state = 1003
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.state = 1002
                self.type_(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenericDecoratedIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def decoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DecoratedIdentifierContext,0)


        def genericTypeParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.GenericTypeParametersContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_genericDecoratedIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenericDecoratedIdentifier" ):
                listener.enterGenericDecoratedIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenericDecoratedIdentifier" ):
                listener.exitGenericDecoratedIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenericDecoratedIdentifier" ):
                return visitor.visitGenericDecoratedIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def genericDecoratedIdentifier(self):

        localctx = NeoBasicParser.GenericDecoratedIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_genericDecoratedIdentifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1005
            self.decoratedIdentifier()
            self.state = 1007
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==349:
                self.state = 1006
                self.genericTypeParameters()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def metadataDecorators(self):
            return self.getTypedRuleContext(NeoBasicParser.MetadataDecoratorsContext,0)


        def genericTypeParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.GenericTypeParametersContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_declarationIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclarationIdentifier" ):
                listener.enterDeclarationIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclarationIdentifier" ):
                listener.exitDeclarationIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeclarationIdentifier" ):
                return visitor.visitDeclarationIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def declarationIdentifier(self):

        localctx = NeoBasicParser.DeclarationIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_declarationIdentifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1010
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==416 or _la==417:
                self.state = 1009
                self.metadataDecorators()


            self.state = 1012
            self.qualifiedIdentifier()
            self.state = 1014
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==349:
                self.state = 1013
                self.genericTypeParameters()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifiersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.IDENTIFIER)
            else:
                return self.getToken(NeoBasicParser.IDENTIFIER, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_identifiers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifiers" ):
                listener.enterIdentifiers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifiers" ):
                listener.exitIdentifiers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifiers" ):
                return visitor.visitIdentifiers(self)
            else:
                return visitor.visitChildren(self)




    def identifiers(self):

        localctx = NeoBasicParser.IdentifiersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_identifiers)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1016
            self.match(NeoBasicParser.IDENTIFIER)
            self.state = 1021
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==473:
                self.state = 1017
                self.match(NeoBasicParser.COMMA)
                self.state = 1018
                self.match(NeoBasicParser.IDENTIFIER)
                self.state = 1023
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QualifiedIdentifiersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.QualifiedIdentifierContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_qualifiedIdentifiers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQualifiedIdentifiers" ):
                listener.enterQualifiedIdentifiers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQualifiedIdentifiers" ):
                listener.exitQualifiedIdentifiers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQualifiedIdentifiers" ):
                return visitor.visitQualifiedIdentifiers(self)
            else:
                return visitor.visitChildren(self)




    def qualifiedIdentifiers(self):

        localctx = NeoBasicParser.QualifiedIdentifiersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_qualifiedIdentifiers)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1024
            self.qualifiedIdentifier()
            self.state = 1029
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==473:
                self.state = 1025
                self.match(NeoBasicParser.COMMA)
                self.state = 1026
                self.qualifiedIdentifier()
                self.state = 1031
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecoratedIdentifiersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def decoratedIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.DecoratedIdentifierContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.DecoratedIdentifierContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_decoratedIdentifiers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecoratedIdentifiers" ):
                listener.enterDecoratedIdentifiers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecoratedIdentifiers" ):
                listener.exitDecoratedIdentifiers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDecoratedIdentifiers" ):
                return visitor.visitDecoratedIdentifiers(self)
            else:
                return visitor.visitChildren(self)




    def decoratedIdentifiers(self):

        localctx = NeoBasicParser.DecoratedIdentifiersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_decoratedIdentifiers)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1032
            self.decoratedIdentifier()
            self.state = 1037
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==473:
                self.state = 1033
                self.match(NeoBasicParser.COMMA)
                self.state = 1034
                self.decoratedIdentifier()
                self.state = 1039
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecoratedTypesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def decoratedType(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.DecoratedTypeContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.DecoratedTypeContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_decoratedTypes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecoratedTypes" ):
                listener.enterDecoratedTypes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecoratedTypes" ):
                listener.exitDecoratedTypes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDecoratedTypes" ):
                return visitor.visitDecoratedTypes(self)
            else:
                return visitor.visitChildren(self)




    def decoratedTypes(self):

        localctx = NeoBasicParser.DecoratedTypesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_decoratedTypes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1040
            self.decoratedType()
            self.state = 1045
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==473:
                self.state = 1041
                self.match(NeoBasicParser.COMMA)
                self.state = 1042
                self.decoratedType()
                self.state = 1047
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypedDecoratedIdentifiersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typedDecoratedIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.TypedDecoratedIdentifierContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.TypedDecoratedIdentifierContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_typedDecoratedIdentifiers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypedDecoratedIdentifiers" ):
                listener.enterTypedDecoratedIdentifiers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypedDecoratedIdentifiers" ):
                listener.exitTypedDecoratedIdentifiers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypedDecoratedIdentifiers" ):
                return visitor.visitTypedDecoratedIdentifiers(self)
            else:
                return visitor.visitChildren(self)




    def typedDecoratedIdentifiers(self):

        localctx = NeoBasicParser.TypedDecoratedIdentifiersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_typedDecoratedIdentifiers)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1048
            self.typedDecoratedIdentifier()
            self.state = 1053
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==473:
                self.state = 1049
                self.match(NeoBasicParser.COMMA)
                self.state = 1050
                self.typedDecoratedIdentifier()
                self.state = 1055
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InferredDecoratedIdentifiersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def inferredDecoratedIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.InferredDecoratedIdentifierContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifierContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_inferredDecoratedIdentifiers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInferredDecoratedIdentifiers" ):
                listener.enterInferredDecoratedIdentifiers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInferredDecoratedIdentifiers" ):
                listener.exitInferredDecoratedIdentifiers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInferredDecoratedIdentifiers" ):
                return visitor.visitInferredDecoratedIdentifiers(self)
            else:
                return visitor.visitChildren(self)




    def inferredDecoratedIdentifiers(self):

        localctx = NeoBasicParser.InferredDecoratedIdentifiersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_inferredDecoratedIdentifiers)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1056
            self.inferredDecoratedIdentifier()
            self.state = 1061
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==473:
                self.state = 1057
                self.match(NeoBasicParser.COMMA)
                self.state = 1058
                self.inferredDecoratedIdentifier()
                self.state = 1063
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopLevelSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identificationSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.IdentificationSentenceContext,0)


        def deflagSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.DeflagSentenceContext,0)


        def useSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.UseSentenceContext,0)


        def interfaceSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.InterfaceSentenceContext,0)


        def includeSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.IncludeSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_topLevelSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopLevelSentence" ):
                listener.enterTopLevelSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopLevelSentence" ):
                listener.exitTopLevelSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTopLevelSentence" ):
                return visitor.visitTopLevelSentence(self)
            else:
                return visitor.visitChildren(self)




    def topLevelSentence(self):

        localctx = NeoBasicParser.TopLevelSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_topLevelSentence)
        try:
            self.state = 1069
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [4, 5, 6]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1064
                self.identificationSentence()
                pass
            elif token in [7, 8]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1065
                self.deflagSentence()
                pass
            elif token in [9]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1066
                self.useSentence()
                pass
            elif token in [13]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1067
                self.interfaceSentence()
                pass
            elif token in [12]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1068
                self.includeSentence()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentificationSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def appletClause(self):
            return self.getTypedRuleContext(NeoBasicParser.AppletClauseContext,0)


        def moduleClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ModuleClauseContext,0)


        def notabeneClause(self):
            return self.getTypedRuleContext(NeoBasicParser.NotabeneClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_identificationSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentificationSentence" ):
                listener.enterIdentificationSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentificationSentence" ):
                listener.exitIdentificationSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentificationSentence" ):
                return visitor.visitIdentificationSentence(self)
            else:
                return visitor.visitChildren(self)




    def identificationSentence(self):

        localctx = NeoBasicParser.IdentificationSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_identificationSentence)
        try:
            self.state = 1074
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [5]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1071
                self.appletClause()
                pass
            elif token in [4]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1072
                self.moduleClause()
                pass
            elif token in [6]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1073
                self.notabeneClause()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AppletClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def APPLET(self):
            return self.getToken(NeoBasicParser.APPLET, 0)

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_appletClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAppletClause" ):
                listener.enterAppletClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAppletClause" ):
                listener.exitAppletClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAppletClause" ):
                return visitor.visitAppletClause(self)
            else:
                return visitor.visitChildren(self)




    def appletClause(self):

        localctx = NeoBasicParser.AppletClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_appletClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1076
            self.match(NeoBasicParser.APPLET)
            self.state = 1078
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==415:
                self.state = 1077
                self.qualifiedIdentifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModuleClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MODULE(self):
            return self.getToken(NeoBasicParser.MODULE, 0)

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_moduleClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModuleClause" ):
                listener.enterModuleClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModuleClause" ):
                listener.exitModuleClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModuleClause" ):
                return visitor.visitModuleClause(self)
            else:
                return visitor.visitChildren(self)




    def moduleClause(self):

        localctx = NeoBasicParser.ModuleClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_moduleClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1080
            self.match(NeoBasicParser.MODULE)
            self.state = 1081
            self.qualifiedIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NotabeneClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOTABENE(self):
            return self.getToken(NeoBasicParser.NOTABENE, 0)

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_notabeneClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNotabeneClause" ):
                listener.enterNotabeneClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNotabeneClause" ):
                listener.exitNotabeneClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNotabeneClause" ):
                return visitor.visitNotabeneClause(self)
            else:
                return visitor.visitChildren(self)




    def notabeneClause(self):

        localctx = NeoBasicParser.NotabeneClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_notabeneClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1083
            self.match(NeoBasicParser.NOTABENE)
            self.state = 1084
            self.qualifiedIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeflagSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defineClause(self):
            return self.getTypedRuleContext(NeoBasicParser.DefineClauseContext,0)


        def undefClause(self):
            return self.getTypedRuleContext(NeoBasicParser.UndefClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_deflagSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeflagSentence" ):
                listener.enterDeflagSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeflagSentence" ):
                listener.exitDeflagSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeflagSentence" ):
                return visitor.visitDeflagSentence(self)
            else:
                return visitor.visitChildren(self)




    def deflagSentence(self):

        localctx = NeoBasicParser.DeflagSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_deflagSentence)
        try:
            self.state = 1088
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1086
                self.defineClause()
                pass
            elif token in [8]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1087
                self.undefClause()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefineClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFINE(self):
            return self.getToken(NeoBasicParser.DEFINE, 0)

        def defineSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.DefineSuiteContext,0)


        def defineDeclare(self):
            return self.getTypedRuleContext(NeoBasicParser.DefineDeclareContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_defineClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefineClause" ):
                listener.enterDefineClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefineClause" ):
                listener.exitDefineClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefineClause" ):
                return visitor.visitDefineClause(self)
            else:
                return visitor.visitChildren(self)




    def defineClause(self):

        localctx = NeoBasicParser.DefineClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_defineClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1090
            self.match(NeoBasicParser.DEFINE)
            self.state = 1093
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [457]:
                self.state = 1091
                self.defineSuite()
                pass
            elif token in [415, 416]:
                self.state = 1092
                self.defineDeclare()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefineSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def defineDeclareBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.DefineDeclareBlockContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_defineSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefineSuite" ):
                listener.enterDefineSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefineSuite" ):
                listener.exitDefineSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefineSuite" ):
                return visitor.visitDefineSuite(self)
            else:
                return visitor.visitChildren(self)




    def defineSuite(self):

        localctx = NeoBasicParser.DefineSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_defineSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1095
            self.match(NeoBasicParser.EOS)
            self.state = 1096
            self.match(NeoBasicParser.INDENT)
            self.state = 1097
            self.defineDeclareBlock()
            self.state = 1098
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefineDeclareBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defineDeclare(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.DefineDeclareContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.DefineDeclareContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_defineDeclareBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefineDeclareBlock" ):
                listener.enterDefineDeclareBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefineDeclareBlock" ):
                listener.exitDefineDeclareBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefineDeclareBlock" ):
                return visitor.visitDefineDeclareBlock(self)
            else:
                return visitor.visitChildren(self)




    def defineDeclareBlock(self):

        localctx = NeoBasicParser.DefineDeclareBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_defineDeclareBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1100
            self.defineDeclare()
            self.state = 1105
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==457:
                self.state = 1101
                self.match(NeoBasicParser.EOS)
                self.state = 1102
                self.defineDeclare()
                self.state = 1107
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefineDeclareContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defineDeclareSingle(self):
            return self.getTypedRuleContext(NeoBasicParser.DefineDeclareSingleContext,0)


        def defineDeclareMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.DefineDeclareMultipleContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_defineDeclare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefineDeclare" ):
                listener.enterDefineDeclare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefineDeclare" ):
                listener.exitDefineDeclare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefineDeclare" ):
                return visitor.visitDefineDeclare(self)
            else:
                return visitor.visitChildren(self)




    def defineDeclare(self):

        localctx = NeoBasicParser.DefineDeclareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_defineDeclare)
        try:
            self.state = 1110
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1108
                self.defineDeclareSingle()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1109
                self.defineDeclareMultiple()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefineDeclareSingleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DefIdentifierContext,0)


        def literal(self):
            return self.getTypedRuleContext(NeoBasicParser.LiteralContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_defineDeclareSingle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefineDeclareSingle" ):
                listener.enterDefineDeclareSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefineDeclareSingle" ):
                listener.exitDefineDeclareSingle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefineDeclareSingle" ):
                return visitor.visitDefineDeclareSingle(self)
            else:
                return visitor.visitChildren(self)




    def defineDeclareSingle(self):

        localctx = NeoBasicParser.DefineDeclareSingleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_defineDeclareSingle)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1112
            self.defIdentifier()
            self.state = 1114
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1649529585664) != 0) or ((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & -16712191) != 0) or ((((_la - 205)) & ~0x3f) == 0 and ((1 << (_la - 205)) & -1) != 0) or ((((_la - 269)) & ~0x3f) == 0 and ((1 << (_la - 269)) & -1859985546592387201) != 0) or ((((_la - 333)) & ~0x3f) == 0 and ((1 << (_la - 333)) & 687194833919) != 0) or ((((_la - 415)) & ~0x3f) == 0 and ((1 << (_la - 415)) & 47287821890748409) != 0) or ((((_la - 487)) & ~0x3f) == 0 and ((1 << (_la - 487)) & 1537) != 0):
                self.state = 1113
                self.literal()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefineDeclareMultipleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defineDeclareSingle(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.DefineDeclareSingleContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.DefineDeclareSingleContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_defineDeclareMultiple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefineDeclareMultiple" ):
                listener.enterDefineDeclareMultiple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefineDeclareMultiple" ):
                listener.exitDefineDeclareMultiple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefineDeclareMultiple" ):
                return visitor.visitDefineDeclareMultiple(self)
            else:
                return visitor.visitChildren(self)




    def defineDeclareMultiple(self):

        localctx = NeoBasicParser.DefineDeclareMultipleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_defineDeclareMultiple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1116
            self.defineDeclareSingle()
            self.state = 1119 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1117
                self.match(NeoBasicParser.COMMA)
                self.state = 1118
                self.defineDeclareSingle()
                self.state = 1121 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==473):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UndefClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNDEF(self):
            return self.getToken(NeoBasicParser.UNDEF, 0)

        def undefSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.UndefSuiteContext,0)


        def undefDeclare(self):
            return self.getTypedRuleContext(NeoBasicParser.UndefDeclareContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_undefClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUndefClause" ):
                listener.enterUndefClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUndefClause" ):
                listener.exitUndefClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUndefClause" ):
                return visitor.visitUndefClause(self)
            else:
                return visitor.visitChildren(self)




    def undefClause(self):

        localctx = NeoBasicParser.UndefClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_undefClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1123
            self.match(NeoBasicParser.UNDEF)
            self.state = 1126
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [457]:
                self.state = 1124
                self.undefSuite()
                pass
            elif token in [415, 416]:
                self.state = 1125
                self.undefDeclare()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UndefSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def undefDeclareBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.UndefDeclareBlockContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_undefSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUndefSuite" ):
                listener.enterUndefSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUndefSuite" ):
                listener.exitUndefSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUndefSuite" ):
                return visitor.visitUndefSuite(self)
            else:
                return visitor.visitChildren(self)




    def undefSuite(self):

        localctx = NeoBasicParser.UndefSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_undefSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1128
            self.match(NeoBasicParser.EOS)
            self.state = 1129
            self.match(NeoBasicParser.INDENT)
            self.state = 1130
            self.undefDeclareBlock()
            self.state = 1131
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UndefDeclareBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def undefDeclare(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.UndefDeclareContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.UndefDeclareContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_undefDeclareBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUndefDeclareBlock" ):
                listener.enterUndefDeclareBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUndefDeclareBlock" ):
                listener.exitUndefDeclareBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUndefDeclareBlock" ):
                return visitor.visitUndefDeclareBlock(self)
            else:
                return visitor.visitChildren(self)




    def undefDeclareBlock(self):

        localctx = NeoBasicParser.UndefDeclareBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_undefDeclareBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1133
            self.undefDeclare()
            self.state = 1138
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==457:
                self.state = 1134
                self.match(NeoBasicParser.EOS)
                self.state = 1135
                self.undefDeclare()
                self.state = 1140
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UndefDeclareContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defIdentifiers(self):
            return self.getTypedRuleContext(NeoBasicParser.DefIdentifiersContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_undefDeclare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUndefDeclare" ):
                listener.enterUndefDeclare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUndefDeclare" ):
                listener.exitUndefDeclare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUndefDeclare" ):
                return visitor.visitUndefDeclare(self)
            else:
                return visitor.visitChildren(self)




    def undefDeclare(self):

        localctx = NeoBasicParser.UndefDeclareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_undefDeclare)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1141
            self.defIdentifiers()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(NeoBasicParser.IDENTIFIER, 0)

        def ATOM_IDENTIFIER(self):
            return self.getToken(NeoBasicParser.ATOM_IDENTIFIER, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_defIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefIdentifier" ):
                listener.enterDefIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefIdentifier" ):
                listener.exitDefIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefIdentifier" ):
                return visitor.visitDefIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def defIdentifier(self):

        localctx = NeoBasicParser.DefIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_defIdentifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1143
            _la = self._input.LA(1)
            if not(_la==415 or _la==416):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefIdentifiersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def defIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.DefIdentifierContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.DefIdentifierContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_defIdentifiers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefIdentifiers" ):
                listener.enterDefIdentifiers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefIdentifiers" ):
                listener.exitDefIdentifiers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefIdentifiers" ):
                return visitor.visitDefIdentifiers(self)
            else:
                return visitor.visitChildren(self)




    def defIdentifiers(self):

        localctx = NeoBasicParser.DefIdentifiersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_defIdentifiers)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1145
            self.defIdentifier()
            self.state = 1150
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==473:
                self.state = 1146
                self.match(NeoBasicParser.COMMA)
                self.state = 1147
                self.defIdentifier()
                self.state = 1152
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UseSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def useClause(self):
            return self.getTypedRuleContext(NeoBasicParser.UseClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_useSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseSentence" ):
                listener.enterUseSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseSentence" ):
                listener.exitUseSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUseSentence" ):
                return visitor.visitUseSentence(self)
            else:
                return visitor.visitChildren(self)




    def useSentence(self):

        localctx = NeoBasicParser.UseSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_useSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1153
            self.useClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UseClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USE(self):
            return self.getToken(NeoBasicParser.USE, 0)

        def useSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.UseSuiteContext,0)


        def useDeclare(self):
            return self.getTypedRuleContext(NeoBasicParser.UseDeclareContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_useClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseClause" ):
                listener.enterUseClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseClause" ):
                listener.exitUseClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUseClause" ):
                return visitor.visitUseClause(self)
            else:
                return visitor.visitChildren(self)




    def useClause(self):

        localctx = NeoBasicParser.UseClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_useClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1155
            self.match(NeoBasicParser.USE)
            self.state = 1158
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [457]:
                self.state = 1156
                self.useSuite()
                pass
            elif token in [415]:
                self.state = 1157
                self.useDeclare()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UseSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def useDeclareBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.UseDeclareBlockContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_useSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseSuite" ):
                listener.enterUseSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseSuite" ):
                listener.exitUseSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUseSuite" ):
                return visitor.visitUseSuite(self)
            else:
                return visitor.visitChildren(self)




    def useSuite(self):

        localctx = NeoBasicParser.UseSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_useSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1160
            self.match(NeoBasicParser.EOS)
            self.state = 1161
            self.match(NeoBasicParser.INDENT)
            self.state = 1162
            self.useDeclareBlock()
            self.state = 1163
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UseDeclareBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def useDeclare(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.UseDeclareContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.UseDeclareContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_useDeclareBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseDeclareBlock" ):
                listener.enterUseDeclareBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseDeclareBlock" ):
                listener.exitUseDeclareBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUseDeclareBlock" ):
                return visitor.visitUseDeclareBlock(self)
            else:
                return visitor.visitChildren(self)




    def useDeclareBlock(self):

        localctx = NeoBasicParser.UseDeclareBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_useDeclareBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1165
            self.useDeclare()
            self.state = 1170
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==457:
                self.state = 1166
                self.match(NeoBasicParser.EOS)
                self.state = 1167
                self.useDeclare()
                self.state = 1172
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UseDeclareContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def useDeclareSingle(self):
            return self.getTypedRuleContext(NeoBasicParser.UseDeclareSingleContext,0)


        def useDeclareMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.UseDeclareMultipleContext,0)


        def useDeclareAs(self):
            return self.getTypedRuleContext(NeoBasicParser.UseDeclareAsContext,0)


        def useDeclareOf(self):
            return self.getTypedRuleContext(NeoBasicParser.UseDeclareOfContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_useDeclare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseDeclare" ):
                listener.enterUseDeclare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseDeclare" ):
                listener.exitUseDeclare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUseDeclare" ):
                return visitor.visitUseDeclare(self)
            else:
                return visitor.visitChildren(self)




    def useDeclare(self):

        localctx = NeoBasicParser.UseDeclareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_useDeclare)
        try:
            self.state = 1177
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1173
                self.useDeclareSingle()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1174
                self.useDeclareMultiple()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1175
                self.useDeclareAs()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1176
                self.useDeclareOf()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UseDeclareSingleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_useDeclareSingle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseDeclareSingle" ):
                listener.enterUseDeclareSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseDeclareSingle" ):
                listener.exitUseDeclareSingle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUseDeclareSingle" ):
                return visitor.visitUseDeclareSingle(self)
            else:
                return visitor.visitChildren(self)




    def useDeclareSingle(self):

        localctx = NeoBasicParser.UseDeclareSingleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_useDeclareSingle)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1179
            self.qualifiedIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UseDeclareMultipleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def useDeclareSingle(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.UseDeclareSingleContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.UseDeclareSingleContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_useDeclareMultiple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseDeclareMultiple" ):
                listener.enterUseDeclareMultiple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseDeclareMultiple" ):
                listener.exitUseDeclareMultiple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUseDeclareMultiple" ):
                return visitor.visitUseDeclareMultiple(self)
            else:
                return visitor.visitChildren(self)




    def useDeclareMultiple(self):

        localctx = NeoBasicParser.UseDeclareMultipleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_useDeclareMultiple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1181
            self.useDeclareSingle()
            self.state = 1184 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1182
                self.match(NeoBasicParser.COMMA)
                self.state = 1183
                self.useDeclareSingle()
                self.state = 1186 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==473):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UseDeclareAsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def AS(self):
            return self.getToken(NeoBasicParser.AS, 0)

        def IDENTIFIER(self):
            return self.getToken(NeoBasicParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_useDeclareAs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseDeclareAs" ):
                listener.enterUseDeclareAs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseDeclareAs" ):
                listener.exitUseDeclareAs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUseDeclareAs" ):
                return visitor.visitUseDeclareAs(self)
            else:
                return visitor.visitChildren(self)




    def useDeclareAs(self):

        localctx = NeoBasicParser.UseDeclareAsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_useDeclareAs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1188
            self.qualifiedIdentifier()
            self.state = 1189
            self.match(NeoBasicParser.AS)
            self.state = 1190
            self.match(NeoBasicParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UseDeclareOfContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedIdentifiers(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifiersContext,0)


        def OF(self):
            return self.getToken(NeoBasicParser.OF, 0)

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_useDeclareOf

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseDeclareOf" ):
                listener.enterUseDeclareOf(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseDeclareOf" ):
                listener.exitUseDeclareOf(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUseDeclareOf" ):
                return visitor.visitUseDeclareOf(self)
            else:
                return visitor.visitChildren(self)




    def useDeclareOf(self):

        localctx = NeoBasicParser.UseDeclareOfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_useDeclareOf)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1192
            self.qualifiedIdentifiers()
            self.state = 1193
            self.match(NeoBasicParser.OF)
            self.state = 1194
            self.qualifiedIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InterfaceSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def interfaceClause(self):
            return self.getTypedRuleContext(NeoBasicParser.InterfaceClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_interfaceSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterfaceSentence" ):
                listener.enterInterfaceSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterfaceSentence" ):
                listener.exitInterfaceSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterfaceSentence" ):
                return visitor.visitInterfaceSentence(self)
            else:
                return visitor.visitChildren(self)




    def interfaceSentence(self):

        localctx = NeoBasicParser.InterfaceSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_interfaceSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1196
            self.interfaceClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InterfaceClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTERFACE(self):
            return self.getToken(NeoBasicParser.INTERFACE, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def interfaceBody(self):
            return self.getTypedRuleContext(NeoBasicParser.InterfaceBodyContext,0)


        def mixesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.MixesClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_interfaceClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterfaceClause" ):
                listener.enterInterfaceClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterfaceClause" ):
                listener.exitInterfaceClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterfaceClause" ):
                return visitor.visitInterfaceClause(self)
            else:
                return visitor.visitChildren(self)




    def interfaceClause(self):

        localctx = NeoBasicParser.InterfaceClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_interfaceClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1198
            self.match(NeoBasicParser.INTERFACE)
            self.state = 1199
            self.declarationIdentifier()
            self.state = 1201
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==35:
                self.state = 1200
                self.mixesClause()


            self.state = 1203
            self.interfaceBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InterfaceBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_interfaceBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterfaceBody" ):
                listener.enterInterfaceBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterfaceBody" ):
                listener.exitInterfaceBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterfaceBody" ):
                return visitor.visitInterfaceBody(self)
            else:
                return visitor.visitChildren(self)




    def interfaceBody(self):

        localctx = NeoBasicParser.InterfaceBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_interfaceBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1205
            self.logicalInstructionSuite()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def includeClause(self):
            return self.getTypedRuleContext(NeoBasicParser.IncludeClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_includeSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncludeSentence" ):
                listener.enterIncludeSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncludeSentence" ):
                listener.exitIncludeSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncludeSentence" ):
                return visitor.visitIncludeSentence(self)
            else:
                return visitor.visitChildren(self)




    def includeSentence(self):

        localctx = NeoBasicParser.IncludeSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_includeSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1207
            self.includeClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INCLUDE(self):
            return self.getToken(NeoBasicParser.INCLUDE, 0)

        def includeSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.IncludeSuiteContext,0)


        def includeDeclare(self):
            return self.getTypedRuleContext(NeoBasicParser.IncludeDeclareContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_includeClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncludeClause" ):
                listener.enterIncludeClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncludeClause" ):
                listener.exitIncludeClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncludeClause" ):
                return visitor.visitIncludeClause(self)
            else:
                return visitor.visitChildren(self)




    def includeClause(self):

        localctx = NeoBasicParser.IncludeClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_includeClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1209
            self.match(NeoBasicParser.INCLUDE)
            self.state = 1212
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [457]:
                self.state = 1210
                self.includeSuite()
                pass
            elif token in [285, 286, 287, 288, 289, 290, 291, 292, 448, 449]:
                self.state = 1211
                self.includeDeclare()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def includeDeclareBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.IncludeDeclareBlockContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_includeSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncludeSuite" ):
                listener.enterIncludeSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncludeSuite" ):
                listener.exitIncludeSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncludeSuite" ):
                return visitor.visitIncludeSuite(self)
            else:
                return visitor.visitChildren(self)




    def includeSuite(self):

        localctx = NeoBasicParser.IncludeSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_includeSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1214
            self.match(NeoBasicParser.EOS)
            self.state = 1215
            self.match(NeoBasicParser.INDENT)
            self.state = 1216
            self.includeDeclareBlock()
            self.state = 1217
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeDeclareBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def includeDeclare(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.IncludeDeclareContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.IncludeDeclareContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_includeDeclareBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncludeDeclareBlock" ):
                listener.enterIncludeDeclareBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncludeDeclareBlock" ):
                listener.exitIncludeDeclareBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncludeDeclareBlock" ):
                return visitor.visitIncludeDeclareBlock(self)
            else:
                return visitor.visitChildren(self)




    def includeDeclareBlock(self):

        localctx = NeoBasicParser.IncludeDeclareBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_includeDeclareBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1219
            self.includeDeclare()
            self.state = 1224
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==457:
                self.state = 1220
                self.match(NeoBasicParser.EOS)
                self.state = 1221
                self.includeDeclare()
                self.state = 1226
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeDeclareContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def includeDeclareSingle(self):
            return self.getTypedRuleContext(NeoBasicParser.IncludeDeclareSingleContext,0)


        def includeDeclareMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.IncludeDeclareMultipleContext,0)


        def includeDeclareAs(self):
            return self.getTypedRuleContext(NeoBasicParser.IncludeDeclareAsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_includeDeclare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncludeDeclare" ):
                listener.enterIncludeDeclare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncludeDeclare" ):
                listener.exitIncludeDeclare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncludeDeclare" ):
                return visitor.visitIncludeDeclare(self)
            else:
                return visitor.visitChildren(self)




    def includeDeclare(self):

        localctx = NeoBasicParser.IncludeDeclareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_includeDeclare)
        try:
            self.state = 1230
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1227
                self.includeDeclareSingle()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1228
                self.includeDeclareMultiple()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1229
                self.includeDeclareAs()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeDeclareSingleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shellPathLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.ShellPathLiteralContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_includeDeclareSingle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncludeDeclareSingle" ):
                listener.enterIncludeDeclareSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncludeDeclareSingle" ):
                listener.exitIncludeDeclareSingle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncludeDeclareSingle" ):
                return visitor.visitIncludeDeclareSingle(self)
            else:
                return visitor.visitChildren(self)




    def includeDeclareSingle(self):

        localctx = NeoBasicParser.IncludeDeclareSingleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_includeDeclareSingle)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1232
            self.shellPathLiteral()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeDeclareMultipleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def includeDeclareSingle(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.IncludeDeclareSingleContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.IncludeDeclareSingleContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_includeDeclareMultiple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncludeDeclareMultiple" ):
                listener.enterIncludeDeclareMultiple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncludeDeclareMultiple" ):
                listener.exitIncludeDeclareMultiple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncludeDeclareMultiple" ):
                return visitor.visitIncludeDeclareMultiple(self)
            else:
                return visitor.visitChildren(self)




    def includeDeclareMultiple(self):

        localctx = NeoBasicParser.IncludeDeclareMultipleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_includeDeclareMultiple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1234
            self.includeDeclareSingle()
            self.state = 1237 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1235
                self.match(NeoBasicParser.COMMA)
                self.state = 1236
                self.includeDeclareSingle()
                self.state = 1239 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==473):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeDeclareAsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shellPathLiterals(self):
            return self.getTypedRuleContext(NeoBasicParser.ShellPathLiteralsContext,0)


        def AS(self):
            return self.getToken(NeoBasicParser.AS, 0)

        def inferredDecoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_includeDeclareAs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncludeDeclareAs" ):
                listener.enterIncludeDeclareAs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncludeDeclareAs" ):
                listener.exitIncludeDeclareAs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncludeDeclareAs" ):
                return visitor.visitIncludeDeclareAs(self)
            else:
                return visitor.visitChildren(self)




    def includeDeclareAs(self):

        localctx = NeoBasicParser.IncludeDeclareAsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_includeDeclareAs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1241
            self.shellPathLiterals()
            self.state = 1242
            self.match(NeoBasicParser.AS)
            self.state = 1243
            self.inferredDecoratedIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declarationSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationSentenceContext,0)


        def adhocMetadata(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.AdhocMetadataContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.AdhocMetadataContext,i)


        def visibilityLabelSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.VisibilityLabelSuiteContext,0)


        def outerDeclareSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.OuterDeclareSentenceContext,0)


        def innerDeclareSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.InnerDeclareSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_declarationSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclarationSentence" ):
                listener.enterDeclarationSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclarationSentence" ):
                listener.exitDeclarationSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeclarationSentence" ):
                return visitor.visitDeclarationSentence(self)
            else:
                return visitor.visitChildren(self)




    def declarationSentence(self):

        localctx = NeoBasicParser.DeclarationSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_declarationSentence)
        try:
            self.state = 1255
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1246 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 1245
                        self.adhocMetadata()

                    else:
                        raise NoViableAltException(self)
                    self.state = 1248 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,43,self._ctx)

                self.state = 1250
                self.declarationSentence()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1252
                self.visibilityLabelSuite()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1253
                self.outerDeclareSentence()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1254
                self.innerDeclareSentence()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AdhocMetadataContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def metadataDecorators(self):
            return self.getTypedRuleContext(NeoBasicParser.MetadataDecoratorsContext,0)


        def metadataGenerics(self):
            return self.getTypedRuleContext(NeoBasicParser.MetadataGenericsContext,0)


        def visibilityModifier(self):
            return self.getTypedRuleContext(NeoBasicParser.VisibilityModifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_adhocMetadata

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdhocMetadata" ):
                listener.enterAdhocMetadata(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdhocMetadata" ):
                listener.exitAdhocMetadata(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdhocMetadata" ):
                return visitor.visitAdhocMetadata(self)
            else:
                return visitor.visitChildren(self)




    def adhocMetadata(self):

        localctx = NeoBasicParser.AdhocMetadataContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_adhocMetadata)
        try:
            self.state = 1260
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [416, 417]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1257
                self.metadataDecorators()
                pass
            elif token in [340]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1258
                self.metadataGenerics()
                pass
            elif token in [43, 44, 45]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1259
                self.visibilityModifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MetadataDecoratorsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbolDecorators(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.SymbolDecoratorsContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.SymbolDecoratorsContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_metadataDecorators

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetadataDecorators" ):
                listener.enterMetadataDecorators(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetadataDecorators" ):
                listener.exitMetadataDecorators(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetadataDecorators" ):
                return visitor.visitMetadataDecorators(self)
            else:
                return visitor.visitChildren(self)




    def metadataDecorators(self):

        localctx = NeoBasicParser.MetadataDecoratorsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_metadataDecorators)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1262
            self.symbolDecorators()
            self.state = 1269
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,47,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1264
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==457:
                        self.state = 1263
                        self.match(NeoBasicParser.EOS)


                    self.state = 1266
                    self.symbolDecorators() 
                self.state = 1271
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,47,self._ctx)

            self.state = 1273
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==457:
                self.state = 1272
                self.match(NeoBasicParser.EOS)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MetadataGenericsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOUBLE_LEFT_ANGLE(self):
            return self.getToken(NeoBasicParser.DOUBLE_LEFT_ANGLE, 0)

        def typeParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeParametersContext,0)


        def DOUBLE_RIGHT_ANGLE(self):
            return self.getToken(NeoBasicParser.DOUBLE_RIGHT_ANGLE, 0)

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_metadataGenerics

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetadataGenerics" ):
                listener.enterMetadataGenerics(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetadataGenerics" ):
                listener.exitMetadataGenerics(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetadataGenerics" ):
                return visitor.visitMetadataGenerics(self)
            else:
                return visitor.visitChildren(self)




    def metadataGenerics(self):

        localctx = NeoBasicParser.MetadataGenericsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_metadataGenerics)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1275
            self.match(NeoBasicParser.DOUBLE_LEFT_ANGLE)
            self.state = 1276
            self.typeParameters()
            self.state = 1277
            self.match(NeoBasicParser.DOUBLE_RIGHT_ANGLE)
            self.state = 1279
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==457:
                self.state = 1278
                self.match(NeoBasicParser.EOS)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VisibilityModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PUBLIC(self):
            return self.getToken(NeoBasicParser.PUBLIC, 0)

        def PROTECTED(self):
            return self.getToken(NeoBasicParser.PROTECTED, 0)

        def PRIVATE(self):
            return self.getToken(NeoBasicParser.PRIVATE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_visibilityModifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVisibilityModifier" ):
                listener.enterVisibilityModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVisibilityModifier" ):
                listener.exitVisibilityModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVisibilityModifier" ):
                return visitor.visitVisibilityModifier(self)
            else:
                return visitor.visitChildren(self)




    def visibilityModifier(self):

        localctx = NeoBasicParser.VisibilityModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_visibilityModifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1281
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 61572651155456) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VisibilityLabelSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def visibilityModifier(self):
            return self.getTypedRuleContext(NeoBasicParser.VisibilityModifierContext,0)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def declarationSentence(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.DeclarationSentenceContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.DeclarationSentenceContext,i)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_visibilityLabelSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVisibilityLabelSuite" ):
                listener.enterVisibilityLabelSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVisibilityLabelSuite" ):
                listener.exitVisibilityLabelSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVisibilityLabelSuite" ):
                return visitor.visitVisibilityLabelSuite(self)
            else:
                return visitor.visitChildren(self)




    def visibilityLabelSuite(self):

        localctx = NeoBasicParser.VisibilityLabelSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_visibilityLabelSuite)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1283
            self.visibilityModifier()
            self.state = 1284
            self.match(NeoBasicParser.EOS)
            self.state = 1285
            self.match(NeoBasicParser.INDENT)
            self.state = 1286
            self.declarationSentence()
            self.state = 1291
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==457:
                self.state = 1287
                self.match(NeoBasicParser.EOS)
                self.state = 1288
                self.declarationSentence()
                self.state = 1293
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1294
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtendsClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXTENDS(self):
            return self.getToken(NeoBasicParser.EXTENDS, 0)

        def types(self):
            return self.getTypedRuleContext(NeoBasicParser.TypesContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_extendsClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtendsClause" ):
                listener.enterExtendsClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtendsClause" ):
                listener.exitExtendsClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExtendsClause" ):
                return visitor.visitExtendsClause(self)
            else:
                return visitor.visitChildren(self)




    def extendsClause(self):

        localctx = NeoBasicParser.ExtendsClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_extendsClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1296
            self.match(NeoBasicParser.EXTENDS)
            self.state = 1297
            self.types()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImplementsClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IMPLEMENTS(self):
            return self.getToken(NeoBasicParser.IMPLEMENTS, 0)

        def types(self):
            return self.getTypedRuleContext(NeoBasicParser.TypesContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_implementsClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImplementsClause" ):
                listener.enterImplementsClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImplementsClause" ):
                listener.exitImplementsClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImplementsClause" ):
                return visitor.visitImplementsClause(self)
            else:
                return visitor.visitChildren(self)




    def implementsClause(self):

        localctx = NeoBasicParser.ImplementsClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_implementsClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1299
            self.match(NeoBasicParser.IMPLEMENTS)
            self.state = 1300
            self.types()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MixesClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MIXES(self):
            return self.getToken(NeoBasicParser.MIXES, 0)

        def types(self):
            return self.getTypedRuleContext(NeoBasicParser.TypesContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_mixesClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMixesClause" ):
                listener.enterMixesClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMixesClause" ):
                listener.exitMixesClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMixesClause" ):
                return visitor.visitMixesClause(self)
            else:
                return visitor.visitChildren(self)




    def mixesClause(self):

        localctx = NeoBasicParser.MixesClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_mixesClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1302
            self.match(NeoBasicParser.MIXES)
            self.state = 1303
            self.types()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RaisesClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOPANIC(self):
            return self.getToken(NeoBasicParser.NOPANIC, 0)

        def RAISES(self):
            return self.getToken(NeoBasicParser.RAISES, 0)

        def types(self):
            return self.getTypedRuleContext(NeoBasicParser.TypesContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_raisesClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRaisesClause" ):
                listener.enterRaisesClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRaisesClause" ):
                listener.exitRaisesClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRaisesClause" ):
                return visitor.visitRaisesClause(self)
            else:
                return visitor.visitChildren(self)




    def raisesClause(self):

        localctx = NeoBasicParser.RaisesClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_raisesClause)
        try:
            self.state = 1308
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [42]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1305
                self.match(NeoBasicParser.NOPANIC)
                pass
            elif token in [41]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1306
                self.match(NeoBasicParser.RAISES)
                self.state = 1307
                self.types()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParenthesizedArgumentsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LEFT_PARENTHESIS, 0)

        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def namedArguments(self):
            return self.getTypedRuleContext(NeoBasicParser.NamedArgumentsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_parenthesizedArguments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenthesizedArguments" ):
                listener.enterParenthesizedArguments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenthesizedArguments" ):
                listener.exitParenthesizedArguments(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenthesizedArguments" ):
                return visitor.visitParenthesizedArguments(self)
            else:
                return visitor.visitChildren(self)




    def parenthesizedArguments(self):

        localctx = NeoBasicParser.ParenthesizedArgumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_parenthesizedArguments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1310
            self.match(NeoBasicParser.LEFT_PARENTHESIS)
            self.state = 1312
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1649529585664) != 0) or ((((_la - 127)) & ~0x3f) == 0 and ((1 << (_la - 127)) & -257706303489) != 0) or ((((_la - 191)) & ~0x3f) == 0 and ((1 << (_la - 191)) & -1) != 0) or ((((_la - 255)) & ~0x3f) == 0 and ((1 << (_la - 255)) & 18014398507384831) != 0) or ((((_la - 321)) & ~0x3f) == 0 and ((1 << (_la - 321)) & 2814750039736063) != 0) or ((((_la - 415)) & ~0x3f) == 0 and ((1 << (_la - 415)) & 47287830447128569) != 0) or ((((_la - 485)) & ~0x3f) == 0 and ((1 << (_la - 485)) & 6151) != 0):
                self.state = 1311
                self.namedArguments()


            self.state = 1314
            self.match(NeoBasicParser.RIGHT_PARENTHESIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamedArgumentsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def namedArgument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.NamedArgumentContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.NamedArgumentContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_namedArguments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNamedArguments" ):
                listener.enterNamedArguments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNamedArguments" ):
                listener.exitNamedArguments(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNamedArguments" ):
                return visitor.visitNamedArguments(self)
            else:
                return visitor.visitChildren(self)




    def namedArguments(self):

        localctx = NeoBasicParser.NamedArgumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_namedArguments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1316
            self.namedArgument()
            self.state = 1321
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==473:
                self.state = 1317
                self.match(NeoBasicParser.COMMA)
                self.state = 1318
                self.namedArgument()
                self.state = 1323
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamedArgumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def IDENTIFIER(self):
            return self.getToken(NeoBasicParser.IDENTIFIER, 0)

        def EQUAL(self):
            return self.getToken(NeoBasicParser.EQUAL, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_namedArgument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNamedArgument" ):
                listener.enterNamedArgument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNamedArgument" ):
                listener.exitNamedArgument(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNamedArgument" ):
                return visitor.visitNamedArgument(self)
            else:
                return visitor.visitChildren(self)




    def namedArgument(self):

        localctx = NeoBasicParser.NamedArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_namedArgument)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1326
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
            if la_ == 1:
                self.state = 1324
                self.match(NeoBasicParser.IDENTIFIER)
                self.state = 1325
                self.match(NeoBasicParser.EQUAL)


            self.state = 1328
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParenthesizedParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LEFT_PARENTHESIS, 0)

        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def procParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcParametersContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_parenthesizedParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenthesizedParameters" ):
                listener.enterParenthesizedParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenthesizedParameters" ):
                listener.exitParenthesizedParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenthesizedParameters" ):
                return visitor.visitParenthesizedParameters(self)
            else:
                return visitor.visitChildren(self)




    def parenthesizedParameters(self):

        localctx = NeoBasicParser.ParenthesizedParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_parenthesizedParameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1330
            self.match(NeoBasicParser.LEFT_PARENTHESIS)
            self.state = 1332
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==330 or ((((_la - 415)) & ~0x3f) == 0 and ((1 << (_la - 415)) & 7) != 0) or _la==482 or _la==484:
                self.state = 1331
                self.procParameters()


            self.state = 1334
            self.match(NeoBasicParser.RIGHT_PARENTHESIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def procParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ProcParameterContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ProcParameterContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_procParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcParameters" ):
                listener.enterProcParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcParameters" ):
                listener.exitProcParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcParameters" ):
                return visitor.visitProcParameters(self)
            else:
                return visitor.visitChildren(self)




    def procParameters(self):

        localctx = NeoBasicParser.ProcParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_procParameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1336
            self.procParameter()
            self.state = 1341
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==473:
                self.state = 1337
                self.match(NeoBasicParser.COMMA)
                self.state = 1338
                self.procParameter()
                self.state = 1343
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(NeoBasicParser.IDENTIFIER, 0)

        def metadataDecorators(self):
            return self.getTypedRuleContext(NeoBasicParser.MetadataDecoratorsContext,0)


        def prefixParameterName(self):
            return self.getTypedRuleContext(NeoBasicParser.PrefixParameterNameContext,0)


        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def EQUAL(self):
            return self.getToken(NeoBasicParser.EQUAL, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def prefixParameterType(self):
            return self.getTypedRuleContext(NeoBasicParser.PrefixParameterTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_procParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcParameter" ):
                listener.enterProcParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcParameter" ):
                listener.exitProcParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcParameter" ):
                return visitor.visitProcParameter(self)
            else:
                return visitor.visitChildren(self)




    def procParameter(self):

        localctx = NeoBasicParser.ProcParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_procParameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1345
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==416 or _la==417:
                self.state = 1344
                self.metadataDecorators()


            self.state = 1348
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==330 or _la==482 or _la==484:
                self.state = 1347
                self.prefixParameterName()


            self.state = 1350
            self.match(NeoBasicParser.IDENTIFIER)
            self.state = 1355
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,60,self._ctx)
            if la_ == 1:
                self.state = 1352
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 328)) & ~0x3f) == 0 and ((1 << (_la - 328)) & 4398046511107) != 0) or _la==475:
                    self.state = 1351
                    self.prefixParameterType()


                self.state = 1354
                self.type_(0)


            self.state = 1359
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==389:
                self.state = 1357
                self.match(NeoBasicParser.EQUAL)
                self.state = 1358
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrefixParameterNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AMPERSAND(self):
            return self.getToken(NeoBasicParser.AMPERSAND, 0)

        def ASTERISK(self):
            return self.getToken(NeoBasicParser.ASTERISK, 0)

        def TILDE(self):
            return self.getToken(NeoBasicParser.TILDE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_prefixParameterName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrefixParameterName" ):
                listener.enterPrefixParameterName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrefixParameterName" ):
                listener.exitPrefixParameterName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrefixParameterName" ):
                return visitor.visitPrefixParameterName(self)
            else:
                return visitor.visitChildren(self)




    def prefixParameterName(self):

        localctx = NeoBasicParser.PrefixParameterNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_prefixParameterName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1361
            _la = self._input.LA(1)
            if not(_la==330 or _la==482 or _la==484):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrefixParameterTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAMED_ARGUMENTS(self):
            return self.getToken(NeoBasicParser.NAMED_ARGUMENTS, 0)

        def ELLIPSIS(self):
            return self.getToken(NeoBasicParser.ELLIPSIS, 0)

        def INTERVAL_INCLUSIVE(self):
            return self.getToken(NeoBasicParser.INTERVAL_INCLUSIVE, 0)

        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_prefixParameterType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrefixParameterType" ):
                listener.enterPrefixParameterType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrefixParameterType" ):
                listener.exitPrefixParameterType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrefixParameterType" ):
                return visitor.visitPrefixParameterType(self)
            else:
                return visitor.visitChildren(self)




    def prefixParameterType(self):

        localctx = NeoBasicParser.PrefixParameterTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_prefixParameterType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1363
            _la = self._input.LA(1)
            if not(((((_la - 328)) & ~0x3f) == 0 and ((1 << (_la - 328)) & 4398046511107) != 0) or _la==475):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcResultTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def types(self):
            return self.getTypedRuleContext(NeoBasicParser.TypesContext,0)


        def LEFT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LEFT_PARENTHESIS, 0)

        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_procResultType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcResultType" ):
                listener.enterProcResultType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcResultType" ):
                listener.exitProcResultType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcResultType" ):
                return visitor.visitProcResultType(self)
            else:
                return visitor.visitChildren(self)




    def procResultType(self):

        localctx = NeoBasicParser.ProcResultTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_procResultType)
        try:
            self.state = 1371
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,62,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1365
                self.type_(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1366
                self.types()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1367
                self.match(NeoBasicParser.LEFT_PARENTHESIS)
                self.state = 1368
                self.types()
                self.state = 1369
                self.match(NeoBasicParser.RIGHT_PARENTHESIS)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def procSemex(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcSemexContext,0)


        def procImplicitReturn(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcImplicitReturnContext,0)


        def procPatternGuards(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcPatternGuardsContext,0)


        def procSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_procBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcBody" ):
                listener.enterProcBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcBody" ):
                listener.exitProcBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcBody" ):
                return visitor.visitProcBody(self)
            else:
                return visitor.visitChildren(self)




    def procBody(self):

        localctx = NeoBasicParser.ProcBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_procBody)
        try:
            self.state = 1377
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,63,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1373
                self.procSemex()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1374
                self.procImplicitReturn()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1375
                self.procPatternGuards()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1376
                self.procSuite()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_procSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcSuite" ):
                listener.enterProcSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcSuite" ):
                listener.exitProcSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcSuite" ):
                return visitor.visitProcSuite(self)
            else:
                return visitor.visitChildren(self)




    def procSuite(self):

        localctx = NeoBasicParser.ProcSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_procSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1379
            self.logicalInstructionSuite()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcSemexContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def procSpecifier(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcSpecifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_procSemex

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcSemex" ):
                listener.enterProcSemex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcSemex" ):
                listener.exitProcSemex(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcSemex" ):
                return visitor.visitProcSemex(self)
            else:
                return visitor.visitChildren(self)




    def procSemex(self):

        localctx = NeoBasicParser.ProcSemexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_procSemex)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1381
            self.match(NeoBasicParser.COLON)
            self.state = 1382
            self.procSpecifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcSpecifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFAULT(self):
            return self.getToken(NeoBasicParser.DEFAULT, 0)

        def DELETE(self):
            return self.getToken(NeoBasicParser.DELETE, 0)

        def ABSTRACT(self):
            return self.getToken(NeoBasicParser.ABSTRACT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_procSpecifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcSpecifier" ):
                listener.enterProcSpecifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcSpecifier" ):
                listener.exitProcSpecifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcSpecifier" ):
                return visitor.visitProcSpecifier(self)
            else:
                return visitor.visitChildren(self)




    def procSpecifier(self):

        localctx = NeoBasicParser.ProcSpecifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_procSpecifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1384
            _la = self._input.LA(1)
            if not(((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 562949953423361) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcImplicitReturnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IMPLICIT_RETURN(self):
            return self.getToken(NeoBasicParser.IMPLICIT_RETURN, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_procImplicitReturn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcImplicitReturn" ):
                listener.enterProcImplicitReturn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcImplicitReturn" ):
                listener.exitProcImplicitReturn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcImplicitReturn" ):
                return visitor.visitProcImplicitReturn(self)
            else:
                return visitor.visitChildren(self)




    def procImplicitReturn(self):

        localctx = NeoBasicParser.ProcImplicitReturnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_procImplicitReturn)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1386
            self.match(NeoBasicParser.IMPLICIT_RETURN)
            self.state = 1387
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcPatternGuardsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def guardBranchClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.GuardBranchClauseContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.GuardBranchClauseContext,i)


        def guardElseClause(self):
            return self.getTypedRuleContext(NeoBasicParser.GuardElseClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_procPatternGuards

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcPatternGuards" ):
                listener.enterProcPatternGuards(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcPatternGuards" ):
                listener.exitProcPatternGuards(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcPatternGuards" ):
                return visitor.visitProcPatternGuards(self)
            else:
                return visitor.visitChildren(self)




    def procPatternGuards(self):

        localctx = NeoBasicParser.ProcPatternGuardsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_procPatternGuards)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1390 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1389
                    self.guardBranchClause()

                else:
                    raise NoViableAltException(self)
                self.state = 1392 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,64,self._ctx)

            self.state = 1395
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,65,self._ctx)
            if la_ == 1:
                self.state = 1394
                self.guardElseClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GuardBranchClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def PIPE(self):
            return self.getToken(NeoBasicParser.PIPE, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def IMPLICIT_RETURN(self):
            return self.getToken(NeoBasicParser.IMPLICIT_RETURN, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_guardBranchClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGuardBranchClause" ):
                listener.enterGuardBranchClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGuardBranchClause" ):
                listener.exitGuardBranchClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGuardBranchClause" ):
                return visitor.visitGuardBranchClause(self)
            else:
                return visitor.visitChildren(self)




    def guardBranchClause(self):

        localctx = NeoBasicParser.GuardBranchClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_guardBranchClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1397
            self.match(NeoBasicParser.EOS)
            self.state = 1398
            self.match(NeoBasicParser.PIPE)
            self.state = 1399
            self.expressions()
            self.state = 1400
            self.match(NeoBasicParser.IMPLICIT_RETURN)
            self.state = 1401
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GuardElseClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def PIPE(self):
            return self.getToken(NeoBasicParser.PIPE, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def ELSE(self):
            return self.getToken(NeoBasicParser.ELSE, 0)

        def IMPLICIT_RETURN(self):
            return self.getToken(NeoBasicParser.IMPLICIT_RETURN, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_guardElseClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGuardElseClause" ):
                listener.enterGuardElseClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGuardElseClause" ):
                listener.exitGuardElseClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGuardElseClause" ):
                return visitor.visitGuardElseClause(self)
            else:
                return visitor.visitChildren(self)




    def guardElseClause(self):

        localctx = NeoBasicParser.GuardElseClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_guardElseClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1403
            self.match(NeoBasicParser.EOS)
            self.state = 1404
            self.match(NeoBasicParser.PIPE)
            self.state = 1407
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==80:
                self.state = 1405
                self.match(NeoBasicParser.ELSE)
                self.state = 1406
                self.match(NeoBasicParser.IMPLICIT_RETURN)


            self.state = 1409
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OuterDeclareSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeSentenceContext,0)


        def constSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.ConstSentenceContext,0)


        def ivalSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.IvalSentenceContext,0)


        def varSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.VarSentenceContext,0)


        def factSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.FactSentenceContext,0)


        def funcSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.FuncSentenceContext,0)


        def feedSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.FeedSentenceContext,0)


        def subSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.SubSentenceContext,0)


        def operatorSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.OperatorSentenceContext,0)


        def eventSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.EventSentenceContext,0)


        def enumSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.EnumSentenceContext,0)


        def structSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.StructSentenceContext,0)


        def protoSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.ProtoSentenceContext,0)


        def traitSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.TraitSentenceContext,0)


        def classSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.ClassSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_outerDeclareSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOuterDeclareSentence" ):
                listener.enterOuterDeclareSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOuterDeclareSentence" ):
                listener.exitOuterDeclareSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOuterDeclareSentence" ):
                return visitor.visitOuterDeclareSentence(self)
            else:
                return visitor.visitChildren(self)




    def outerDeclareSentence(self):

        localctx = NeoBasicParser.OuterDeclareSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_outerDeclareSentence)
        try:
            self.state = 1426
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [20]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1411
                self.typeSentence()
                pass
            elif token in [17]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1412
                self.constSentence()
                pass
            elif token in [18]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1413
                self.ivalSentence()
                pass
            elif token in [19]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1414
                self.varSentence()
                pass
            elif token in [21]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1415
                self.factSentence()
                pass
            elif token in [23]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1416
                self.funcSentence()
                pass
            elif token in [24]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1417
                self.feedSentence()
                pass
            elif token in [25]:
                self.enterOuterAlt(localctx, 8)
                self.state = 1418
                self.subSentence()
                pass
            elif token in [26]:
                self.enterOuterAlt(localctx, 9)
                self.state = 1419
                self.operatorSentence()
                pass
            elif token in [27]:
                self.enterOuterAlt(localctx, 10)
                self.state = 1420
                self.eventSentence()
                pass
            elif token in [22]:
                self.enterOuterAlt(localctx, 11)
                self.state = 1421
                self.enumSentence()
                pass
            elif token in [28]:
                self.enterOuterAlt(localctx, 12)
                self.state = 1422
                self.structSentence()
                pass
            elif token in [29]:
                self.enterOuterAlt(localctx, 13)
                self.state = 1423
                self.protoSentence()
                pass
            elif token in [30]:
                self.enterOuterAlt(localctx, 14)
                self.state = 1424
                self.traitSentence()
                pass
            elif token in [31]:
                self.enterOuterAlt(localctx, 15)
                self.state = 1425
                self.classSentence()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeClause(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_typeSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeSentence" ):
                listener.enterTypeSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeSentence" ):
                listener.exitTypeSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeSentence" ):
                return visitor.visitTypeSentence(self)
            else:
                return visitor.visitChildren(self)




    def typeSentence(self):

        localctx = NeoBasicParser.TypeSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_typeSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1428
            self.typeClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPE(self):
            return self.getToken(NeoBasicParser.TYPE, 0)

        def typeSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeSuiteContext,0)


        def typeDeclare(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeDeclareContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_typeClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeClause" ):
                listener.enterTypeClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeClause" ):
                listener.exitTypeClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeClause" ):
                return visitor.visitTypeClause(self)
            else:
                return visitor.visitChildren(self)




    def typeClause(self):

        localctx = NeoBasicParser.TypeClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_typeClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1430
            self.match(NeoBasicParser.TYPE)
            self.state = 1433
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [457]:
                self.state = 1431
                self.typeSuite()
                pass
            elif token in [415, 416, 417]:
                self.state = 1432
                self.typeDeclare()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def typeDeclareBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeDeclareBlockContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_typeSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeSuite" ):
                listener.enterTypeSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeSuite" ):
                listener.exitTypeSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeSuite" ):
                return visitor.visitTypeSuite(self)
            else:
                return visitor.visitChildren(self)




    def typeSuite(self):

        localctx = NeoBasicParser.TypeSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_typeSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1435
            self.match(NeoBasicParser.EOS)
            self.state = 1436
            self.match(NeoBasicParser.INDENT)
            self.state = 1437
            self.typeDeclareBlock()
            self.state = 1438
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeDeclareBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeDeclare(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.TypeDeclareContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.TypeDeclareContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_typeDeclareBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeDeclareBlock" ):
                listener.enterTypeDeclareBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeDeclareBlock" ):
                listener.exitTypeDeclareBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeDeclareBlock" ):
                return visitor.visitTypeDeclareBlock(self)
            else:
                return visitor.visitChildren(self)




    def typeDeclareBlock(self):

        localctx = NeoBasicParser.TypeDeclareBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_typeDeclareBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1440
            self.typeDeclare()
            self.state = 1445
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==457:
                self.state = 1441
                self.match(NeoBasicParser.EOS)
                self.state = 1442
                self.typeDeclare()
                self.state = 1447
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeDeclareContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeDeclareSingle(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeDeclareSingleContext,0)


        def typeDeclareSubrange(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeDeclareSubrangeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_typeDeclare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeDeclare" ):
                listener.enterTypeDeclare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeDeclare" ):
                listener.exitTypeDeclare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeDeclare" ):
                return visitor.visitTypeDeclare(self)
            else:
                return visitor.visitChildren(self)




    def typeDeclare(self):

        localctx = NeoBasicParser.TypeDeclareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_typeDeclare)
        try:
            self.state = 1450
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1448
                self.typeDeclareSingle()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1449
                self.typeDeclareSubrange()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeDeclareSingleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def genericDecoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.GenericDecoratedIdentifierContext,0)


        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def IS(self):
            return self.getToken(NeoBasicParser.IS, 0)

        def ANCESTOROF(self):
            return self.getToken(NeoBasicParser.ANCESTOROF, 0)

        def EXTENDS(self):
            return self.getToken(NeoBasicParser.EXTENDS, 0)

        def IMPLEMENTS(self):
            return self.getToken(NeoBasicParser.IMPLEMENTS, 0)

        def MIXES(self):
            return self.getToken(NeoBasicParser.MIXES, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_typeDeclareSingle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeDeclareSingle" ):
                listener.enterTypeDeclareSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeDeclareSingle" ):
                listener.exitTypeDeclareSingle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeDeclareSingle" ):
                return visitor.visitTypeDeclareSingle(self)
            else:
                return visitor.visitChildren(self)




    def typeDeclareSingle(self):

        localctx = NeoBasicParser.TypeDeclareSingleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_typeDeclareSingle)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1452
            self.genericDecoratedIdentifier()
            self.state = 1453
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 60129542144) != 0) or _la==145 or _la==146):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1454
            self.type_(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeDeclareSubrangeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def genericDecoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.GenericDecoratedIdentifierContext,0)


        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def rangeLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.RangeLiteralContext,0)


        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_typeDeclareSubrange

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeDeclareSubrange" ):
                listener.enterTypeDeclareSubrange(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeDeclareSubrange" ):
                listener.exitTypeDeclareSubrange(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeDeclareSubrange" ):
                return visitor.visitTypeDeclareSubrange(self)
            else:
                return visitor.visitChildren(self)




    def typeDeclareSubrange(self):

        localctx = NeoBasicParser.TypeDeclareSubrangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_typeDeclareSubrange)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1456
            self.genericDecoratedIdentifier()
            self.state = 1458
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1649529585664) != 0) or ((((_la - 165)) & ~0x3f) == 0 and ((1 << (_la - 165)) & -1) != 0) or ((((_la - 229)) & ~0x3f) == 0 and ((1 << (_la - 229)) & 33554431) != 0) or ((((_la - 297)) & ~0x3f) == 0 and ((1 << (_la - 297)) & 585) != 0) or _la==415 or _la==468:
                self.state = 1457
                self.type_(0)


            self.state = 1460
            self.match(NeoBasicParser.COLON)
            self.state = 1461
            self.rangeLiteral()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ConstClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_constSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstSentence" ):
                listener.enterConstSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstSentence" ):
                listener.exitConstSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstSentence" ):
                return visitor.visitConstSentence(self)
            else:
                return visitor.visitChildren(self)




    def constSentence(self):

        localctx = NeoBasicParser.ConstSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_constSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1463
            self.constClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONST(self):
            return self.getToken(NeoBasicParser.CONST, 0)

        def constSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.ConstSuiteContext,0)


        def constDeclare(self):
            return self.getTypedRuleContext(NeoBasicParser.ConstDeclareContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_constClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstClause" ):
                listener.enterConstClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstClause" ):
                listener.exitConstClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstClause" ):
                return visitor.visitConstClause(self)
            else:
                return visitor.visitChildren(self)




    def constClause(self):

        localctx = NeoBasicParser.ConstClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_constClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1465
            self.match(NeoBasicParser.CONST)
            self.state = 1468
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [457]:
                self.state = 1466
                self.constSuite()
                pass
            elif token in [415, 416, 417, 466]:
                self.state = 1467
                self.constDeclare()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def constDeclareBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.ConstDeclareBlockContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_constSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstSuite" ):
                listener.enterConstSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstSuite" ):
                listener.exitConstSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstSuite" ):
                return visitor.visitConstSuite(self)
            else:
                return visitor.visitChildren(self)




    def constSuite(self):

        localctx = NeoBasicParser.ConstSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_constSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1470
            self.match(NeoBasicParser.EOS)
            self.state = 1471
            self.match(NeoBasicParser.INDENT)
            self.state = 1472
            self.constDeclareBlock()
            self.state = 1473
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstDeclareBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constDeclare(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ConstDeclareContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ConstDeclareContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_constDeclareBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstDeclareBlock" ):
                listener.enterConstDeclareBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstDeclareBlock" ):
                listener.exitConstDeclareBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstDeclareBlock" ):
                return visitor.visitConstDeclareBlock(self)
            else:
                return visitor.visitChildren(self)




    def constDeclareBlock(self):

        localctx = NeoBasicParser.ConstDeclareBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_constDeclareBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1475
            self.constDeclare()
            self.state = 1480
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==457:
                self.state = 1476
                self.match(NeoBasicParser.EOS)
                self.state = 1477
                self.constDeclare()
                self.state = 1482
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstDeclareContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constDeclareSingle(self):
            return self.getTypedRuleContext(NeoBasicParser.ConstDeclareSingleContext,0)


        def constDeclareMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.ConstDeclareMultipleContext,0)


        def constDeclareParallel(self):
            return self.getTypedRuleContext(NeoBasicParser.ConstDeclareParallelContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_constDeclare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstDeclare" ):
                listener.enterConstDeclare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstDeclare" ):
                listener.exitConstDeclare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstDeclare" ):
                return visitor.visitConstDeclare(self)
            else:
                return visitor.visitChildren(self)




    def constDeclare(self):

        localctx = NeoBasicParser.ConstDeclareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_constDeclare)
        try:
            self.state = 1486
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,74,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1483
                self.constDeclareSingle()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1484
                self.constDeclareMultiple()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1485
                self.constDeclareParallel()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstDeclareSingleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def inferredDecoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifierContext,0)


        def singleAssignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.SingleAssignmentOperatorContext,0)


        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_constDeclareSingle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstDeclareSingle" ):
                listener.enterConstDeclareSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstDeclareSingle" ):
                listener.exitConstDeclareSingle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstDeclareSingle" ):
                return visitor.visitConstDeclareSingle(self)
            else:
                return visitor.visitChildren(self)




    def constDeclareSingle(self):

        localctx = NeoBasicParser.ConstDeclareSingleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_constDeclareSingle)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1488
            self.inferredDecoratedIdentifier()
            self.state = 1489
            self.singleAssignmentOperator()
            self.state = 1490
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstDeclareMultipleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constDeclareSingle(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ConstDeclareSingleContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ConstDeclareSingleContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def INDENT(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.INDENT)
            else:
                return self.getToken(NeoBasicParser.INDENT, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_constDeclareMultiple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstDeclareMultiple" ):
                listener.enterConstDeclareMultiple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstDeclareMultiple" ):
                listener.exitConstDeclareMultiple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstDeclareMultiple" ):
                return visitor.visitConstDeclareMultiple(self)
            else:
                return visitor.visitChildren(self)




    def constDeclareMultiple(self):

        localctx = NeoBasicParser.ConstDeclareMultipleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 222, self.RULE_constDeclareMultiple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1492
            self.constDeclareSingle()
            self.state = 1497 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1493
                self.match(NeoBasicParser.COMMA)
                self.state = 1494
                self.constDeclareSingle()
                self.state = 1495
                self.match(NeoBasicParser.INDENT)
                self.state = 1499 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==473):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstDeclareParallelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LEFT_PARENTHESIS, 0)

        def inferredDecoratedIdentifiers(self):
            return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifiersContext,0)


        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def unpackingAssignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnpackingAssignmentOperatorContext,0)


        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_constDeclareParallel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstDeclareParallel" ):
                listener.enterConstDeclareParallel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstDeclareParallel" ):
                listener.exitConstDeclareParallel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstDeclareParallel" ):
                return visitor.visitConstDeclareParallel(self)
            else:
                return visitor.visitChildren(self)




    def constDeclareParallel(self):

        localctx = NeoBasicParser.ConstDeclareParallelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_constDeclareParallel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1501
            self.match(NeoBasicParser.LEFT_PARENTHESIS)
            self.state = 1502
            self.inferredDecoratedIdentifiers()
            self.state = 1503
            self.match(NeoBasicParser.RIGHT_PARENTHESIS)
            self.state = 1504
            self.unpackingAssignmentOperator()
            self.state = 1505
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IvalSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ivalClause(self):
            return self.getTypedRuleContext(NeoBasicParser.IvalClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_ivalSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIvalSentence" ):
                listener.enterIvalSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIvalSentence" ):
                listener.exitIvalSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIvalSentence" ):
                return visitor.visitIvalSentence(self)
            else:
                return visitor.visitChildren(self)




    def ivalSentence(self):

        localctx = NeoBasicParser.IvalSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_ivalSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1507
            self.ivalClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IvalClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IVAL(self):
            return self.getToken(NeoBasicParser.IVAL, 0)

        def ivalSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.IvalSuiteContext,0)


        def ivalDeclare(self):
            return self.getTypedRuleContext(NeoBasicParser.IvalDeclareContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_ivalClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIvalClause" ):
                listener.enterIvalClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIvalClause" ):
                listener.exitIvalClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIvalClause" ):
                return visitor.visitIvalClause(self)
            else:
                return visitor.visitChildren(self)




    def ivalClause(self):

        localctx = NeoBasicParser.IvalClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_ivalClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1509
            self.match(NeoBasicParser.IVAL)
            self.state = 1512
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [457]:
                self.state = 1510
                self.ivalSuite()
                pass
            elif token in [415, 416, 417, 466]:
                self.state = 1511
                self.ivalDeclare()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IvalSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def ivalDeclareBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.IvalDeclareBlockContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_ivalSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIvalSuite" ):
                listener.enterIvalSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIvalSuite" ):
                listener.exitIvalSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIvalSuite" ):
                return visitor.visitIvalSuite(self)
            else:
                return visitor.visitChildren(self)




    def ivalSuite(self):

        localctx = NeoBasicParser.IvalSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_ivalSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1514
            self.match(NeoBasicParser.EOS)
            self.state = 1515
            self.match(NeoBasicParser.INDENT)
            self.state = 1516
            self.ivalDeclareBlock()
            self.state = 1517
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IvalDeclareBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ivalDeclare(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.IvalDeclareContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.IvalDeclareContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_ivalDeclareBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIvalDeclareBlock" ):
                listener.enterIvalDeclareBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIvalDeclareBlock" ):
                listener.exitIvalDeclareBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIvalDeclareBlock" ):
                return visitor.visitIvalDeclareBlock(self)
            else:
                return visitor.visitChildren(self)




    def ivalDeclareBlock(self):

        localctx = NeoBasicParser.IvalDeclareBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_ivalDeclareBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1519
            self.ivalDeclare()
            self.state = 1524
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==457:
                self.state = 1520
                self.match(NeoBasicParser.EOS)
                self.state = 1521
                self.ivalDeclare()
                self.state = 1526
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IvalDeclareContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ivalDeclareSingle(self):
            return self.getTypedRuleContext(NeoBasicParser.IvalDeclareSingleContext,0)


        def ivalDeclareMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.IvalDeclareMultipleContext,0)


        def ivalDeclareParallel(self):
            return self.getTypedRuleContext(NeoBasicParser.IvalDeclareParallelContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_ivalDeclare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIvalDeclare" ):
                listener.enterIvalDeclare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIvalDeclare" ):
                listener.exitIvalDeclare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIvalDeclare" ):
                return visitor.visitIvalDeclare(self)
            else:
                return visitor.visitChildren(self)




    def ivalDeclare(self):

        localctx = NeoBasicParser.IvalDeclareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_ivalDeclare)
        try:
            self.state = 1530
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,78,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1527
                self.ivalDeclareSingle()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1528
                self.ivalDeclareMultiple()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1529
                self.ivalDeclareParallel()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IvalDeclareSingleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def inferredDecoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifierContext,0)


        def singleAssignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.SingleAssignmentOperatorContext,0)


        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_ivalDeclareSingle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIvalDeclareSingle" ):
                listener.enterIvalDeclareSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIvalDeclareSingle" ):
                listener.exitIvalDeclareSingle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIvalDeclareSingle" ):
                return visitor.visitIvalDeclareSingle(self)
            else:
                return visitor.visitChildren(self)




    def ivalDeclareSingle(self):

        localctx = NeoBasicParser.IvalDeclareSingleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_ivalDeclareSingle)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1532
            self.inferredDecoratedIdentifier()
            self.state = 1536
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 389)) & ~0x3f) == 0 and ((1 << (_la - 389)) & 31) != 0):
                self.state = 1533
                self.singleAssignmentOperator()
                self.state = 1534
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IvalDeclareMultipleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ivalDeclareSingle(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.IvalDeclareSingleContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.IvalDeclareSingleContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_ivalDeclareMultiple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIvalDeclareMultiple" ):
                listener.enterIvalDeclareMultiple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIvalDeclareMultiple" ):
                listener.exitIvalDeclareMultiple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIvalDeclareMultiple" ):
                return visitor.visitIvalDeclareMultiple(self)
            else:
                return visitor.visitChildren(self)




    def ivalDeclareMultiple(self):

        localctx = NeoBasicParser.IvalDeclareMultipleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_ivalDeclareMultiple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1538
            self.ivalDeclareSingle()
            self.state = 1541 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1539
                self.match(NeoBasicParser.COMMA)
                self.state = 1540
                self.ivalDeclareSingle()
                self.state = 1543 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==473):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IvalDeclareParallelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LEFT_PARENTHESIS, 0)

        def inferredDecoratedIdentifiers(self):
            return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifiersContext,0)


        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def unpackingAssignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnpackingAssignmentOperatorContext,0)


        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_ivalDeclareParallel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIvalDeclareParallel" ):
                listener.enterIvalDeclareParallel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIvalDeclareParallel" ):
                listener.exitIvalDeclareParallel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIvalDeclareParallel" ):
                return visitor.visitIvalDeclareParallel(self)
            else:
                return visitor.visitChildren(self)




    def ivalDeclareParallel(self):

        localctx = NeoBasicParser.IvalDeclareParallelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_ivalDeclareParallel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1545
            self.match(NeoBasicParser.LEFT_PARENTHESIS)
            self.state = 1546
            self.inferredDecoratedIdentifiers()
            self.state = 1547
            self.match(NeoBasicParser.RIGHT_PARENTHESIS)
            self.state = 1548
            self.unpackingAssignmentOperator()
            self.state = 1549
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varClause(self):
            return self.getTypedRuleContext(NeoBasicParser.VarClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_varSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarSentence" ):
                listener.enterVarSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarSentence" ):
                listener.exitVarSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarSentence" ):
                return visitor.visitVarSentence(self)
            else:
                return visitor.visitChildren(self)




    def varSentence(self):

        localctx = NeoBasicParser.VarSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 242, self.RULE_varSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1551
            self.varClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAR(self):
            return self.getToken(NeoBasicParser.VAR, 0)

        def varSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.VarSuiteContext,0)


        def varDeclare(self):
            return self.getTypedRuleContext(NeoBasicParser.VarDeclareContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_varClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarClause" ):
                listener.enterVarClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarClause" ):
                listener.exitVarClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarClause" ):
                return visitor.visitVarClause(self)
            else:
                return visitor.visitChildren(self)




    def varClause(self):

        localctx = NeoBasicParser.VarClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 244, self.RULE_varClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1553
            self.match(NeoBasicParser.VAR)
            self.state = 1556
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [457]:
                self.state = 1554
                self.varSuite()
                pass
            elif token in [415, 416, 417, 466]:
                self.state = 1555
                self.varDeclare()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def varDeclareBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.VarDeclareBlockContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_varSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarSuite" ):
                listener.enterVarSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarSuite" ):
                listener.exitVarSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarSuite" ):
                return visitor.visitVarSuite(self)
            else:
                return visitor.visitChildren(self)




    def varSuite(self):

        localctx = NeoBasicParser.VarSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 246, self.RULE_varSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1558
            self.match(NeoBasicParser.EOS)
            self.state = 1559
            self.match(NeoBasicParser.INDENT)
            self.state = 1560
            self.varDeclareBlock()
            self.state = 1561
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarDeclareBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varDeclare(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.VarDeclareContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.VarDeclareContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_varDeclareBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarDeclareBlock" ):
                listener.enterVarDeclareBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarDeclareBlock" ):
                listener.exitVarDeclareBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarDeclareBlock" ):
                return visitor.visitVarDeclareBlock(self)
            else:
                return visitor.visitChildren(self)




    def varDeclareBlock(self):

        localctx = NeoBasicParser.VarDeclareBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 248, self.RULE_varDeclareBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1563
            self.varDeclare()
            self.state = 1568
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==457:
                self.state = 1564
                self.match(NeoBasicParser.EOS)
                self.state = 1565
                self.varDeclare()
                self.state = 1570
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarDeclareContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varDeclareSingle(self):
            return self.getTypedRuleContext(NeoBasicParser.VarDeclareSingleContext,0)


        def varDeclareMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.VarDeclareMultipleContext,0)


        def varDeclareParallel(self):
            return self.getTypedRuleContext(NeoBasicParser.VarDeclareParallelContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_varDeclare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarDeclare" ):
                listener.enterVarDeclare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarDeclare" ):
                listener.exitVarDeclare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarDeclare" ):
                return visitor.visitVarDeclare(self)
            else:
                return visitor.visitChildren(self)




    def varDeclare(self):

        localctx = NeoBasicParser.VarDeclareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 250, self.RULE_varDeclare)
        try:
            self.state = 1574
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1571
                self.varDeclareSingle()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1572
                self.varDeclareMultiple()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1573
                self.varDeclareParallel()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarDeclareSingleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def inferredDecoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifierContext,0)


        def singleAssignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.SingleAssignmentOperatorContext,0)


        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_varDeclareSingle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarDeclareSingle" ):
                listener.enterVarDeclareSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarDeclareSingle" ):
                listener.exitVarDeclareSingle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarDeclareSingle" ):
                return visitor.visitVarDeclareSingle(self)
            else:
                return visitor.visitChildren(self)




    def varDeclareSingle(self):

        localctx = NeoBasicParser.VarDeclareSingleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 252, self.RULE_varDeclareSingle)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1576
            self.inferredDecoratedIdentifier()
            self.state = 1580
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 389)) & ~0x3f) == 0 and ((1 << (_la - 389)) & 31) != 0):
                self.state = 1577
                self.singleAssignmentOperator()
                self.state = 1578
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarDeclareMultipleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def varDeclareSingle(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.VarDeclareSingleContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.VarDeclareSingleContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_varDeclareMultiple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarDeclareMultiple" ):
                listener.enterVarDeclareMultiple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarDeclareMultiple" ):
                listener.exitVarDeclareMultiple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarDeclareMultiple" ):
                return visitor.visitVarDeclareMultiple(self)
            else:
                return visitor.visitChildren(self)




    def varDeclareMultiple(self):

        localctx = NeoBasicParser.VarDeclareMultipleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 254, self.RULE_varDeclareMultiple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1582
            self.varDeclareSingle()
            self.state = 1585 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1583
                self.match(NeoBasicParser.COMMA)
                self.state = 1584
                self.varDeclareSingle()
                self.state = 1587 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==473):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarDeclareParallelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LEFT_PARENTHESIS, 0)

        def inferredDecoratedIdentifiers(self):
            return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifiersContext,0)


        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def unpackingAssignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnpackingAssignmentOperatorContext,0)


        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_varDeclareParallel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarDeclareParallel" ):
                listener.enterVarDeclareParallel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarDeclareParallel" ):
                listener.exitVarDeclareParallel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarDeclareParallel" ):
                return visitor.visitVarDeclareParallel(self)
            else:
                return visitor.visitChildren(self)




    def varDeclareParallel(self):

        localctx = NeoBasicParser.VarDeclareParallelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 256, self.RULE_varDeclareParallel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1589
            self.match(NeoBasicParser.LEFT_PARENTHESIS)
            self.state = 1590
            self.inferredDecoratedIdentifiers()
            self.state = 1591
            self.match(NeoBasicParser.RIGHT_PARENTHESIS)
            self.state = 1592
            self.unpackingAssignmentOperator()
            self.state = 1593
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FactSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def factClause(self):
            return self.getTypedRuleContext(NeoBasicParser.FactClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_factSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactSentence" ):
                listener.enterFactSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactSentence" ):
                listener.exitFactSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactSentence" ):
                return visitor.visitFactSentence(self)
            else:
                return visitor.visitChildren(self)




    def factSentence(self):

        localctx = NeoBasicParser.FactSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 258, self.RULE_factSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1595
            self.factClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FactClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FACT(self):
            return self.getToken(NeoBasicParser.FACT, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def procParameter(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcParameterContext,0)


        def procBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcBodyContext,0)


        def raisesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.RaisesClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_factClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactClause" ):
                listener.enterFactClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactClause" ):
                listener.exitFactClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactClause" ):
                return visitor.visitFactClause(self)
            else:
                return visitor.visitChildren(self)




    def factClause(self):

        localctx = NeoBasicParser.FactClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 260, self.RULE_factClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1597
            self.match(NeoBasicParser.FACT)
            self.state = 1598
            self.declarationIdentifier()
            self.state = 1599
            self.procParameter()
            self.state = 1601
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==41 or _la==42:
                self.state = 1600
                self.raisesClause()


            self.state = 1603
            self.procBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def funcClause(self):
            return self.getTypedRuleContext(NeoBasicParser.FuncClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_funcSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncSentence" ):
                listener.enterFuncSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncSentence" ):
                listener.exitFuncSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncSentence" ):
                return visitor.visitFuncSentence(self)
            else:
                return visitor.visitChildren(self)




    def funcSentence(self):

        localctx = NeoBasicParser.FuncSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 262, self.RULE_funcSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1605
            self.funcClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FUNC(self):
            return self.getToken(NeoBasicParser.FUNC, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def parenthesizedParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParametersContext,0)


        def procResultType(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcResultTypeContext,0)


        def raisesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.RaisesClauseContext,0)


        def procBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcBodyContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_funcClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncClause" ):
                listener.enterFuncClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncClause" ):
                listener.exitFuncClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncClause" ):
                return visitor.visitFuncClause(self)
            else:
                return visitor.visitChildren(self)




    def funcClause(self):

        localctx = NeoBasicParser.FuncClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 264, self.RULE_funcClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1607
            self.match(NeoBasicParser.FUNC)
            self.state = 1608
            self.declarationIdentifier()
            self.state = 1609
            self.parenthesizedParameters()
            self.state = 1610
            self.procResultType()
            self.state = 1612
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==41 or _la==42:
                self.state = 1611
                self.raisesClause()


            self.state = 1615
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,88,self._ctx)
            if la_ == 1:
                self.state = 1614
                self.procBody()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeedSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def feedClause(self):
            return self.getTypedRuleContext(NeoBasicParser.FeedClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_feedSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeedSentence" ):
                listener.enterFeedSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeedSentence" ):
                listener.exitFeedSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeedSentence" ):
                return visitor.visitFeedSentence(self)
            else:
                return visitor.visitChildren(self)




    def feedSentence(self):

        localctx = NeoBasicParser.FeedSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 266, self.RULE_feedSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1617
            self.feedClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeedClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FEED(self):
            return self.getToken(NeoBasicParser.FEED, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def parenthesizedParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParametersContext,0)


        def procResultType(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcResultTypeContext,0)


        def raisesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.RaisesClauseContext,0)


        def procBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcBodyContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_feedClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeedClause" ):
                listener.enterFeedClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeedClause" ):
                listener.exitFeedClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeedClause" ):
                return visitor.visitFeedClause(self)
            else:
                return visitor.visitChildren(self)




    def feedClause(self):

        localctx = NeoBasicParser.FeedClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 268, self.RULE_feedClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1619
            self.match(NeoBasicParser.FEED)
            self.state = 1620
            self.declarationIdentifier()
            self.state = 1621
            self.parenthesizedParameters()
            self.state = 1622
            self.procResultType()
            self.state = 1624
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==41 or _la==42:
                self.state = 1623
                self.raisesClause()


            self.state = 1627
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,90,self._ctx)
            if la_ == 1:
                self.state = 1626
                self.procBody()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subClause(self):
            return self.getTypedRuleContext(NeoBasicParser.SubClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_subSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubSentence" ):
                listener.enterSubSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubSentence" ):
                listener.exitSubSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubSentence" ):
                return visitor.visitSubSentence(self)
            else:
                return visitor.visitChildren(self)




    def subSentence(self):

        localctx = NeoBasicParser.SubSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 270, self.RULE_subSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1629
            self.subClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUB(self):
            return self.getToken(NeoBasicParser.SUB, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def parenthesizedParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParametersContext,0)


        def raisesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.RaisesClauseContext,0)


        def procBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcBodyContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_subClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubClause" ):
                listener.enterSubClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubClause" ):
                listener.exitSubClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubClause" ):
                return visitor.visitSubClause(self)
            else:
                return visitor.visitChildren(self)




    def subClause(self):

        localctx = NeoBasicParser.SubClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 272, self.RULE_subClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1631
            self.match(NeoBasicParser.SUB)
            self.state = 1632
            self.declarationIdentifier()
            self.state = 1633
            self.parenthesizedParameters()
            self.state = 1635
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==41 or _la==42:
                self.state = 1634
                self.raisesClause()


            self.state = 1638
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,92,self._ctx)
            if la_ == 1:
                self.state = 1637
                self.procBody()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperatorSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operatorClause(self):
            return self.getTypedRuleContext(NeoBasicParser.OperatorClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_operatorSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperatorSentence" ):
                listener.enterOperatorSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperatorSentence" ):
                listener.exitOperatorSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperatorSentence" ):
                return visitor.visitOperatorSentence(self)
            else:
                return visitor.visitChildren(self)




    def operatorSentence(self):

        localctx = NeoBasicParser.OperatorSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 274, self.RULE_operatorSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1640
            self.operatorClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperatorClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPERATOR(self):
            return self.getToken(NeoBasicParser.OPERATOR, 0)

        def operatorIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.OperatorIdentifierContext,0)


        def parenthesizedParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParametersContext,0)


        def procResultType(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcResultTypeContext,0)


        def raisesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.RaisesClauseContext,0)


        def procBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcBodyContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_operatorClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperatorClause" ):
                listener.enterOperatorClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperatorClause" ):
                listener.exitOperatorClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperatorClause" ):
                return visitor.visitOperatorClause(self)
            else:
                return visitor.visitChildren(self)




    def operatorClause(self):

        localctx = NeoBasicParser.OperatorClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 276, self.RULE_operatorClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1642
            self.match(NeoBasicParser.OPERATOR)
            self.state = 1643
            self.operatorIdentifier()
            self.state = 1644
            self.parenthesizedParameters()
            self.state = 1645
            self.procResultType()
            self.state = 1647
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==41 or _la==42:
                self.state = 1646
                self.raisesClause()


            self.state = 1650
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,94,self._ctx)
            if la_ == 1:
                self.state = 1649
                self.procBody()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperatorIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def declarationOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationOperatorContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_operatorIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperatorIdentifier" ):
                listener.enterOperatorIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperatorIdentifier" ):
                listener.exitOperatorIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperatorIdentifier" ):
                return visitor.visitOperatorIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def operatorIdentifier(self):

        localctx = NeoBasicParser.OperatorIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 278, self.RULE_operatorIdentifier)
        try:
            self.state = 1654
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,95,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1652
                self.declarationIdentifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1653
                self.declarationOperator()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def overloadableOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.OverloadableOperatorContext,0)


        def metadataDecorators(self):
            return self.getTypedRuleContext(NeoBasicParser.MetadataDecoratorsContext,0)


        def genericTypeParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.GenericTypeParametersContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_declarationOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclarationOperator" ):
                listener.enterDeclarationOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclarationOperator" ):
                listener.exitDeclarationOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeclarationOperator" ):
                return visitor.visitDeclarationOperator(self)
            else:
                return visitor.visitChildren(self)




    def declarationOperator(self):

        localctx = NeoBasicParser.DeclarationOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 280, self.RULE_declarationOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1657
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==416 or _la==417:
                self.state = 1656
                self.metadataDecorators()


            self.state = 1659
            self.overloadableOperator()
            self.state = 1661
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==349:
                self.state = 1660
                self.genericTypeParameters()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EventSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def eventClause(self):
            return self.getTypedRuleContext(NeoBasicParser.EventClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_eventSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEventSentence" ):
                listener.enterEventSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEventSentence" ):
                listener.exitEventSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEventSentence" ):
                return visitor.visitEventSentence(self)
            else:
                return visitor.visitChildren(self)




    def eventSentence(self):

        localctx = NeoBasicParser.EventSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 282, self.RULE_eventSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1663
            self.eventClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EventClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EVENT(self):
            return self.getToken(NeoBasicParser.EVENT, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def bracketedParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.BracketedParametersContext,0)


        def procResultType(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcResultTypeContext,0)


        def raisesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.RaisesClauseContext,0)


        def procBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcBodyContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_eventClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEventClause" ):
                listener.enterEventClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEventClause" ):
                listener.exitEventClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEventClause" ):
                return visitor.visitEventClause(self)
            else:
                return visitor.visitChildren(self)




    def eventClause(self):

        localctx = NeoBasicParser.EventClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 284, self.RULE_eventClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1665
            self.match(NeoBasicParser.EVENT)
            self.state = 1666
            self.declarationIdentifier()
            self.state = 1667
            self.bracketedParameters()
            self.state = 1668
            self.procResultType()
            self.state = 1670
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==41 or _la==42:
                self.state = 1669
                self.raisesClause()


            self.state = 1673
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,99,self._ctx)
            if la_ == 1:
                self.state = 1672
                self.procBody()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BracketedParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_BRACKET(self):
            return self.getToken(NeoBasicParser.LEFT_BRACKET, 0)

        def RIGHT_BRACKET(self):
            return self.getToken(NeoBasicParser.RIGHT_BRACKET, 0)

        def procParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcParametersContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_bracketedParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBracketedParameters" ):
                listener.enterBracketedParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBracketedParameters" ):
                listener.exitBracketedParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBracketedParameters" ):
                return visitor.visitBracketedParameters(self)
            else:
                return visitor.visitChildren(self)




    def bracketedParameters(self):

        localctx = NeoBasicParser.BracketedParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 286, self.RULE_bracketedParameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1675
            self.match(NeoBasicParser.LEFT_BRACKET)
            self.state = 1677
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==330 or ((((_la - 415)) & ~0x3f) == 0 and ((1 << (_la - 415)) & 7) != 0) or _la==482 or _la==484:
                self.state = 1676
                self.procParameters()


            self.state = 1679
            self.match(NeoBasicParser.RIGHT_BRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enumClause(self):
            return self.getTypedRuleContext(NeoBasicParser.EnumClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_enumSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumSentence" ):
                listener.enterEnumSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumSentence" ):
                listener.exitEnumSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumSentence" ):
                return visitor.visitEnumSentence(self)
            else:
                return visitor.visitChildren(self)




    def enumSentence(self):

        localctx = NeoBasicParser.EnumSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 288, self.RULE_enumSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1681
            self.enumClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENUM(self):
            return self.getToken(NeoBasicParser.ENUM, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def enumBody(self):
            return self.getTypedRuleContext(NeoBasicParser.EnumBodyContext,0)


        def parenthesizedParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParametersContext,0)


        def enumType(self):
            return self.getTypedRuleContext(NeoBasicParser.EnumTypeContext,0)


        def mixesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.MixesClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_enumClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumClause" ):
                listener.enterEnumClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumClause" ):
                listener.exitEnumClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumClause" ):
                return visitor.visitEnumClause(self)
            else:
                return visitor.visitChildren(self)




    def enumClause(self):

        localctx = NeoBasicParser.EnumClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 290, self.RULE_enumClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1683
            self.match(NeoBasicParser.ENUM)
            self.state = 1684
            self.declarationIdentifier()
            self.state = 1686
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==466:
                self.state = 1685
                self.parenthesizedParameters()


            self.state = 1689
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1649529585664) != 0) or ((((_la - 165)) & ~0x3f) == 0 and ((1 << (_la - 165)) & -1) != 0) or ((((_la - 229)) & ~0x3f) == 0 and ((1 << (_la - 229)) & 33554431) != 0) or ((((_la - 297)) & ~0x3f) == 0 and ((1 << (_la - 297)) & 585) != 0) or _la==415 or _la==468:
                self.state = 1688
                self.enumType()


            self.state = 1692
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==35:
                self.state = 1691
                self.mixesClause()


            self.state = 1694
            self.enumBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_enumType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumType" ):
                listener.enterEnumType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumType" ):
                listener.exitEnumType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumType" ):
                return visitor.visitEnumType(self)
            else:
                return visitor.visitChildren(self)




    def enumType(self):

        localctx = NeoBasicParser.EnumTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 292, self.RULE_enumType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1696
            self.type_(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enumSemex(self):
            return self.getTypedRuleContext(NeoBasicParser.EnumSemexContext,0)


        def enumSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.EnumSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_enumBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumBody" ):
                listener.enterEnumBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumBody" ):
                listener.exitEnumBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumBody" ):
                return visitor.visitEnumBody(self)
            else:
                return visitor.visitChildren(self)




    def enumBody(self):

        localctx = NeoBasicParser.EnumBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 294, self.RULE_enumBody)
        try:
            self.state = 1700
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [475]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1698
                self.enumSemex()
                pass
            elif token in [457]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1699
                self.enumSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumSemexContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def enumFieldMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.EnumFieldMultipleContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_enumSemex

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumSemex" ):
                listener.enterEnumSemex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumSemex" ):
                listener.exitEnumSemex(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumSemex" ):
                return visitor.visitEnumSemex(self)
            else:
                return visitor.visitChildren(self)




    def enumSemex(self):

        localctx = NeoBasicParser.EnumSemexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 296, self.RULE_enumSemex)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1702
            self.match(NeoBasicParser.COLON)
            self.state = 1703
            self.enumFieldMultiple()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def enumMembersBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.EnumMembersBlockContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_enumSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumSuite" ):
                listener.enterEnumSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumSuite" ):
                listener.exitEnumSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumSuite" ):
                return visitor.visitEnumSuite(self)
            else:
                return visitor.visitChildren(self)




    def enumSuite(self):

        localctx = NeoBasicParser.EnumSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 298, self.RULE_enumSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1705
            self.match(NeoBasicParser.EOS)
            self.state = 1706
            self.match(NeoBasicParser.INDENT)
            self.state = 1707
            self.enumMembersBlock()
            self.state = 1708
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumMembersBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enumMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.EnumMemberContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.EnumMemberContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_enumMembersBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumMembersBlock" ):
                listener.enterEnumMembersBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumMembersBlock" ):
                listener.exitEnumMembersBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumMembersBlock" ):
                return visitor.visitEnumMembersBlock(self)
            else:
                return visitor.visitChildren(self)




    def enumMembersBlock(self):

        localctx = NeoBasicParser.EnumMembersBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 300, self.RULE_enumMembersBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1710
            self.enumMember()
            self.state = 1715
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==457:
                self.state = 1711
                self.match(NeoBasicParser.EOS)
                self.state = 1712
                self.enumMember()
                self.state = 1717
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalInstruction(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionContext,0)


        def enumFieldSingle(self):
            return self.getTypedRuleContext(NeoBasicParser.EnumFieldSingleContext,0)


        def enumFieldMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.EnumFieldMultipleContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_enumMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumMember" ):
                listener.enterEnumMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumMember" ):
                listener.exitEnumMember(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumMember" ):
                return visitor.visitEnumMember(self)
            else:
                return visitor.visitChildren(self)




    def enumMember(self):

        localctx = NeoBasicParser.EnumMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 302, self.RULE_enumMember)
        try:
            self.state = 1721
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,106,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1718
                self.logicalInstruction()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1719
                self.enumFieldSingle()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1720
                self.enumFieldMultiple()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumFieldSingleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def decoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DecoratedIdentifierContext,0)


        def parenthesizedArguments(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedArgumentsContext,0)


        def EQUAL(self):
            return self.getToken(NeoBasicParser.EQUAL, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_enumFieldSingle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumFieldSingle" ):
                listener.enterEnumFieldSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumFieldSingle" ):
                listener.exitEnumFieldSingle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumFieldSingle" ):
                return visitor.visitEnumFieldSingle(self)
            else:
                return visitor.visitChildren(self)




    def enumFieldSingle(self):

        localctx = NeoBasicParser.EnumFieldSingleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 304, self.RULE_enumFieldSingle)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1723
            self.decoratedIdentifier()
            self.state = 1725
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==466:
                self.state = 1724
                self.parenthesizedArguments()


            self.state = 1729
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==389:
                self.state = 1727
                self.match(NeoBasicParser.EQUAL)
                self.state = 1728
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumFieldMultipleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def enumFieldSingle(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.EnumFieldSingleContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.EnumFieldSingleContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_enumFieldMultiple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumFieldMultiple" ):
                listener.enterEnumFieldMultiple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumFieldMultiple" ):
                listener.exitEnumFieldMultiple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumFieldMultiple" ):
                return visitor.visitEnumFieldMultiple(self)
            else:
                return visitor.visitChildren(self)




    def enumFieldMultiple(self):

        localctx = NeoBasicParser.EnumFieldMultipleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 306, self.RULE_enumFieldMultiple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1731
            self.enumFieldSingle()
            self.state = 1736
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==473:
                self.state = 1732
                self.match(NeoBasicParser.COMMA)
                self.state = 1733
                self.enumFieldSingle()
                self.state = 1738
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def structClause(self):
            return self.getTypedRuleContext(NeoBasicParser.StructClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_structSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructSentence" ):
                listener.enterStructSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructSentence" ):
                listener.exitStructSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructSentence" ):
                return visitor.visitStructSentence(self)
            else:
                return visitor.visitChildren(self)




    def structSentence(self):

        localctx = NeoBasicParser.StructSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 308, self.RULE_structSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1739
            self.structClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRUCT(self):
            return self.getToken(NeoBasicParser.STRUCT, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def structBody(self):
            return self.getTypedRuleContext(NeoBasicParser.StructBodyContext,0)


        def mixesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.MixesClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_structClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructClause" ):
                listener.enterStructClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructClause" ):
                listener.exitStructClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructClause" ):
                return visitor.visitStructClause(self)
            else:
                return visitor.visitChildren(self)




    def structClause(self):

        localctx = NeoBasicParser.StructClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 310, self.RULE_structClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1741
            self.match(NeoBasicParser.STRUCT)
            self.state = 1742
            self.declarationIdentifier()
            self.state = 1744
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==35:
                self.state = 1743
                self.mixesClause()


            self.state = 1746
            self.structBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def structSemex(self):
            return self.getTypedRuleContext(NeoBasicParser.StructSemexContext,0)


        def structSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.StructSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_structBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructBody" ):
                listener.enterStructBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructBody" ):
                listener.exitStructBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructBody" ):
                return visitor.visitStructBody(self)
            else:
                return visitor.visitChildren(self)




    def structBody(self):

        localctx = NeoBasicParser.StructBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 312, self.RULE_structBody)
        try:
            self.state = 1750
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [475]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1748
                self.structSemex()
                pass
            elif token in [457]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1749
                self.structSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructSemexContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def structFieldMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.StructFieldMultipleContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_structSemex

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructSemex" ):
                listener.enterStructSemex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructSemex" ):
                listener.exitStructSemex(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructSemex" ):
                return visitor.visitStructSemex(self)
            else:
                return visitor.visitChildren(self)




    def structSemex(self):

        localctx = NeoBasicParser.StructSemexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 314, self.RULE_structSemex)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1752
            self.match(NeoBasicParser.COLON)
            self.state = 1753
            self.structFieldMultiple()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def structMembersBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.StructMembersBlockContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_structSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructSuite" ):
                listener.enterStructSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructSuite" ):
                listener.exitStructSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructSuite" ):
                return visitor.visitStructSuite(self)
            else:
                return visitor.visitChildren(self)




    def structSuite(self):

        localctx = NeoBasicParser.StructSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 316, self.RULE_structSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1755
            self.match(NeoBasicParser.EOS)
            self.state = 1756
            self.match(NeoBasicParser.INDENT)
            self.state = 1757
            self.structMembersBlock()
            self.state = 1758
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructMembersBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def structMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.StructMemberContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.StructMemberContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_structMembersBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructMembersBlock" ):
                listener.enterStructMembersBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructMembersBlock" ):
                listener.exitStructMembersBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructMembersBlock" ):
                return visitor.visitStructMembersBlock(self)
            else:
                return visitor.visitChildren(self)




    def structMembersBlock(self):

        localctx = NeoBasicParser.StructMembersBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 318, self.RULE_structMembersBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1760
            self.structMember()
            self.state = 1765
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==457:
                self.state = 1761
                self.match(NeoBasicParser.EOS)
                self.state = 1762
                self.structMember()
                self.state = 1767
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalInstruction(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionContext,0)


        def structFieldSingle(self):
            return self.getTypedRuleContext(NeoBasicParser.StructFieldSingleContext,0)


        def structFieldMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.StructFieldMultipleContext,0)


        def structMemberEmbedded(self):
            return self.getTypedRuleContext(NeoBasicParser.StructMemberEmbeddedContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_structMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructMember" ):
                listener.enterStructMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructMember" ):
                listener.exitStructMember(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructMember" ):
                return visitor.visitStructMember(self)
            else:
                return visitor.visitChildren(self)




    def structMember(self):

        localctx = NeoBasicParser.StructMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 320, self.RULE_structMember)
        try:
            self.state = 1772
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,113,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1768
                self.logicalInstruction()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1769
                self.structFieldSingle()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1770
                self.structFieldMultiple()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1771
                self.structMemberEmbedded()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructFieldSingleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def inferredDecoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifierContext,0)


        def attributeTag(self):
            return self.getTypedRuleContext(NeoBasicParser.AttributeTagContext,0)


        def EQUAL(self):
            return self.getToken(NeoBasicParser.EQUAL, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_structFieldSingle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructFieldSingle" ):
                listener.enterStructFieldSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructFieldSingle" ):
                listener.exitStructFieldSingle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructFieldSingle" ):
                return visitor.visitStructFieldSingle(self)
            else:
                return visitor.visitChildren(self)




    def structFieldSingle(self):

        localctx = NeoBasicParser.StructFieldSingleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 322, self.RULE_structFieldSingle)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1774
            self.inferredDecoratedIdentifier()
            self.state = 1776
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 429)) & ~0x3f) == 0 and ((1 << (_la - 429)) & 21) != 0):
                self.state = 1775
                self.attributeTag()


            self.state = 1780
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==389:
                self.state = 1778
                self.match(NeoBasicParser.EQUAL)
                self.state = 1779
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttributeTagContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stringLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.StringLiteralContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_attributeTag

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAttributeTag" ):
                listener.enterAttributeTag(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAttributeTag" ):
                listener.exitAttributeTag(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttributeTag" ):
                return visitor.visitAttributeTag(self)
            else:
                return visitor.visitChildren(self)




    def attributeTag(self):

        localctx = NeoBasicParser.AttributeTagContext(self, self._ctx, self.state)
        self.enterRule(localctx, 324, self.RULE_attributeTag)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1782
            self.stringLiteral()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructFieldMultipleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def structFieldSingle(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.StructFieldSingleContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.StructFieldSingleContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_structFieldMultiple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructFieldMultiple" ):
                listener.enterStructFieldMultiple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructFieldMultiple" ):
                listener.exitStructFieldMultiple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructFieldMultiple" ):
                return visitor.visitStructFieldMultiple(self)
            else:
                return visitor.visitChildren(self)




    def structFieldMultiple(self):

        localctx = NeoBasicParser.StructFieldMultipleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 326, self.RULE_structFieldMultiple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1784
            self.structFieldSingle()
            self.state = 1787 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1785
                self.match(NeoBasicParser.COMMA)
                self.state = 1786
                self.structFieldSingle()
                self.state = 1789 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==473):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructMemberEmbeddedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def decoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DecoratedIdentifierContext,0)


        def STRUCT(self):
            return self.getToken(NeoBasicParser.STRUCT, 0)

        def structSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.StructSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_structMemberEmbedded

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructMemberEmbedded" ):
                listener.enterStructMemberEmbedded(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructMemberEmbedded" ):
                listener.exitStructMemberEmbedded(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructMemberEmbedded" ):
                return visitor.visitStructMemberEmbedded(self)
            else:
                return visitor.visitChildren(self)




    def structMemberEmbedded(self):

        localctx = NeoBasicParser.StructMemberEmbeddedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 328, self.RULE_structMemberEmbedded)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1791
            self.decoratedIdentifier()
            self.state = 1792
            self.match(NeoBasicParser.STRUCT)
            self.state = 1793
            self.structSuite()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProtoSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def protoClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ProtoClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_protoSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProtoSentence" ):
                listener.enterProtoSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProtoSentence" ):
                listener.exitProtoSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProtoSentence" ):
                return visitor.visitProtoSentence(self)
            else:
                return visitor.visitChildren(self)




    def protoSentence(self):

        localctx = NeoBasicParser.ProtoSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 330, self.RULE_protoSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1795
            self.protoClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProtoClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROTO(self):
            return self.getToken(NeoBasicParser.PROTO, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def protoBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProtoBodyContext,0)


        def extendsClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ExtendsClauseContext,0)


        def mixesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.MixesClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_protoClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProtoClause" ):
                listener.enterProtoClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProtoClause" ):
                listener.exitProtoClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProtoClause" ):
                return visitor.visitProtoClause(self)
            else:
                return visitor.visitChildren(self)




    def protoClause(self):

        localctx = NeoBasicParser.ProtoClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 332, self.RULE_protoClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1797
            self.match(NeoBasicParser.PROTO)
            self.state = 1798
            self.declarationIdentifier()
            self.state = 1800
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==33:
                self.state = 1799
                self.extendsClause()


            self.state = 1803
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==35:
                self.state = 1802
                self.mixesClause()


            self.state = 1805
            self.protoBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProtoBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_protoBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProtoBody" ):
                listener.enterProtoBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProtoBody" ):
                listener.exitProtoBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProtoBody" ):
                return visitor.visitProtoBody(self)
            else:
                return visitor.visitChildren(self)




    def protoBody(self):

        localctx = NeoBasicParser.ProtoBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 334, self.RULE_protoBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1807
            self.logicalInstructionSuite()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraitSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def traitClause(self):
            return self.getTypedRuleContext(NeoBasicParser.TraitClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_traitSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraitSentence" ):
                listener.enterTraitSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraitSentence" ):
                listener.exitTraitSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraitSentence" ):
                return visitor.visitTraitSentence(self)
            else:
                return visitor.visitChildren(self)




    def traitSentence(self):

        localctx = NeoBasicParser.TraitSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 336, self.RULE_traitSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1809
            self.traitClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraitClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRAIT(self):
            return self.getToken(NeoBasicParser.TRAIT, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def traitBody(self):
            return self.getTypedRuleContext(NeoBasicParser.TraitBodyContext,0)


        def mixesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.MixesClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_traitClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraitClause" ):
                listener.enterTraitClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraitClause" ):
                listener.exitTraitClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraitClause" ):
                return visitor.visitTraitClause(self)
            else:
                return visitor.visitChildren(self)




    def traitClause(self):

        localctx = NeoBasicParser.TraitClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 338, self.RULE_traitClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1811
            self.match(NeoBasicParser.TRAIT)
            self.state = 1812
            self.declarationIdentifier()
            self.state = 1814
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==35:
                self.state = 1813
                self.mixesClause()


            self.state = 1816
            self.traitBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraitBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_traitBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraitBody" ):
                listener.enterTraitBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraitBody" ):
                listener.exitTraitBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTraitBody" ):
                return visitor.visitTraitBody(self)
            else:
                return visitor.visitChildren(self)




    def traitBody(self):

        localctx = NeoBasicParser.TraitBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 340, self.RULE_traitBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1818
            self.logicalInstructionSuite()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ClassClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_classSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassSentence" ):
                listener.enterClassSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassSentence" ):
                listener.exitClassSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassSentence" ):
                return visitor.visitClassSentence(self)
            else:
                return visitor.visitChildren(self)




    def classSentence(self):

        localctx = NeoBasicParser.ClassSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 342, self.RULE_classSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1820
            self.classClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CLASS(self):
            return self.getToken(NeoBasicParser.CLASS, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def classBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ClassBodyContext,0)


        def extendsClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ExtendsClauseContext,0)


        def implementsClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ImplementsClauseContext,0)


        def mixesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.MixesClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_classClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassClause" ):
                listener.enterClassClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassClause" ):
                listener.exitClassClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassClause" ):
                return visitor.visitClassClause(self)
            else:
                return visitor.visitChildren(self)




    def classClause(self):

        localctx = NeoBasicParser.ClassClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 344, self.RULE_classClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1822
            self.match(NeoBasicParser.CLASS)
            self.state = 1823
            self.declarationIdentifier()
            self.state = 1825
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==33:
                self.state = 1824
                self.extendsClause()


            self.state = 1828
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==34:
                self.state = 1827
                self.implementsClause()


            self.state = 1831
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==35:
                self.state = 1830
                self.mixesClause()


            self.state = 1833
            self.classBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classSemex(self):
            return self.getTypedRuleContext(NeoBasicParser.ClassSemexContext,0)


        def classSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.ClassSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_classBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassBody" ):
                listener.enterClassBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassBody" ):
                listener.exitClassBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassBody" ):
                return visitor.visitClassBody(self)
            else:
                return visitor.visitChildren(self)




    def classBody(self):

        localctx = NeoBasicParser.ClassBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 346, self.RULE_classBody)
        try:
            self.state = 1837
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [475]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1835
                self.classSemex()
                pass
            elif token in [457]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1836
                self.classSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassSemexContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def classFieldMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.ClassFieldMultipleContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_classSemex

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassSemex" ):
                listener.enterClassSemex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassSemex" ):
                listener.exitClassSemex(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassSemex" ):
                return visitor.visitClassSemex(self)
            else:
                return visitor.visitChildren(self)




    def classSemex(self):

        localctx = NeoBasicParser.ClassSemexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 348, self.RULE_classSemex)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1839
            self.match(NeoBasicParser.COLON)
            self.state = 1840
            self.classFieldMultiple()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassFieldMultipleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classFieldSimple(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ClassFieldSimpleContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ClassFieldSimpleContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_classFieldMultiple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassFieldMultiple" ):
                listener.enterClassFieldMultiple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassFieldMultiple" ):
                listener.exitClassFieldMultiple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassFieldMultiple" ):
                return visitor.visitClassFieldMultiple(self)
            else:
                return visitor.visitChildren(self)




    def classFieldMultiple(self):

        localctx = NeoBasicParser.ClassFieldMultipleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 350, self.RULE_classFieldMultiple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1842
            self.classFieldSimple()
            self.state = 1847
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==473:
                self.state = 1843
                self.match(NeoBasicParser.COMMA)
                self.state = 1844
                self.classFieldSimple()
                self.state = 1849
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassFieldSimpleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def inferredDecoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifierContext,0)


        def attributeTag(self):
            return self.getTypedRuleContext(NeoBasicParser.AttributeTagContext,0)


        def EQUAL(self):
            return self.getToken(NeoBasicParser.EQUAL, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_classFieldSimple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassFieldSimple" ):
                listener.enterClassFieldSimple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassFieldSimple" ):
                listener.exitClassFieldSimple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassFieldSimple" ):
                return visitor.visitClassFieldSimple(self)
            else:
                return visitor.visitChildren(self)




    def classFieldSimple(self):

        localctx = NeoBasicParser.ClassFieldSimpleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 352, self.RULE_classFieldSimple)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1850
            self.inferredDecoratedIdentifier()
            self.state = 1852
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 429)) & ~0x3f) == 0 and ((1 << (_la - 429)) & 21) != 0):
                self.state = 1851
                self.attributeTag()


            self.state = 1856
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==389:
                self.state = 1854
                self.match(NeoBasicParser.EQUAL)
                self.state = 1855
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_classSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassSuite" ):
                listener.enterClassSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassSuite" ):
                listener.exitClassSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassSuite" ):
                return visitor.visitClassSuite(self)
            else:
                return visitor.visitChildren(self)




    def classSuite(self):

        localctx = NeoBasicParser.ClassSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 354, self.RULE_classSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1858
            self.logicalInstructionSuite()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InnerDeclareSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constructSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.ConstructSentenceContext,0)


        def destructSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.DestructSentenceContext,0)


        def propertySentence(self):
            return self.getTypedRuleContext(NeoBasicParser.PropertySentenceContext,0)


        def propertyAccessorSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.PropertyAccessorSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_innerDeclareSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInnerDeclareSentence" ):
                listener.enterInnerDeclareSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInnerDeclareSentence" ):
                listener.exitInnerDeclareSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInnerDeclareSentence" ):
                return visitor.visitInnerDeclareSentence(self)
            else:
                return visitor.visitChildren(self)




    def innerDeclareSentence(self):

        localctx = NeoBasicParser.InnerDeclareSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 356, self.RULE_innerDeclareSentence)
        try:
            self.state = 1864
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [36]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1860
                self.constructSentence()
                pass
            elif token in [37]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1861
                self.destructSentence()
                pass
            elif token in [38]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1862
                self.propertySentence()
                pass
            elif token in [39, 40]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1863
                self.propertyAccessorSentence()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstructSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constructClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ConstructClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_constructSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstructSentence" ):
                listener.enterConstructSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstructSentence" ):
                listener.exitConstructSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstructSentence" ):
                return visitor.visitConstructSentence(self)
            else:
                return visitor.visitChildren(self)




    def constructSentence(self):

        localctx = NeoBasicParser.ConstructSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 358, self.RULE_constructSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1866
            self.constructClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstructClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONSTRUCT(self):
            return self.getToken(NeoBasicParser.CONSTRUCT, 0)

        def parenthesizedParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParametersContext,0)


        def procBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcBodyContext,0)


        def classInitializer(self):
            return self.getTypedRuleContext(NeoBasicParser.ClassInitializerContext,0)


        def raisesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.RaisesClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_constructClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstructClause" ):
                listener.enterConstructClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstructClause" ):
                listener.exitConstructClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstructClause" ):
                return visitor.visitConstructClause(self)
            else:
                return visitor.visitChildren(self)




    def constructClause(self):

        localctx = NeoBasicParser.ConstructClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 360, self.RULE_constructClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1868
            self.match(NeoBasicParser.CONSTRUCT)
            self.state = 1869
            self.parenthesizedParameters()
            self.state = 1871
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==470:
                self.state = 1870
                self.classInitializer()


            self.state = 1874
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==41 or _la==42:
                self.state = 1873
                self.raisesClause()


            self.state = 1876
            self.procBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassInitializerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_CURLY(self):
            return self.getToken(NeoBasicParser.LEFT_CURLY, 0)

        def classInitializingMembers(self):
            return self.getTypedRuleContext(NeoBasicParser.ClassInitializingMembersContext,0)


        def RIGHT_CURLY(self):
            return self.getToken(NeoBasicParser.RIGHT_CURLY, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_classInitializer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassInitializer" ):
                listener.enterClassInitializer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassInitializer" ):
                listener.exitClassInitializer(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassInitializer" ):
                return visitor.visitClassInitializer(self)
            else:
                return visitor.visitChildren(self)




    def classInitializer(self):

        localctx = NeoBasicParser.ClassInitializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 362, self.RULE_classInitializer)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1878
            self.match(NeoBasicParser.LEFT_CURLY)
            self.state = 1879
            self.classInitializingMembers()
            self.state = 1880
            self.match(NeoBasicParser.RIGHT_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassInitializingMembersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def classInitializingMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ClassInitializingMemberContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ClassInitializingMemberContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_classInitializingMembers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassInitializingMembers" ):
                listener.enterClassInitializingMembers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassInitializingMembers" ):
                listener.exitClassInitializingMembers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassInitializingMembers" ):
                return visitor.visitClassInitializingMembers(self)
            else:
                return visitor.visitChildren(self)




    def classInitializingMembers(self):

        localctx = NeoBasicParser.ClassInitializingMembersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 364, self.RULE_classInitializingMembers)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1882
            self.classInitializingMember()
            self.state = 1887
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==473:
                self.state = 1883
                self.match(NeoBasicParser.COMMA)
                self.state = 1884
                self.classInitializingMember()
                self.state = 1889
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassInitializingMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_classInitializingMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassInitializingMember" ):
                listener.enterClassInitializingMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassInitializingMember" ):
                listener.exitClassInitializingMember(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClassInitializingMember" ):
                return visitor.visitClassInitializingMember(self)
            else:
                return visitor.visitChildren(self)




    def classInitializingMember(self):

        localctx = NeoBasicParser.ClassInitializingMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 366, self.RULE_classInitializingMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1893
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,131,self._ctx)
            if la_ == 1:
                self.state = 1890
                self.qualifiedIdentifier()
                self.state = 1891
                self.match(NeoBasicParser.COLON)


            self.state = 1895
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DestructSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def destructClause(self):
            return self.getTypedRuleContext(NeoBasicParser.DestructClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_destructSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDestructSentence" ):
                listener.enterDestructSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDestructSentence" ):
                listener.exitDestructSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDestructSentence" ):
                return visitor.visitDestructSentence(self)
            else:
                return visitor.visitChildren(self)




    def destructSentence(self):

        localctx = NeoBasicParser.DestructSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 368, self.RULE_destructSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1897
            self.destructClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DestructClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DESTRUCT(self):
            return self.getToken(NeoBasicParser.DESTRUCT, 0)

        def procBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcBodyContext,0)


        def parenthesizedParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParametersContext,0)


        def raisesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.RaisesClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_destructClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDestructClause" ):
                listener.enterDestructClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDestructClause" ):
                listener.exitDestructClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDestructClause" ):
                return visitor.visitDestructClause(self)
            else:
                return visitor.visitChildren(self)




    def destructClause(self):

        localctx = NeoBasicParser.DestructClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 370, self.RULE_destructClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1899
            self.match(NeoBasicParser.DESTRUCT)
            self.state = 1901
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==466:
                self.state = 1900
                self.parenthesizedParameters()


            self.state = 1904
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==41 or _la==42:
                self.state = 1903
                self.raisesClause()


            self.state = 1906
            self.procBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertySentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def propertyClause(self):
            return self.getTypedRuleContext(NeoBasicParser.PropertyClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_propertySentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertySentence" ):
                listener.enterPropertySentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertySentence" ):
                listener.exitPropertySentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropertySentence" ):
                return visitor.visitPropertySentence(self)
            else:
                return visitor.visitChildren(self)




    def propertySentence(self):

        localctx = NeoBasicParser.PropertySentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 372, self.RULE_propertySentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1908
            self.propertyClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertyClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROPERTY(self):
            return self.getToken(NeoBasicParser.PROPERTY, 0)

        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def propertyBody(self):
            return self.getTypedRuleContext(NeoBasicParser.PropertyBodyContext,0)


        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def attributeTag(self):
            return self.getTypedRuleContext(NeoBasicParser.AttributeTagContext,0)


        def EQUAL(self):
            return self.getToken(NeoBasicParser.EQUAL, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_propertyClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyClause" ):
                listener.enterPropertyClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyClause" ):
                listener.exitPropertyClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropertyClause" ):
                return visitor.visitPropertyClause(self)
            else:
                return visitor.visitChildren(self)




    def propertyClause(self):

        localctx = NeoBasicParser.PropertyClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 374, self.RULE_propertyClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1910
            self.match(NeoBasicParser.PROPERTY)
            self.state = 1911
            self.declarationIdentifier()
            self.state = 1913
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1649529585664) != 0) or ((((_la - 165)) & ~0x3f) == 0 and ((1 << (_la - 165)) & -1) != 0) or ((((_la - 229)) & ~0x3f) == 0 and ((1 << (_la - 229)) & 33554431) != 0) or ((((_la - 297)) & ~0x3f) == 0 and ((1 << (_la - 297)) & 585) != 0) or _la==415 or _la==468:
                self.state = 1912
                self.type_(0)


            self.state = 1916
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 429)) & ~0x3f) == 0 and ((1 << (_la - 429)) & 21) != 0):
                self.state = 1915
                self.attributeTag()


            self.state = 1920
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==389:
                self.state = 1918
                self.match(NeoBasicParser.EQUAL)
                self.state = 1919
                self.expression(0)


            self.state = 1922
            self.propertyBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertyBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_propertyBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyBody" ):
                listener.enterPropertyBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyBody" ):
                listener.exitPropertyBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropertyBody" ):
                return visitor.visitPropertyBody(self)
            else:
                return visitor.visitChildren(self)




    def propertyBody(self):

        localctx = NeoBasicParser.PropertyBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 376, self.RULE_propertyBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1924
            self.logicalInstructionSuite()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertyAccessorSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def propertyGetterClause(self):
            return self.getTypedRuleContext(NeoBasicParser.PropertyGetterClauseContext,0)


        def propertySetterClause(self):
            return self.getTypedRuleContext(NeoBasicParser.PropertySetterClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_propertyAccessorSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyAccessorSentence" ):
                listener.enterPropertyAccessorSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyAccessorSentence" ):
                listener.exitPropertyAccessorSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropertyAccessorSentence" ):
                return visitor.visitPropertyAccessorSentence(self)
            else:
                return visitor.visitChildren(self)




    def propertyAccessorSentence(self):

        localctx = NeoBasicParser.PropertyAccessorSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 378, self.RULE_propertyAccessorSentence)
        try:
            self.state = 1928
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [39]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1926
                self.propertyGetterClause()
                pass
            elif token in [40]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1927
                self.propertySetterClause()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertyGetterClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GETTER(self):
            return self.getToken(NeoBasicParser.GETTER, 0)

        def procBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcBodyContext,0)


        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def parenthesizedParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParametersContext,0)


        def raisesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.RaisesClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_propertyGetterClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyGetterClause" ):
                listener.enterPropertyGetterClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyGetterClause" ):
                listener.exitPropertyGetterClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropertyGetterClause" ):
                return visitor.visitPropertyGetterClause(self)
            else:
                return visitor.visitChildren(self)




    def propertyGetterClause(self):

        localctx = NeoBasicParser.PropertyGetterClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 380, self.RULE_propertyGetterClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1930
            self.match(NeoBasicParser.GETTER)
            self.state = 1932
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 415)) & ~0x3f) == 0 and ((1 << (_la - 415)) & 7) != 0):
                self.state = 1931
                self.declarationIdentifier()


            self.state = 1935
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==466:
                self.state = 1934
                self.parenthesizedParameters()


            self.state = 1938
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==41 or _la==42:
                self.state = 1937
                self.raisesClause()


            self.state = 1940
            self.procBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertySetterClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SETTER(self):
            return self.getToken(NeoBasicParser.SETTER, 0)

        def procBody(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcBodyContext,0)


        def declarationIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DeclarationIdentifierContext,0)


        def parenthesizedParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParametersContext,0)


        def raisesClause(self):
            return self.getTypedRuleContext(NeoBasicParser.RaisesClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_propertySetterClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertySetterClause" ):
                listener.enterPropertySetterClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertySetterClause" ):
                listener.exitPropertySetterClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropertySetterClause" ):
                return visitor.visitPropertySetterClause(self)
            else:
                return visitor.visitChildren(self)




    def propertySetterClause(self):

        localctx = NeoBasicParser.PropertySetterClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 382, self.RULE_propertySetterClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1942
            self.match(NeoBasicParser.SETTER)
            self.state = 1944
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 415)) & ~0x3f) == 0 and ((1 << (_la - 415)) & 7) != 0):
                self.state = 1943
                self.declarationIdentifier()


            self.state = 1947
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==466:
                self.state = 1946
                self.parenthesizedParameters()


            self.state = 1950
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==41 or _la==42:
                self.state = 1949
                self.raisesClause()


            self.state = 1952
            self.procBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def labelIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.LabelIdentifierContext,0)


        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def statementSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementSentenceContext,0)


        def simpleStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.SimpleStatementContext,0)


        def compoundStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.CompoundStatementContext,0)


        def testingStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.TestingStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_statementSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatementSentence" ):
                listener.enterStatementSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatementSentence" ):
                listener.exitStatementSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatementSentence" ):
                return visitor.visitStatementSentence(self)
            else:
                return visitor.visitChildren(self)




    def statementSentence(self):

        localctx = NeoBasicParser.StatementSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 384, self.RULE_statementSentence)
        try:
            self.state = 1964
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,144,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1954
                self.labelIdentifier()
                self.state = 1955
                self.match(NeoBasicParser.COLON)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1957
                self.labelIdentifier()
                self.state = 1958
                self.match(NeoBasicParser.COLON)
                self.state = 1959
                self.statementSentence()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1961
                self.simpleStatement(0)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1962
                self.compoundStatement()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1963
                self.testingStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementSuiteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def statementBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementBlockContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_statementSuite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatementSuite" ):
                listener.enterStatementSuite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatementSuite" ):
                listener.exitStatementSuite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatementSuite" ):
                return visitor.visitStatementSuite(self)
            else:
                return visitor.visitChildren(self)




    def statementSuite(self):

        localctx = NeoBasicParser.StatementSuiteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 386, self.RULE_statementSuite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1966
            self.match(NeoBasicParser.EOS)
            self.state = 1967
            self.match(NeoBasicParser.INDENT)
            self.state = 1968
            self.statementBlock()
            self.state = 1969
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statementSentence(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.StatementSentenceContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.StatementSentenceContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_statementBlock

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatementBlock" ):
                listener.enterStatementBlock(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatementBlock" ):
                listener.exitStatementBlock(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatementBlock" ):
                return visitor.visitStatementBlock(self)
            else:
                return visitor.visitChildren(self)




    def statementBlock(self):

        localctx = NeoBasicParser.StatementBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 388, self.RULE_statementBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1971
            self.statementSentence()
            self.state = 1976
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==457:
                self.state = 1972
                self.match(NeoBasicParser.EOS)
                self.state = 1973
                self.statementSentence()
                self.state = 1978
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClauseStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IMPLICIT_RETURN(self):
            return self.getToken(NeoBasicParser.IMPLICIT_RETURN, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def DO(self):
            return self.getToken(NeoBasicParser.DO, 0)

        def simpleStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.SimpleStatementContext,0)


        def statementSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_clauseStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClauseStatement" ):
                listener.enterClauseStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClauseStatement" ):
                listener.exitClauseStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClauseStatement" ):
                return visitor.visitClauseStatement(self)
            else:
                return visitor.visitChildren(self)




    def clauseStatement(self):

        localctx = NeoBasicParser.ClauseStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 390, self.RULE_clauseStatement)
        try:
            self.state = 1984
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [376]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1979
                self.match(NeoBasicParser.IMPLICIT_RETURN)
                self.state = 1980
                self.expression(0)
                pass
            elif token in [91]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1981
                self.match(NeoBasicParser.DO)
                self.state = 1982
                self.simpleStatement(0)
                pass
            elif token in [457]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1983
                self.statementSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignmentStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.AssignmentStatementContext,0)


        def consoleStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ConsoleStatementContext,0)


        def deterministicStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.DeterministicStatementContext,0)


        def nondeterministicStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.NondeterministicStatementContext,0)


        def expressionStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionStatementContext,0)


        def emptyStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.EmptyStatementContext,0)


        def simpleStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.SimpleStatementContext,0)


        def executionFlowOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.ExecutionFlowOperatorContext,0)


        def statementSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementSentenceContext,0)


        def OTHERWISE(self):
            return self.getToken(NeoBasicParser.OTHERWISE, 0)

        def UNLESS(self):
            return self.getToken(NeoBasicParser.UNLESS, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def TILL(self):
            return self.getToken(NeoBasicParser.TILL, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_simpleStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleStatement" ):
                listener.enterSimpleStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleStatement" ):
                listener.exitSimpleStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleStatement" ):
                return visitor.visitSimpleStatement(self)
            else:
                return visitor.visitChildren(self)



    def simpleStatement(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = NeoBasicParser.SimpleStatementContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 392
        self.enterRecursionRule(localctx, 392, self.RULE_simpleStatement, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1993
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,147,self._ctx)
            if la_ == 1:
                self.state = 1987
                self.assignmentStatement()
                pass

            elif la_ == 2:
                self.state = 1988
                self.consoleStatement()
                pass

            elif la_ == 3:
                self.state = 1989
                self.deterministicStatement()
                pass

            elif la_ == 4:
                self.state = 1990
                self.nondeterministicStatement()
                pass

            elif la_ == 5:
                self.state = 1991
                self.expressionStatement()
                pass

            elif la_ == 6:
                self.state = 1992
                self.emptyStatement()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 2010
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,149,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 2008
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,148,self._ctx)
                    if la_ == 1:
                        localctx = NeoBasicParser.SimpleStatementContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_simpleStatement)
                        self.state = 1995
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 1996
                        self.executionFlowOperator()
                        self.state = 1997
                        self.statementSentence()
                        pass

                    elif la_ == 2:
                        localctx = NeoBasicParser.SimpleStatementContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_simpleStatement)
                        self.state = 1999
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 2000
                        self.match(NeoBasicParser.OTHERWISE)
                        self.state = 2001
                        self.statementSentence()
                        pass

                    elif la_ == 3:
                        localctx = NeoBasicParser.SimpleStatementContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_simpleStatement)
                        self.state = 2002
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 2003
                        self.match(NeoBasicParser.UNLESS)
                        self.state = 2004
                        self.expression(0)
                        pass

                    elif la_ == 4:
                        localctx = NeoBasicParser.SimpleStatementContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_simpleStatement)
                        self.state = 2005
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 2006
                        self.match(NeoBasicParser.TILL)
                        self.state = 2007
                        self.expression(0)
                        pass

             
                self.state = 2012
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,149,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ExpressionStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_expressionStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionStatement" ):
                listener.enterExpressionStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionStatement" ):
                listener.exitExpressionStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressionStatement" ):
                return visitor.visitExpressionStatement(self)
            else:
                return visitor.visitChildren(self)




    def expressionStatement(self):

        localctx = NeoBasicParser.ExpressionStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 394, self.RULE_expressionStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2013
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EmptyStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELLIPSIS(self):
            return self.getToken(NeoBasicParser.ELLIPSIS, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_emptyStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEmptyStatement" ):
                listener.enterEmptyStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEmptyStatement" ):
                listener.exitEmptyStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEmptyStatement" ):
                return visitor.visitEmptyStatement(self)
            else:
                return visitor.visitChildren(self)




    def emptyStatement(self):

        localctx = NeoBasicParser.EmptyStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 396, self.RULE_emptyStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2015
            self.match(NeoBasicParser.ELLIPSIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LET(self):
            return self.getToken(NeoBasicParser.LET, 0)

        def assignmentStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.AssignmentStatementContext,0)


        def assignmentSingle(self):
            return self.getTypedRuleContext(NeoBasicParser.AssignmentSingleContext,0)


        def assignmentMultiple(self):
            return self.getTypedRuleContext(NeoBasicParser.AssignmentMultipleContext,0)


        def assignmentParallel(self):
            return self.getTypedRuleContext(NeoBasicParser.AssignmentParallelContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_assignmentStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentStatement" ):
                listener.enterAssignmentStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentStatement" ):
                listener.exitAssignmentStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignmentStatement" ):
                return visitor.visitAssignmentStatement(self)
            else:
                return visitor.visitChildren(self)




    def assignmentStatement(self):

        localctx = NeoBasicParser.AssignmentStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 398, self.RULE_assignmentStatement)
        try:
            self.state = 2022
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,150,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2017
                self.match(NeoBasicParser.LET)
                self.state = 2018
                self.assignmentStatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2019
                self.assignmentSingle()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2020
                self.assignmentMultiple()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2021
                self.assignmentParallel()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentSingleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primaryExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.PrimaryExpressionContext,0)


        def singleAssignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.SingleAssignmentOperatorContext,0)


        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_assignmentSingle

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentSingle" ):
                listener.enterAssignmentSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentSingle" ):
                listener.exitAssignmentSingle(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignmentSingle" ):
                return visitor.visitAssignmentSingle(self)
            else:
                return visitor.visitChildren(self)




    def assignmentSingle(self):

        localctx = NeoBasicParser.AssignmentSingleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 400, self.RULE_assignmentSingle)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2024
            self.primaryExpression(0)
            self.state = 2025
            self.singleAssignmentOperator()
            self.state = 2026
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentMultipleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignmentSingle(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.AssignmentSingleContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.AssignmentSingleContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_assignmentMultiple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentMultiple" ):
                listener.enterAssignmentMultiple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentMultiple" ):
                listener.exitAssignmentMultiple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignmentMultiple" ):
                return visitor.visitAssignmentMultiple(self)
            else:
                return visitor.visitChildren(self)




    def assignmentMultiple(self):

        localctx = NeoBasicParser.AssignmentMultipleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 402, self.RULE_assignmentMultiple)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2028
            self.assignmentSingle()
            self.state = 2031 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 2029
                    self.match(NeoBasicParser.COMMA)
                    self.state = 2030
                    self.assignmentSingle()

                else:
                    raise NoViableAltException(self)
                self.state = 2033 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,151,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentParallelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primaryExpressions(self):
            return self.getTypedRuleContext(NeoBasicParser.PrimaryExpressionsContext,0)


        def unpackingAssignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnpackingAssignmentOperatorContext,0)


        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_assignmentParallel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentParallel" ):
                listener.enterAssignmentParallel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentParallel" ):
                listener.exitAssignmentParallel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignmentParallel" ):
                return visitor.visitAssignmentParallel(self)
            else:
                return visitor.visitChildren(self)




    def assignmentParallel(self):

        localctx = NeoBasicParser.AssignmentParallelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 404, self.RULE_assignmentParallel)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2035
            self.primaryExpressions()
            self.state = 2036
            self.unpackingAssignmentOperator()
            self.state = 2037
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConsoleStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atClause(self):
            return self.getTypedRuleContext(NeoBasicParser.AtClauseContext,0)


        def consoleStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ConsoleStatementContext,0)


        def echoCommand(self):
            return self.getTypedRuleContext(NeoBasicParser.EchoCommandContext,0)


        def scanCommand(self):
            return self.getTypedRuleContext(NeoBasicParser.ScanCommandContext,0)


        def alertCommand(self):
            return self.getTypedRuleContext(NeoBasicParser.AlertCommandContext,0)


        def entryCommand(self):
            return self.getTypedRuleContext(NeoBasicParser.EntryCommandContext,0)


        def playCommand(self):
            return self.getTypedRuleContext(NeoBasicParser.PlayCommandContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_consoleStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConsoleStatement" ):
                listener.enterConsoleStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConsoleStatement" ):
                listener.exitConsoleStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConsoleStatement" ):
                return visitor.visitConsoleStatement(self)
            else:
                return visitor.visitChildren(self)




    def consoleStatement(self):

        localctx = NeoBasicParser.ConsoleStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 406, self.RULE_consoleStatement)
        try:
            self.state = 2047
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [118]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2039
                self.atClause()
                self.state = 2040
                self.consoleStatement()
                pass
            elif token in [120]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2042
                self.echoCommand()
                pass
            elif token in [119]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2043
                self.scanCommand()
                pass
            elif token in [121]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2044
                self.alertCommand()
                pass
            elif token in [122]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2045
                self.entryCommand()
                pass
            elif token in [123]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2046
                self.playCommand()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AtClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AT(self):
            return self.getToken(NeoBasicParser.AT, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_atClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtClause" ):
                listener.enterAtClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtClause" ):
                listener.exitAtClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtClause" ):
                return visitor.visitAtClause(self)
            else:
                return visitor.visitChildren(self)




    def atClause(self):

        localctx = NeoBasicParser.AtClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 408, self.RULE_atClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2049
            self.match(NeoBasicParser.AT)
            self.state = 2050
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EchoCommandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ECHO(self):
            return self.getToken(NeoBasicParser.ECHO, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def COMMA(self):
            return self.getToken(NeoBasicParser.COMMA, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_echoCommand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEchoCommand" ):
                listener.enterEchoCommand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEchoCommand" ):
                listener.exitEchoCommand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEchoCommand" ):
                return visitor.visitEchoCommand(self)
            else:
                return visitor.visitChildren(self)




    def echoCommand(self):

        localctx = NeoBasicParser.EchoCommandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 410, self.RULE_echoCommand)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2052
            self.match(NeoBasicParser.ECHO)
            self.state = 2054
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,153,self._ctx)
            if la_ == 1:
                self.state = 2053
                self.expression(0)


            self.state = 2057
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,154,self._ctx)
            if la_ == 1:
                self.state = 2056
                self.match(NeoBasicParser.COMMA)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScanCommandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SCAN(self):
            return self.getToken(NeoBasicParser.SCAN, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def COMMA(self):
            return self.getToken(NeoBasicParser.COMMA, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_scanCommand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScanCommand" ):
                listener.enterScanCommand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScanCommand" ):
                listener.exitScanCommand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitScanCommand" ):
                return visitor.visitScanCommand(self)
            else:
                return visitor.visitChildren(self)




    def scanCommand(self):

        localctx = NeoBasicParser.ScanCommandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 412, self.RULE_scanCommand)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2059
            self.match(NeoBasicParser.SCAN)
            self.state = 2061
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,155,self._ctx)
            if la_ == 1:
                self.state = 2060
                self.expression(0)


            self.state = 2064
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,156,self._ctx)
            if la_ == 1:
                self.state = 2063
                self.match(NeoBasicParser.COMMA)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlertCommandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALERT(self):
            return self.getToken(NeoBasicParser.ALERT, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_alertCommand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlertCommand" ):
                listener.enterAlertCommand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlertCommand" ):
                listener.exitAlertCommand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlertCommand" ):
                return visitor.visitAlertCommand(self)
            else:
                return visitor.visitChildren(self)




    def alertCommand(self):

        localctx = NeoBasicParser.AlertCommandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 414, self.RULE_alertCommand)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2066
            self.match(NeoBasicParser.ALERT)
            self.state = 2068
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,157,self._ctx)
            if la_ == 1:
                self.state = 2067
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EntryCommandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENTRY(self):
            return self.getToken(NeoBasicParser.ENTRY, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_entryCommand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntryCommand" ):
                listener.enterEntryCommand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntryCommand" ):
                listener.exitEntryCommand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEntryCommand" ):
                return visitor.visitEntryCommand(self)
            else:
                return visitor.visitChildren(self)




    def entryCommand(self):

        localctx = NeoBasicParser.EntryCommandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 416, self.RULE_entryCommand)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2070
            self.match(NeoBasicParser.ENTRY)
            self.state = 2072
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,158,self._ctx)
            if la_ == 1:
                self.state = 2071
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PlayCommandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLAY(self):
            return self.getToken(NeoBasicParser.PLAY, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_playCommand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlayCommand" ):
                listener.enterPlayCommand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlayCommand" ):
                listener.exitPlayCommand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPlayCommand" ):
                return visitor.visitPlayCommand(self)
            else:
                return visitor.visitChildren(self)




    def playCommand(self):

        localctx = NeoBasicParser.PlayCommandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 418, self.RULE_playCommand)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2074
            self.match(NeoBasicParser.PLAY)
            self.state = 2075
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeterministicStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def redoSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.RedoSentenceContext,0)


        def continueSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.ContinueSentenceContext,0)


        def breakSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.BreakSentenceContext,0)


        def fallthroughSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.FallthroughSentenceContext,0)


        def deferSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.DeferSentenceContext,0)


        def resumeSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.ResumeSentenceContext,0)


        def returnSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.ReturnSentenceContext,0)


        def yieldSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.YieldSentenceContext,0)


        def raiseSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.RaiseSentenceContext,0)


        def panicSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.PanicSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_deterministicStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeterministicStatement" ):
                listener.enterDeterministicStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeterministicStatement" ):
                listener.exitDeterministicStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeterministicStatement" ):
                return visitor.visitDeterministicStatement(self)
            else:
                return visitor.visitChildren(self)




    def deterministicStatement(self):

        localctx = NeoBasicParser.DeterministicStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 420, self.RULE_deterministicStatement)
        try:
            self.state = 2087
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [100]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2077
                self.redoSentence()
                pass
            elif token in [101]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2078
                self.continueSentence()
                pass
            elif token in [102]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2079
                self.breakSentence()
                pass
            elif token in [83]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2080
                self.fallthroughSentence()
                pass
            elif token in [89]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2081
                self.deferSentence()
                pass
            elif token in [115]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2082
                self.resumeSentence()
                pass
            elif token in [103]:
                self.enterOuterAlt(localctx, 7)
                self.state = 2083
                self.returnSentence()
                pass
            elif token in [104]:
                self.enterOuterAlt(localctx, 8)
                self.state = 2084
                self.yieldSentence()
                pass
            elif token in [105]:
                self.enterOuterAlt(localctx, 9)
                self.state = 2085
                self.raiseSentence()
                pass
            elif token in [106]:
                self.enterOuterAlt(localctx, 10)
                self.state = 2086
                self.panicSentence()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RedoSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REDO(self):
            return self.getToken(NeoBasicParser.REDO, 0)

        def labelIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.LabelIdentifierContext,0)


        def INTEGER_LIT(self):
            return self.getToken(NeoBasicParser.INTEGER_LIT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_redoSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRedoSentence" ):
                listener.enterRedoSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRedoSentence" ):
                listener.exitRedoSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRedoSentence" ):
                return visitor.visitRedoSentence(self)
            else:
                return visitor.visitChildren(self)




    def redoSentence(self):

        localctx = NeoBasicParser.RedoSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 422, self.RULE_redoSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2089
            self.match(NeoBasicParser.REDO)
            self.state = 2092
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,160,self._ctx)
            if la_ == 1:
                self.state = 2090
                self.labelIdentifier()

            elif la_ == 2:
                self.state = 2091
                self.match(NeoBasicParser.INTEGER_LIT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContinueSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONTINUE(self):
            return self.getToken(NeoBasicParser.CONTINUE, 0)

        def labelIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.LabelIdentifierContext,0)


        def INTEGER_LIT(self):
            return self.getToken(NeoBasicParser.INTEGER_LIT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_continueSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContinueSentence" ):
                listener.enterContinueSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContinueSentence" ):
                listener.exitContinueSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitContinueSentence" ):
                return visitor.visitContinueSentence(self)
            else:
                return visitor.visitChildren(self)




    def continueSentence(self):

        localctx = NeoBasicParser.ContinueSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 424, self.RULE_continueSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2094
            self.match(NeoBasicParser.CONTINUE)
            self.state = 2097
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,161,self._ctx)
            if la_ == 1:
                self.state = 2095
                self.labelIdentifier()

            elif la_ == 2:
                self.state = 2096
                self.match(NeoBasicParser.INTEGER_LIT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BreakSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BREAK(self):
            return self.getToken(NeoBasicParser.BREAK, 0)

        def labelIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.LabelIdentifierContext,0)


        def INTEGER_LIT(self):
            return self.getToken(NeoBasicParser.INTEGER_LIT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_breakSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBreakSentence" ):
                listener.enterBreakSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBreakSentence" ):
                listener.exitBreakSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBreakSentence" ):
                return visitor.visitBreakSentence(self)
            else:
                return visitor.visitChildren(self)




    def breakSentence(self):

        localctx = NeoBasicParser.BreakSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 426, self.RULE_breakSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2099
            self.match(NeoBasicParser.BREAK)
            self.state = 2102
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,162,self._ctx)
            if la_ == 1:
                self.state = 2100
                self.labelIdentifier()

            elif la_ == 2:
                self.state = 2101
                self.match(NeoBasicParser.INTEGER_LIT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FallthroughSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FALLTHROUGH(self):
            return self.getToken(NeoBasicParser.FALLTHROUGH, 0)

        def labelIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.LabelIdentifierContext,0)


        def INTEGER_LIT(self):
            return self.getToken(NeoBasicParser.INTEGER_LIT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_fallthroughSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFallthroughSentence" ):
                listener.enterFallthroughSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFallthroughSentence" ):
                listener.exitFallthroughSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFallthroughSentence" ):
                return visitor.visitFallthroughSentence(self)
            else:
                return visitor.visitChildren(self)




    def fallthroughSentence(self):

        localctx = NeoBasicParser.FallthroughSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 428, self.RULE_fallthroughSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2104
            self.match(NeoBasicParser.FALLTHROUGH)
            self.state = 2107
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,163,self._ctx)
            if la_ == 1:
                self.state = 2105
                self.labelIdentifier()

            elif la_ == 2:
                self.state = 2106
                self.match(NeoBasicParser.INTEGER_LIT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeferSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFER(self):
            return self.getToken(NeoBasicParser.DEFER, 0)

        def statementSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_deferSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeferSentence" ):
                listener.enterDeferSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeferSentence" ):
                listener.exitDeferSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeferSentence" ):
                return visitor.visitDeferSentence(self)
            else:
                return visitor.visitChildren(self)




    def deferSentence(self):

        localctx = NeoBasicParser.DeferSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 430, self.RULE_deferSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2109
            self.match(NeoBasicParser.DEFER)
            self.state = 2110
            self.statementSentence()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResumeSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RESUME(self):
            return self.getToken(NeoBasicParser.RESUME, 0)

        def labelIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.LabelIdentifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_resumeSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResumeSentence" ):
                listener.enterResumeSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResumeSentence" ):
                listener.exitResumeSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResumeSentence" ):
                return visitor.visitResumeSentence(self)
            else:
                return visitor.visitChildren(self)




    def resumeSentence(self):

        localctx = NeoBasicParser.ResumeSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 432, self.RULE_resumeSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2112
            self.match(NeoBasicParser.RESUME)
            self.state = 2114
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,164,self._ctx)
            if la_ == 1:
                self.state = 2113
                self.labelIdentifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(NeoBasicParser.RETURN, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_returnSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnSentence" ):
                listener.enterReturnSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnSentence" ):
                listener.exitReturnSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnSentence" ):
                return visitor.visitReturnSentence(self)
            else:
                return visitor.visitChildren(self)




    def returnSentence(self):

        localctx = NeoBasicParser.ReturnSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 434, self.RULE_returnSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2116
            self.match(NeoBasicParser.RETURN)
            self.state = 2118
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,165,self._ctx)
            if la_ == 1:
                self.state = 2117
                self.expressions()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YieldSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def YIELD(self):
            return self.getToken(NeoBasicParser.YIELD, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_yieldSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterYieldSentence" ):
                listener.enterYieldSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitYieldSentence" ):
                listener.exitYieldSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYieldSentence" ):
                return visitor.visitYieldSentence(self)
            else:
                return visitor.visitChildren(self)




    def yieldSentence(self):

        localctx = NeoBasicParser.YieldSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 436, self.RULE_yieldSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2120
            self.match(NeoBasicParser.YIELD)
            self.state = 2121
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RaiseSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RAISE(self):
            return self.getToken(NeoBasicParser.RAISE, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_raiseSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRaiseSentence" ):
                listener.enterRaiseSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRaiseSentence" ):
                listener.exitRaiseSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRaiseSentence" ):
                return visitor.visitRaiseSentence(self)
            else:
                return visitor.visitChildren(self)




    def raiseSentence(self):

        localctx = NeoBasicParser.RaiseSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 438, self.RULE_raiseSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2123
            self.match(NeoBasicParser.RAISE)
            self.state = 2124
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PanicSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PANIC(self):
            return self.getToken(NeoBasicParser.PANIC, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_panicSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPanicSentence" ):
                listener.enterPanicSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPanicSentence" ):
                listener.exitPanicSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPanicSentence" ):
                return visitor.visitPanicSentence(self)
            else:
                return visitor.visitChildren(self)




    def panicSentence(self):

        localctx = NeoBasicParser.PanicSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 440, self.RULE_panicSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2126
            self.match(NeoBasicParser.PANIC)
            self.state = 2127
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NondeterministicStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ifThenSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.IfThenSentenceContext,0)


        def goSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.GoSentenceContext,0)


        def awaitSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.AwaitSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_nondeterministicStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNondeterministicStatement" ):
                listener.enterNondeterministicStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNondeterministicStatement" ):
                listener.exitNondeterministicStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNondeterministicStatement" ):
                return visitor.visitNondeterministicStatement(self)
            else:
                return visitor.visitChildren(self)




    def nondeterministicStatement(self):

        localctx = NeoBasicParser.NondeterministicStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 442, self.RULE_nondeterministicStatement)
        try:
            self.state = 2132
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [77]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2129
                self.ifThenSentence()
                pass
            elif token in [107]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2130
                self.goSentence()
                pass
            elif token in [111]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2131
                self.awaitSentence()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfThenSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(NeoBasicParser.IF, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def THEN(self):
            return self.getToken(NeoBasicParser.THEN, 0)

        def statementSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_ifThenSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfThenSentence" ):
                listener.enterIfThenSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfThenSentence" ):
                listener.exitIfThenSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfThenSentence" ):
                return visitor.visitIfThenSentence(self)
            else:
                return visitor.visitChildren(self)




    def ifThenSentence(self):

        localctx = NeoBasicParser.IfThenSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 444, self.RULE_ifThenSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2134
            self.match(NeoBasicParser.IF)
            self.state = 2135
            self.expression(0)
            self.state = 2136
            self.match(NeoBasicParser.THEN)
            self.state = 2137
            self.statementSentence()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GoSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GO(self):
            return self.getToken(NeoBasicParser.GO, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def INTO(self):
            return self.getToken(NeoBasicParser.INTO, 0)

        def primaryExpressions(self):
            return self.getTypedRuleContext(NeoBasicParser.PrimaryExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_goSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGoSentence" ):
                listener.enterGoSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGoSentence" ):
                listener.exitGoSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGoSentence" ):
                return visitor.visitGoSentence(self)
            else:
                return visitor.visitChildren(self)




    def goSentence(self):

        localctx = NeoBasicParser.GoSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 446, self.RULE_goSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2139
            self.match(NeoBasicParser.GO)
            self.state = 2140
            self.expression(0)
            self.state = 2143
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,167,self._ctx)
            if la_ == 1:
                self.state = 2141
                self.match(NeoBasicParser.INTO)
                self.state = 2142
                self.primaryExpressions()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AwaitSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AWAIT(self):
            return self.getToken(NeoBasicParser.AWAIT, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_awaitSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAwaitSentence" ):
                listener.enterAwaitSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAwaitSentence" ):
                listener.exitAwaitSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAwaitSentence" ):
                return visitor.visitAwaitSentence(self)
            else:
                return visitor.visitChildren(self)




    def awaitSentence(self):

        localctx = NeoBasicParser.AwaitSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 448, self.RULE_awaitSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2145
            self.match(NeoBasicParser.AWAIT)
            self.state = 2146
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompoundStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def conditionalStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ConditionalStatementContext,0)


        def iterationStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.IterationStatementContext,0)


        def controlFlowStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ControlFlowStatementContext,0)


        def concurrencyStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ConcurrencyStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_compoundStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompoundStatement" ):
                listener.enterCompoundStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompoundStatement" ):
                listener.exitCompoundStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompoundStatement" ):
                return visitor.visitCompoundStatement(self)
            else:
                return visitor.visitChildren(self)




    def compoundStatement(self):

        localctx = NeoBasicParser.CompoundStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 450, self.RULE_compoundStatement)
        try:
            self.state = 2152
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [77, 81, 84, 112]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2148
                self.conditionalStatement()
                pass
            elif token in [92]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2149
                self.iterationStatement()
                pass
            elif token in [90, 116]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2150
                self.controlFlowStatement()
                pass
            elif token in [109]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2151
                self.concurrencyStatement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionalStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ifSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.IfSentenceContext,0)


        def matchSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.MatchSentenceContext,0)


        def trySentence(self):
            return self.getTypedRuleContext(NeoBasicParser.TrySentenceContext,0)


        def switchSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.SwitchSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_conditionalStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditionalStatement" ):
                listener.enterConditionalStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditionalStatement" ):
                listener.exitConditionalStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConditionalStatement" ):
                return visitor.visitConditionalStatement(self)
            else:
                return visitor.visitChildren(self)




    def conditionalStatement(self):

        localctx = NeoBasicParser.ConditionalStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 452, self.RULE_conditionalStatement)
        try:
            self.state = 2158
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [77]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2154
                self.ifSentence()
                pass
            elif token in [81]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2155
                self.matchSentence()
                pass
            elif token in [84]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2156
                self.trySentence()
                pass
            elif token in [112]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2157
                self.switchSentence()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IterationStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loopSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.LoopSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_iterationStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIterationStatement" ):
                listener.enterIterationStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIterationStatement" ):
                listener.exitIterationStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIterationStatement" ):
                return visitor.visitIterationStatement(self)
            else:
                return visitor.visitChildren(self)




    def iterationStatement(self):

        localctx = NeoBasicParser.IterationStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 454, self.RULE_iterationStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2160
            self.loopSentence()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ControlFlowStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def beginSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.BeginSentenceContext,0)


        def withSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.WithSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_controlFlowStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterControlFlowStatement" ):
                listener.enterControlFlowStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitControlFlowStatement" ):
                listener.exitControlFlowStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitControlFlowStatement" ):
                return visitor.visitControlFlowStatement(self)
            else:
                return visitor.visitChildren(self)




    def controlFlowStatement(self):

        localctx = NeoBasicParser.ControlFlowStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 456, self.RULE_controlFlowStatement)
        try:
            self.state = 2164
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [116]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2162
                self.beginSentence()
                pass
            elif token in [90]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2163
                self.withSentence()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConcurrencyStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def gosubSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.GosubSentenceContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_concurrencyStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConcurrencyStatement" ):
                listener.enterConcurrencyStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConcurrencyStatement" ):
                listener.exitConcurrencyStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConcurrencyStatement" ):
                return visitor.visitConcurrencyStatement(self)
            else:
                return visitor.visitChildren(self)




    def concurrencyStatement(self):

        localctx = NeoBasicParser.ConcurrencyStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 458, self.RULE_concurrencyStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2166
            self.gosubSentence()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ifClause(self):
            return self.getTypedRuleContext(NeoBasicParser.IfClauseContext,0)


        def elifClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ElifClauseContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ElifClauseContext,i)


        def elseClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ElseClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_ifSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfSentence" ):
                listener.enterIfSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfSentence" ):
                listener.exitIfSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfSentence" ):
                return visitor.visitIfSentence(self)
            else:
                return visitor.visitChildren(self)




    def ifSentence(self):

        localctx = NeoBasicParser.IfSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 460, self.RULE_ifSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2168
            self.ifClause()
            self.state = 2172
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,171,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2169
                    self.elifClause() 
                self.state = 2174
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,171,self._ctx)

            self.state = 2176
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,172,self._ctx)
            if la_ == 1:
                self.state = 2175
                self.elseClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(NeoBasicParser.IF, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_ifClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfClause" ):
                listener.enterIfClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfClause" ):
                listener.exitIfClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfClause" ):
                return visitor.visitIfClause(self)
            else:
                return visitor.visitChildren(self)




    def ifClause(self):

        localctx = NeoBasicParser.IfClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 462, self.RULE_ifClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2178
            self.match(NeoBasicParser.IF)
            self.state = 2179
            self.expression(0)
            self.state = 2180
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElifClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def ELIF(self):
            return self.getToken(NeoBasicParser.ELIF, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_elifClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElifClause" ):
                listener.enterElifClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElifClause" ):
                listener.exitElifClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElifClause" ):
                return visitor.visitElifClause(self)
            else:
                return visitor.visitChildren(self)




    def elifClause(self):

        localctx = NeoBasicParser.ElifClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 464, self.RULE_elifClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2182
            self.match(NeoBasicParser.EOS)
            self.state = 2183
            self.match(NeoBasicParser.ELIF)
            self.state = 2184
            self.expression(0)
            self.state = 2185
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElseClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def ELSE(self):
            return self.getToken(NeoBasicParser.ELSE, 0)

        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_elseClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElseClause" ):
                listener.enterElseClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElseClause" ):
                listener.exitElseClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElseClause" ):
                return visitor.visitElseClause(self)
            else:
                return visitor.visitChildren(self)




    def elseClause(self):

        localctx = NeoBasicParser.ElseClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 466, self.RULE_elseClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2187
            self.match(NeoBasicParser.EOS)
            self.state = 2188
            self.match(NeoBasicParser.ELSE)
            self.state = 2189
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatchSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def matchClause(self):
            return self.getTypedRuleContext(NeoBasicParser.MatchClauseContext,0)


        def caseClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.CaseClauseContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.CaseClauseContext,i)


        def elseClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ElseClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_matchSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatchSentence" ):
                listener.enterMatchSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatchSentence" ):
                listener.exitMatchSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatchSentence" ):
                return visitor.visitMatchSentence(self)
            else:
                return visitor.visitChildren(self)




    def matchSentence(self):

        localctx = NeoBasicParser.MatchSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 468, self.RULE_matchSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2191
            self.matchClause()
            self.state = 2193 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 2192
                    self.caseClause()

                else:
                    raise NoViableAltException(self)
                self.state = 2195 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,173,self._ctx)

            self.state = 2198
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,174,self._ctx)
            if la_ == 1:
                self.state = 2197
                self.elseClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatchClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MATCH(self):
            return self.getToken(NeoBasicParser.MATCH, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_matchClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatchClause" ):
                listener.enterMatchClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatchClause" ):
                listener.exitMatchClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatchClause" ):
                return visitor.visitMatchClause(self)
            else:
                return visitor.visitChildren(self)




    def matchClause(self):

        localctx = NeoBasicParser.MatchClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 470, self.RULE_matchClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2200
            self.match(NeoBasicParser.MATCH)
            self.state = 2202
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1649529585664) != 0) or ((((_la - 127)) & ~0x3f) == 0 and ((1 << (_la - 127)) & -257706303489) != 0) or ((((_la - 191)) & ~0x3f) == 0 and ((1 << (_la - 191)) & -1) != 0) or ((((_la - 255)) & ~0x3f) == 0 and ((1 << (_la - 255)) & 18014398507384831) != 0) or ((((_la - 321)) & ~0x3f) == 0 and ((1 << (_la - 321)) & 2814750039736063) != 0) or ((((_la - 415)) & ~0x3f) == 0 and ((1 << (_la - 415)) & 47287830447128569) != 0) or ((((_la - 485)) & ~0x3f) == 0 and ((1 << (_la - 485)) & 6151) != 0):
                self.state = 2201
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def CASE(self):
            return self.getToken(NeoBasicParser.CASE, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_caseClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseClause" ):
                listener.enterCaseClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseClause" ):
                listener.exitCaseClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaseClause" ):
                return visitor.visitCaseClause(self)
            else:
                return visitor.visitChildren(self)




    def caseClause(self):

        localctx = NeoBasicParser.CaseClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 472, self.RULE_caseClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2204
            self.match(NeoBasicParser.EOS)
            self.state = 2205
            self.match(NeoBasicParser.CASE)
            self.state = 2206
            self.expressions()
            self.state = 2207
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TrySentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tryClause(self):
            return self.getTypedRuleContext(NeoBasicParser.TryClauseContext,0)


        def catchClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.CatchClauseContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.CatchClauseContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_trySentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrySentence" ):
                listener.enterTrySentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrySentence" ):
                listener.exitTrySentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrySentence" ):
                return visitor.visitTrySentence(self)
            else:
                return visitor.visitChildren(self)




    def trySentence(self):

        localctx = NeoBasicParser.TrySentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 474, self.RULE_trySentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2209
            self.tryClause()
            self.state = 2213
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,176,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2210
                    self.catchClause() 
                self.state = 2215
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,176,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TryClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRY(self):
            return self.getToken(NeoBasicParser.TRY, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_tryClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTryClause" ):
                listener.enterTryClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTryClause" ):
                listener.exitTryClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTryClause" ):
                return visitor.visitTryClause(self)
            else:
                return visitor.visitChildren(self)




    def tryClause(self):

        localctx = NeoBasicParser.TryClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 476, self.RULE_tryClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2216
            self.match(NeoBasicParser.TRY)
            self.state = 2217
            self.expressions()
            self.state = 2219
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,177,self._ctx)
            if la_ == 1:
                self.state = 2218
                self.clauseStatement()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CatchClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def CATCH(self):
            return self.getToken(NeoBasicParser.CATCH, 0)

        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def inferredDecoratedIdentifiers(self):
            return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifiersContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_catchClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCatchClause" ):
                listener.enterCatchClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCatchClause" ):
                listener.exitCatchClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCatchClause" ):
                return visitor.visitCatchClause(self)
            else:
                return visitor.visitChildren(self)




    def catchClause(self):

        localctx = NeoBasicParser.CatchClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 478, self.RULE_catchClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2221
            self.match(NeoBasicParser.EOS)
            self.state = 2222
            self.match(NeoBasicParser.CATCH)
            self.state = 2224
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 415)) & ~0x3f) == 0 and ((1 << (_la - 415)) & 7) != 0):
                self.state = 2223
                self.inferredDecoratedIdentifiers()


            self.state = 2226
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SwitchSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def switchClause(self):
            return self.getTypedRuleContext(NeoBasicParser.SwitchClauseContext,0)


        def whenClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.WhenClauseContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.WhenClauseContext,i)


        def defaultClause(self):
            return self.getTypedRuleContext(NeoBasicParser.DefaultClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_switchSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSwitchSentence" ):
                listener.enterSwitchSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSwitchSentence" ):
                listener.exitSwitchSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSwitchSentence" ):
                return visitor.visitSwitchSentence(self)
            else:
                return visitor.visitChildren(self)




    def switchSentence(self):

        localctx = NeoBasicParser.SwitchSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 480, self.RULE_switchSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2228
            self.switchClause()
            self.state = 2230 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 2229
                    self.whenClause()

                else:
                    raise NoViableAltException(self)
                self.state = 2232 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,179,self._ctx)

            self.state = 2235
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,180,self._ctx)
            if la_ == 1:
                self.state = 2234
                self.defaultClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SwitchClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SWITCH(self):
            return self.getToken(NeoBasicParser.SWITCH, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_switchClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSwitchClause" ):
                listener.enterSwitchClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSwitchClause" ):
                listener.exitSwitchClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSwitchClause" ):
                return visitor.visitSwitchClause(self)
            else:
                return visitor.visitChildren(self)




    def switchClause(self):

        localctx = NeoBasicParser.SwitchClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 482, self.RULE_switchClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2237
            self.match(NeoBasicParser.SWITCH)
            self.state = 2238
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhenClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def WHEN(self):
            return self.getToken(NeoBasicParser.WHEN, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_whenClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhenClause" ):
                listener.enterWhenClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhenClause" ):
                listener.exitWhenClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhenClause" ):
                return visitor.visitWhenClause(self)
            else:
                return visitor.visitChildren(self)




    def whenClause(self):

        localctx = NeoBasicParser.WhenClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 484, self.RULE_whenClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2240
            self.match(NeoBasicParser.EOS)
            self.state = 2241
            self.match(NeoBasicParser.WHEN)
            self.state = 2242
            self.expressions()
            self.state = 2243
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def DEFAULT(self):
            return self.getToken(NeoBasicParser.DEFAULT, 0)

        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_defaultClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefaultClause" ):
                listener.enterDefaultClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefaultClause" ):
                listener.exitDefaultClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefaultClause" ):
                return visitor.visitDefaultClause(self)
            else:
                return visitor.visitChildren(self)




    def defaultClause(self):

        localctx = NeoBasicParser.DefaultClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 486, self.RULE_defaultClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2245
            self.match(NeoBasicParser.EOS)
            self.state = 2246
            self.match(NeoBasicParser.DEFAULT)
            self.state = 2247
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loopClause(self):
            return self.getTypedRuleContext(NeoBasicParser.LoopClauseContext,0)


        def thenClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ThenClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_loopSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopSentence" ):
                listener.enterLoopSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopSentence" ):
                listener.exitLoopSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopSentence" ):
                return visitor.visitLoopSentence(self)
            else:
                return visitor.visitChildren(self)




    def loopSentence(self):

        localctx = NeoBasicParser.LoopSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 488, self.RULE_loopSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2249
            self.loopClause()
            self.state = 2251
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,181,self._ctx)
            if la_ == 1:
                self.state = 2250
                self.thenClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOOP(self):
            return self.getToken(NeoBasicParser.LOOP, 0)

        def loopBody(self):
            return self.getTypedRuleContext(NeoBasicParser.LoopBodyContext,0)


        def varDeclare(self):
            return self.getTypedRuleContext(NeoBasicParser.VarDeclareContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_loopClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopClause" ):
                listener.enterLoopClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopClause" ):
                listener.exitLoopClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopClause" ):
                return visitor.visitLoopClause(self)
            else:
                return visitor.visitChildren(self)




    def loopClause(self):

        localctx = NeoBasicParser.LoopClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 490, self.RULE_loopClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2253
            self.match(NeoBasicParser.LOOP)
            self.state = 2255
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,182,self._ctx)
            if la_ == 1:
                self.state = 2254
                self.varDeclare()


            self.state = 2257
            self.loopBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loopNoCheck(self):
            return self.getTypedRuleContext(NeoBasicParser.LoopNoCheckContext,0)


        def loopCheckFirst(self):
            return self.getTypedRuleContext(NeoBasicParser.LoopCheckFirstContext,0)


        def loopCheckLast(self):
            return self.getTypedRuleContext(NeoBasicParser.LoopCheckLastContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_loopBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopBody" ):
                listener.enterLoopBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopBody" ):
                listener.exitLoopBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopBody" ):
                return visitor.visitLoopBody(self)
            else:
                return visitor.visitChildren(self)




    def loopBody(self):

        localctx = NeoBasicParser.LoopBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 492, self.RULE_loopBody)
        try:
            self.state = 2262
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,183,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2259
                self.loopNoCheck()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2260
                self.loopCheckFirst()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2261
                self.loopCheckLast()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopNoCheckContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def uptoClause(self):
            return self.getTypedRuleContext(NeoBasicParser.UptoClauseContext,0)


        def nextClause(self):
            return self.getTypedRuleContext(NeoBasicParser.NextClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_loopNoCheck

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopNoCheck" ):
                listener.enterLoopNoCheck(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopNoCheck" ):
                listener.exitLoopNoCheck(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopNoCheck" ):
                return visitor.visitLoopNoCheck(self)
            else:
                return visitor.visitChildren(self)




    def loopNoCheck(self):

        localctx = NeoBasicParser.LoopNoCheckContext(self, self._ctx, self.state)
        self.enterRule(localctx, 494, self.RULE_loopNoCheck)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2265
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==98:
                self.state = 2264
                self.uptoClause()


            self.state = 2268
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==99:
                self.state = 2267
                self.nextClause()


            self.state = 2270
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopCheckFirstContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pretestClause(self):
            return self.getTypedRuleContext(NeoBasicParser.PretestClauseContext,0)


        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def uptoClause(self):
            return self.getTypedRuleContext(NeoBasicParser.UptoClauseContext,0)


        def nextClause(self):
            return self.getTypedRuleContext(NeoBasicParser.NextClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_loopCheckFirst

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopCheckFirst" ):
                listener.enterLoopCheckFirst(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopCheckFirst" ):
                listener.exitLoopCheckFirst(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopCheckFirst" ):
                return visitor.visitLoopCheckFirst(self)
            else:
                return visitor.visitChildren(self)




    def loopCheckFirst(self):

        localctx = NeoBasicParser.LoopCheckFirstContext(self, self._ctx, self.state)
        self.enterRule(localctx, 496, self.RULE_loopCheckFirst)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2272
            self.pretestClause()
            self.state = 2274
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==98:
                self.state = 2273
                self.uptoClause()


            self.state = 2277
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==99:
                self.state = 2276
                self.nextClause()


            self.state = 2279
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopCheckLastContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statementSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementSuiteContext,0)


        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def posttestClause(self):
            return self.getTypedRuleContext(NeoBasicParser.PosttestClauseContext,0)


        def uptoClause(self):
            return self.getTypedRuleContext(NeoBasicParser.UptoClauseContext,0)


        def nextClause(self):
            return self.getTypedRuleContext(NeoBasicParser.NextClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_loopCheckLast

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopCheckLast" ):
                listener.enterLoopCheckLast(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopCheckLast" ):
                listener.exitLoopCheckLast(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopCheckLast" ):
                return visitor.visitLoopCheckLast(self)
            else:
                return visitor.visitChildren(self)




    def loopCheckLast(self):

        localctx = NeoBasicParser.LoopCheckLastContext(self, self._ctx, self.state)
        self.enterRule(localctx, 498, self.RULE_loopCheckLast)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2281
            self.statementSuite()
            self.state = 2282
            self.match(NeoBasicParser.EOS)
            self.state = 2283
            self.posttestClause()
            self.state = 2285
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,188,self._ctx)
            if la_ == 1:
                self.state = 2284
                self.uptoClause()


            self.state = 2288
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,189,self._ctx)
            if la_ == 1:
                self.state = 2287
                self.nextClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NextClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEXT(self):
            return self.getToken(NeoBasicParser.NEXT, 0)

        def simpleStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.SimpleStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_nextClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNextClause" ):
                listener.enterNextClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNextClause" ):
                listener.exitNextClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNextClause" ):
                return visitor.visitNextClause(self)
            else:
                return visitor.visitChildren(self)




    def nextClause(self):

        localctx = NeoBasicParser.NextClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 500, self.RULE_nextClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2290
            self.match(NeoBasicParser.NEXT)
            self.state = 2291
            self.simpleStatement(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UptoClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UPTO(self):
            return self.getToken(NeoBasicParser.UPTO, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_uptoClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUptoClause" ):
                listener.enterUptoClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUptoClause" ):
                listener.exitUptoClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUptoClause" ):
                return visitor.visitUptoClause(self)
            else:
                return visitor.visitChildren(self)




    def uptoClause(self):

        localctx = NeoBasicParser.UptoClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 502, self.RULE_uptoClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2293
            self.match(NeoBasicParser.UPTO)
            self.state = 2294
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PretestClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loopEachClause(self):
            return self.getTypedRuleContext(NeoBasicParser.LoopEachClauseContext,0)


        def loopWhileClause(self):
            return self.getTypedRuleContext(NeoBasicParser.LoopWhileClauseContext,0)


        def loopUntilClause(self):
            return self.getTypedRuleContext(NeoBasicParser.LoopUntilClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_pretestClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPretestClause" ):
                listener.enterPretestClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPretestClause" ):
                listener.exitPretestClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPretestClause" ):
                return visitor.visitPretestClause(self)
            else:
                return visitor.visitChildren(self)




    def pretestClause(self):

        localctx = NeoBasicParser.PretestClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 504, self.RULE_pretestClause)
        try:
            self.state = 2299
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [415]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2296
                self.loopEachClause()
                pass
            elif token in [96]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2297
                self.loopWhileClause()
                pass
            elif token in [97]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2298
                self.loopUntilClause()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PosttestClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loopWhileClause(self):
            return self.getTypedRuleContext(NeoBasicParser.LoopWhileClauseContext,0)


        def loopUntilClause(self):
            return self.getTypedRuleContext(NeoBasicParser.LoopUntilClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_posttestClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPosttestClause" ):
                listener.enterPosttestClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPosttestClause" ):
                listener.exitPosttestClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPosttestClause" ):
                return visitor.visitPosttestClause(self)
            else:
                return visitor.visitChildren(self)




    def posttestClause(self):

        localctx = NeoBasicParser.PosttestClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 506, self.RULE_posttestClause)
        try:
            self.state = 2303
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [96]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2301
                self.loopWhileClause()
                pass
            elif token in [97]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2302
                self.loopUntilClause()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopEachClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifiers(self):
            return self.getTypedRuleContext(NeoBasicParser.IdentifiersContext,0)


        def EACH(self):
            return self.getToken(NeoBasicParser.EACH, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def STEP(self):
            return self.getToken(NeoBasicParser.STEP, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_loopEachClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopEachClause" ):
                listener.enterLoopEachClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopEachClause" ):
                listener.exitLoopEachClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopEachClause" ):
                return visitor.visitLoopEachClause(self)
            else:
                return visitor.visitChildren(self)




    def loopEachClause(self):

        localctx = NeoBasicParser.LoopEachClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 508, self.RULE_loopEachClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2305
            self.identifiers()
            self.state = 2306
            self.match(NeoBasicParser.EACH)
            self.state = 2307
            self.expressions()
            self.state = 2310
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==95:
                self.state = 2308
                self.match(NeoBasicParser.STEP)
                self.state = 2309
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopWhileClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(NeoBasicParser.WHILE, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_loopWhileClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopWhileClause" ):
                listener.enterLoopWhileClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopWhileClause" ):
                listener.exitLoopWhileClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopWhileClause" ):
                return visitor.visitLoopWhileClause(self)
            else:
                return visitor.visitChildren(self)




    def loopWhileClause(self):

        localctx = NeoBasicParser.LoopWhileClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 510, self.RULE_loopWhileClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2312
            self.match(NeoBasicParser.WHILE)
            self.state = 2313
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopUntilClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNTIL(self):
            return self.getToken(NeoBasicParser.UNTIL, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_loopUntilClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopUntilClause" ):
                listener.enterLoopUntilClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopUntilClause" ):
                listener.exitLoopUntilClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopUntilClause" ):
                return visitor.visitLoopUntilClause(self)
            else:
                return visitor.visitChildren(self)




    def loopUntilClause(self):

        localctx = NeoBasicParser.LoopUntilClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 512, self.RULE_loopUntilClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2315
            self.match(NeoBasicParser.UNTIL)
            self.state = 2316
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ThenClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def THEN(self):
            return self.getToken(NeoBasicParser.THEN, 0)

        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_thenClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThenClause" ):
                listener.enterThenClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThenClause" ):
                listener.exitThenClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitThenClause" ):
                return visitor.visitThenClause(self)
            else:
                return visitor.visitChildren(self)




    def thenClause(self):

        localctx = NeoBasicParser.ThenClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 514, self.RULE_thenClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2318
            self.match(NeoBasicParser.EOS)
            self.state = 2319
            self.match(NeoBasicParser.THEN)
            self.state = 2320
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeginSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def beginClause(self):
            return self.getTypedRuleContext(NeoBasicParser.BeginClauseContext,0)


        def endClause(self):
            return self.getTypedRuleContext(NeoBasicParser.EndClauseContext,0)


        def catchClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.CatchClauseContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.CatchClauseContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_beginSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeginSentence" ):
                listener.enterBeginSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeginSentence" ):
                listener.exitBeginSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeginSentence" ):
                return visitor.visitBeginSentence(self)
            else:
                return visitor.visitChildren(self)




    def beginSentence(self):

        localctx = NeoBasicParser.BeginSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 516, self.RULE_beginSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2322
            self.beginClause()
            self.state = 2326
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,193,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2323
                    self.catchClause() 
                self.state = 2328
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,193,self._ctx)

            self.state = 2329
            self.endClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BeginClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BEGIN(self):
            return self.getToken(NeoBasicParser.BEGIN, 0)

        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_beginClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBeginClause" ):
                listener.enterBeginClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBeginClause" ):
                listener.exitBeginClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBeginClause" ):
                return visitor.visitBeginClause(self)
            else:
                return visitor.visitChildren(self)




    def beginClause(self):

        localctx = NeoBasicParser.BeginClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 518, self.RULE_beginClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2331
            self.match(NeoBasicParser.BEGIN)
            self.state = 2332
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EndClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def END(self):
            return self.getToken(NeoBasicParser.END, 0)

        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_endClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndClause" ):
                listener.enterEndClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndClause" ):
                listener.exitEndClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndClause" ):
                return visitor.visitEndClause(self)
            else:
                return visitor.visitChildren(self)




    def endClause(self):

        localctx = NeoBasicParser.EndClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 520, self.RULE_endClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2334
            self.match(NeoBasicParser.EOS)
            self.state = 2335
            self.match(NeoBasicParser.END)
            self.state = 2336
            self.clauseStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WithSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def withClause(self):
            return self.getTypedRuleContext(NeoBasicParser.WithClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_withSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWithSentence" ):
                listener.enterWithSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWithSentence" ):
                listener.exitWithSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWithSentence" ):
                return visitor.visitWithSentence(self)
            else:
                return visitor.visitChildren(self)




    def withSentence(self):

        localctx = NeoBasicParser.WithSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 522, self.RULE_withSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2338
            self.withClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WithClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH(self):
            return self.getToken(NeoBasicParser.WITH, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def clauseStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.ClauseStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_withClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWithClause" ):
                listener.enterWithClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWithClause" ):
                listener.exitWithClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWithClause" ):
                return visitor.visitWithClause(self)
            else:
                return visitor.visitChildren(self)




    def withClause(self):

        localctx = NeoBasicParser.WithClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 524, self.RULE_withClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2340
            self.match(NeoBasicParser.WITH)
            self.state = 2341
            self.expressions()
            self.state = 2343
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,194,self._ctx)
            if la_ == 1:
                self.state = 2342
                self.clauseStatement()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GosubSentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def gosubClause(self):
            return self.getTypedRuleContext(NeoBasicParser.GosubClauseContext,0)


        def forkClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ForkClauseContext,0)


        def forEachClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ForEachClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_gosubSentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGosubSentence" ):
                listener.enterGosubSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGosubSentence" ):
                listener.exitGosubSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGosubSentence" ):
                return visitor.visitGosubSentence(self)
            else:
                return visitor.visitChildren(self)




    def gosubSentence(self):

        localctx = NeoBasicParser.GosubSentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 526, self.RULE_gosubSentence)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2345
            self.gosubClause()
            self.state = 2347
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,195,self._ctx)
            if la_ == 1:
                self.state = 2346
                self.forkClause()


            self.state = 2350
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,196,self._ctx)
            if la_ == 1:
                self.state = 2349
                self.forEachClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GosubClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GOSUB(self):
            return self.getToken(NeoBasicParser.GOSUB, 0)

        def statementSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementSuiteContext,0)


        def decoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.DecoratedIdentifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_gosubClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGosubClause" ):
                listener.enterGosubClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGosubClause" ):
                listener.exitGosubClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGosubClause" ):
                return visitor.visitGosubClause(self)
            else:
                return visitor.visitChildren(self)




    def gosubClause(self):

        localctx = NeoBasicParser.GosubClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 528, self.RULE_gosubClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2352
            self.match(NeoBasicParser.GOSUB)
            self.state = 2354
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 415)) & ~0x3f) == 0 and ((1 << (_la - 415)) & 7) != 0):
                self.state = 2353
                self.decoratedIdentifier()


            self.state = 2356
            self.statementSuite()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForkClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FORK(self):
            return self.getToken(NeoBasicParser.FORK, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_forkClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForkClause" ):
                listener.enterForkClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForkClause" ):
                listener.exitForkClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForkClause" ):
                return visitor.visitForkClause(self)
            else:
                return visitor.visitChildren(self)




    def forkClause(self):

        localctx = NeoBasicParser.ForkClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 530, self.RULE_forkClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2358
            self.match(NeoBasicParser.FORK)
            self.state = 2359
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForEachClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(NeoBasicParser.FOR, 0)

        def identifiers(self):
            return self.getTypedRuleContext(NeoBasicParser.IdentifiersContext,0)


        def EACH(self):
            return self.getToken(NeoBasicParser.EACH, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def STEP(self):
            return self.getToken(NeoBasicParser.STEP, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_forEachClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForEachClause" ):
                listener.enterForEachClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForEachClause" ):
                listener.exitForEachClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForEachClause" ):
                return visitor.visitForEachClause(self)
            else:
                return visitor.visitChildren(self)




    def forEachClause(self):

        localctx = NeoBasicParser.ForEachClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 532, self.RULE_forEachClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2361
            self.match(NeoBasicParser.FOR)
            self.state = 2362
            self.identifiers()
            self.state = 2363
            self.match(NeoBasicParser.EACH)
            self.state = 2364
            self.expressions()
            self.state = 2367
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,198,self._ctx)
            if la_ == 1:
                self.state = 2365
                self.match(NeoBasicParser.STEP)
                self.state = 2366
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TestingStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simpleTestStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.SimpleTestStatementContext,0)


        def compoundTestStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.CompoundTestStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_testingStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTestingStatement" ):
                listener.enterTestingStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTestingStatement" ):
                listener.exitTestingStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTestingStatement" ):
                return visitor.visitTestingStatement(self)
            else:
                return visitor.visitChildren(self)




    def testingStatement(self):

        localctx = NeoBasicParser.TestingStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 534, self.RULE_testingStatement)
        try:
            self.state = 2371
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [309]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2369
                self.simpleTestStatement()
                pass
            elif token in [310]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2370
                self.compoundTestStatement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SimpleTestStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assertTestStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.AssertTestStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_simpleTestStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleTestStatement" ):
                listener.enterSimpleTestStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleTestStatement" ):
                listener.exitSimpleTestStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleTestStatement" ):
                return visitor.visitSimpleTestStatement(self)
            else:
                return visitor.visitChildren(self)




    def simpleTestStatement(self):

        localctx = NeoBasicParser.SimpleTestStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 536, self.RULE_simpleTestStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2373
            self.assertTestStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompoundTestStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unitTestStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.UnitTestStatementContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_compoundTestStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompoundTestStatement" ):
                listener.enterCompoundTestStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompoundTestStatement" ):
                listener.exitCompoundTestStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompoundTestStatement" ):
                return visitor.visitCompoundTestStatement(self)
            else:
                return visitor.visitChildren(self)




    def compoundTestStatement(self):

        localctx = NeoBasicParser.CompoundTestStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 538, self.RULE_compoundTestStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2375
            self.unitTestStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssertTestStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assertClause(self):
            return self.getTypedRuleContext(NeoBasicParser.AssertClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_assertTestStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssertTestStatement" ):
                listener.enterAssertTestStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssertTestStatement" ):
                listener.exitAssertTestStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssertTestStatement" ):
                return visitor.visitAssertTestStatement(self)
            else:
                return visitor.visitChildren(self)




    def assertTestStatement(self):

        localctx = NeoBasicParser.AssertTestStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 540, self.RULE_assertTestStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2377
            self.assertClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssertClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASSERT(self):
            return self.getToken(NeoBasicParser.ASSERT, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,i)


        def EXCLAMATION(self):
            return self.getToken(NeoBasicParser.EXCLAMATION, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_assertClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssertClause" ):
                listener.enterAssertClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssertClause" ):
                listener.exitAssertClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssertClause" ):
                return visitor.visitAssertClause(self)
            else:
                return visitor.visitChildren(self)




    def assertClause(self):

        localctx = NeoBasicParser.AssertClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 542, self.RULE_assertClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2379
            self.match(NeoBasicParser.ASSERT)
            self.state = 2380
            self.expression(0)
            self.state = 2384
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,200,self._ctx)
            if la_ == 1:
                self.state = 2381
                self.match(NeoBasicParser.EXCLAMATION)

            elif la_ == 2:
                self.state = 2382
                self.match(NeoBasicParser.EXCLAMATION)
                self.state = 2383
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnitTestStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unitClause(self):
            return self.getTypedRuleContext(NeoBasicParser.UnitClauseContext,0)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def fromClause(self):
            return self.getTypedRuleContext(NeoBasicParser.FromClauseContext,0)


        def onceClause(self):
            return self.getTypedRuleContext(NeoBasicParser.OnceClauseContext,0)


        def dataClause(self):
            return self.getTypedRuleContext(NeoBasicParser.DataClauseContext,0)


        def callClause(self):
            return self.getTypedRuleContext(NeoBasicParser.CallClauseContext,0)


        def hideClause(self):
            return self.getTypedRuleContext(NeoBasicParser.HideClauseContext,0)


        def showClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ShowClauseContext,0)


        def stayClause(self):
            return self.getTypedRuleContext(NeoBasicParser.StayClauseContext,0)


        def passClause(self):
            return self.getTypedRuleContext(NeoBasicParser.PassClauseContext,0)


        def pastClause(self):
            return self.getTypedRuleContext(NeoBasicParser.PastClauseContext,0)


        def failClause(self):
            return self.getTypedRuleContext(NeoBasicParser.FailClauseContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_unitTestStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnitTestStatement" ):
                listener.enterUnitTestStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnitTestStatement" ):
                listener.exitUnitTestStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnitTestStatement" ):
                return visitor.visitUnitTestStatement(self)
            else:
                return visitor.visitChildren(self)




    def unitTestStatement(self):

        localctx = NeoBasicParser.UnitTestStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 544, self.RULE_unitTestStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2386
            self.unitClause()
            self.state = 2389
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,201,self._ctx)
            if la_ == 1:
                self.state = 2387
                self.match(NeoBasicParser.EOS)
                self.state = 2388
                self.fromClause()


            self.state = 2393
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,202,self._ctx)
            if la_ == 1:
                self.state = 2391
                self.match(NeoBasicParser.EOS)
                self.state = 2392
                self.onceClause()


            self.state = 2397
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,203,self._ctx)
            if la_ == 1:
                self.state = 2395
                self.match(NeoBasicParser.EOS)
                self.state = 2396
                self.dataClause()


            self.state = 2401
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,204,self._ctx)
            if la_ == 1:
                self.state = 2399
                self.match(NeoBasicParser.EOS)
                self.state = 2400
                self.callClause()


            self.state = 2405
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,205,self._ctx)
            if la_ == 1:
                self.state = 2403
                self.match(NeoBasicParser.EOS)
                self.state = 2404
                self.hideClause()


            self.state = 2409
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,206,self._ctx)
            if la_ == 1:
                self.state = 2407
                self.match(NeoBasicParser.EOS)
                self.state = 2408
                self.showClause()


            self.state = 2413
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,207,self._ctx)
            if la_ == 1:
                self.state = 2411
                self.match(NeoBasicParser.EOS)
                self.state = 2412
                self.stayClause()


            self.state = 2417
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,208,self._ctx)
            if la_ == 1:
                self.state = 2415
                self.match(NeoBasicParser.EOS)
                self.state = 2416
                self.passClause()


            self.state = 2421
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,209,self._ctx)
            if la_ == 1:
                self.state = 2419
                self.match(NeoBasicParser.EOS)
                self.state = 2420
                self.pastClause()


            self.state = 2425
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,210,self._ctx)
            if la_ == 1:
                self.state = 2423
                self.match(NeoBasicParser.EOS)
                self.state = 2424
                self.failClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnitClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNIT(self):
            return self.getToken(NeoBasicParser.UNIT, 0)

        def sequenceLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.SequenceLiteralContext,0)


        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_unitClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnitClause" ):
                listener.enterUnitClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnitClause" ):
                listener.exitUnitClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnitClause" ):
                return visitor.visitUnitClause(self)
            else:
                return visitor.visitChildren(self)




    def unitClause(self):

        localctx = NeoBasicParser.UnitClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 546, self.RULE_unitClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2427
            self.match(NeoBasicParser.UNIT)
            self.state = 2429
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,211,self._ctx)
            if la_ == 1:
                self.state = 2428
                self.sequenceLiteral()


            self.state = 2432
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,212,self._ctx)
            if la_ == 1:
                self.state = 2431
                self.logicalInstructionSuite()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FromClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FROM(self):
            return self.getToken(NeoBasicParser.FROM, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_fromClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFromClause" ):
                listener.enterFromClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFromClause" ):
                listener.exitFromClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFromClause" ):
                return visitor.visitFromClause(self)
            else:
                return visitor.visitChildren(self)




    def fromClause(self):

        localctx = NeoBasicParser.FromClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 548, self.RULE_fromClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2434
            self.match(NeoBasicParser.FROM)
            self.state = 2437
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [21, 23, 24, 25, 26, 27, 39, 40, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 141, 142, 143, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 321, 322, 323, 324, 325, 326, 327, 328, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 349, 370, 372, 415, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 466, 468, 470, 485, 486, 487, 496, 497]:
                self.state = 2435
                self.expressions()
                pass
            elif token in [457]:
                self.state = 2436
                self.logicalInstructionSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnceClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ONCE(self):
            return self.getToken(NeoBasicParser.ONCE, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_onceClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnceClause" ):
                listener.enterOnceClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnceClause" ):
                listener.exitOnceClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnceClause" ):
                return visitor.visitOnceClause(self)
            else:
                return visitor.visitChildren(self)




    def onceClause(self):

        localctx = NeoBasicParser.OnceClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 550, self.RULE_onceClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2439
            self.match(NeoBasicParser.ONCE)
            self.state = 2442
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [21, 23, 24, 25, 26, 27, 39, 40, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 141, 142, 143, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 321, 322, 323, 324, 325, 326, 327, 328, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 349, 370, 372, 415, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 466, 468, 470, 485, 486, 487, 496, 497]:
                self.state = 2440
                self.expressions()
                pass
            elif token in [457]:
                self.state = 2441
                self.logicalInstructionSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATA(self):
            return self.getToken(NeoBasicParser.DATA, 0)

        def EOS(self):
            return self.getToken(NeoBasicParser.EOS, 0)

        def INDENT(self):
            return self.getToken(NeoBasicParser.INDENT, 0)

        def dataTable(self):
            return self.getTypedRuleContext(NeoBasicParser.DataTableContext,0)


        def DEDENT(self):
            return self.getToken(NeoBasicParser.DEDENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_dataClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataClause" ):
                listener.enterDataClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataClause" ):
                listener.exitDataClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataClause" ):
                return visitor.visitDataClause(self)
            else:
                return visitor.visitChildren(self)




    def dataClause(self):

        localctx = NeoBasicParser.DataClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 552, self.RULE_dataClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2444
            self.match(NeoBasicParser.DATA)
            self.state = 2445
            self.match(NeoBasicParser.EOS)
            self.state = 2446
            self.match(NeoBasicParser.INDENT)
            self.state = 2447
            self.dataTable()
            self.state = 2448
            self.match(NeoBasicParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataTableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dataRow(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.DataRowContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.DataRowContext,i)


        def EOS(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.EOS)
            else:
                return self.getToken(NeoBasicParser.EOS, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_dataTable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataTable" ):
                listener.enterDataTable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataTable" ):
                listener.exitDataTable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataTable" ):
                return visitor.visitDataTable(self)
            else:
                return visitor.visitChildren(self)




    def dataTable(self):

        localctx = NeoBasicParser.DataTableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 554, self.RULE_dataTable)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2450
            self.dataRow()
            self.state = 2455
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==457:
                self.state = 2451
                self.match(NeoBasicParser.EOS)
                self.state = 2452
                self.dataRow()
                self.state = 2457
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataRowContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,i)


        def PIPE(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.PIPE)
            else:
                return self.getToken(NeoBasicParser.PIPE, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_dataRow

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataRow" ):
                listener.enterDataRow(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataRow" ):
                listener.exitDataRow(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataRow" ):
                return visitor.visitDataRow(self)
            else:
                return visitor.visitChildren(self)




    def dataRow(self):

        localctx = NeoBasicParser.DataRowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 556, self.RULE_dataRow)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2458
            self.expression(0)
            self.state = 2463
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==485:
                self.state = 2459
                self.match(NeoBasicParser.PIPE)
                self.state = 2460
                self.expression(0)
                self.state = 2465
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CallClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CALL(self):
            return self.getToken(NeoBasicParser.CALL, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_callClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCallClause" ):
                listener.enterCallClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCallClause" ):
                listener.exitCallClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCallClause" ):
                return visitor.visitCallClause(self)
            else:
                return visitor.visitChildren(self)




    def callClause(self):

        localctx = NeoBasicParser.CallClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 558, self.RULE_callClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2466
            self.match(NeoBasicParser.CALL)
            self.state = 2469
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [21, 23, 24, 25, 26, 27, 39, 40, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 141, 142, 143, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 321, 322, 323, 324, 325, 326, 327, 328, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 349, 370, 372, 415, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 466, 468, 470, 485, 486, 487, 496, 497]:
                self.state = 2467
                self.expressions()
                pass
            elif token in [457]:
                self.state = 2468
                self.logicalInstructionSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HideClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HIDE(self):
            return self.getToken(NeoBasicParser.HIDE, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_hideClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHideClause" ):
                listener.enterHideClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHideClause" ):
                listener.exitHideClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHideClause" ):
                return visitor.visitHideClause(self)
            else:
                return visitor.visitChildren(self)




    def hideClause(self):

        localctx = NeoBasicParser.HideClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 560, self.RULE_hideClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2471
            self.match(NeoBasicParser.HIDE)
            self.state = 2474
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [21, 23, 24, 25, 26, 27, 39, 40, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 141, 142, 143, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 321, 322, 323, 324, 325, 326, 327, 328, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 349, 370, 372, 415, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 466, 468, 470, 485, 486, 487, 496, 497]:
                self.state = 2472
                self.expressions()
                pass
            elif token in [457]:
                self.state = 2473
                self.logicalInstructionSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShowClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW(self):
            return self.getToken(NeoBasicParser.SHOW, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_showClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShowClause" ):
                listener.enterShowClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShowClause" ):
                listener.exitShowClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowClause" ):
                return visitor.visitShowClause(self)
            else:
                return visitor.visitChildren(self)




    def showClause(self):

        localctx = NeoBasicParser.ShowClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 562, self.RULE_showClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2476
            self.match(NeoBasicParser.SHOW)
            self.state = 2479
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [21, 23, 24, 25, 26, 27, 39, 40, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 141, 142, 143, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 321, 322, 323, 324, 325, 326, 327, 328, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 349, 370, 372, 415, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 466, 468, 470, 485, 486, 487, 496, 497]:
                self.state = 2477
                self.expressions()
                pass
            elif token in [457]:
                self.state = 2478
                self.logicalInstructionSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StayClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STAY(self):
            return self.getToken(NeoBasicParser.STAY, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_stayClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStayClause" ):
                listener.enterStayClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStayClause" ):
                listener.exitStayClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStayClause" ):
                return visitor.visitStayClause(self)
            else:
                return visitor.visitChildren(self)




    def stayClause(self):

        localctx = NeoBasicParser.StayClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 564, self.RULE_stayClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2481
            self.match(NeoBasicParser.STAY)
            self.state = 2484
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [21, 23, 24, 25, 26, 27, 39, 40, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 141, 142, 143, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 321, 322, 323, 324, 325, 326, 327, 328, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 349, 370, 372, 415, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 466, 468, 470, 485, 486, 487, 496, 497]:
                self.state = 2482
                self.expressions()
                pass
            elif token in [457]:
                self.state = 2483
                self.logicalInstructionSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PassClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PASS(self):
            return self.getToken(NeoBasicParser.PASS, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_passClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPassClause" ):
                listener.enterPassClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPassClause" ):
                listener.exitPassClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPassClause" ):
                return visitor.visitPassClause(self)
            else:
                return visitor.visitChildren(self)




    def passClause(self):

        localctx = NeoBasicParser.PassClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 566, self.RULE_passClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2486
            self.match(NeoBasicParser.PASS)
            self.state = 2489
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [21, 23, 24, 25, 26, 27, 39, 40, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 141, 142, 143, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 321, 322, 323, 324, 325, 326, 327, 328, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 349, 370, 372, 415, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 466, 468, 470, 485, 486, 487, 496, 497]:
                self.state = 2487
                self.expressions()
                pass
            elif token in [457]:
                self.state = 2488
                self.logicalInstructionSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PastClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PAST(self):
            return self.getToken(NeoBasicParser.PAST, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_pastClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPastClause" ):
                listener.enterPastClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPastClause" ):
                listener.exitPastClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPastClause" ):
                return visitor.visitPastClause(self)
            else:
                return visitor.visitChildren(self)




    def pastClause(self):

        localctx = NeoBasicParser.PastClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 568, self.RULE_pastClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2491
            self.match(NeoBasicParser.PAST)
            self.state = 2494
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [21, 23, 24, 25, 26, 27, 39, 40, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 141, 142, 143, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 321, 322, 323, 324, 325, 326, 327, 328, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 349, 370, 372, 415, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 466, 468, 470, 485, 486, 487, 496, 497]:
                self.state = 2492
                self.expressions()
                pass
            elif token in [457]:
                self.state = 2493
                self.logicalInstructionSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FailClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FAIL(self):
            return self.getToken(NeoBasicParser.FAIL, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_failClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFailClause" ):
                listener.enterFailClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFailClause" ):
                listener.exitFailClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFailClause" ):
                return visitor.visitFailClause(self)
            else:
                return visitor.visitChildren(self)




    def failClause(self):

        localctx = NeoBasicParser.FailClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 570, self.RULE_failClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2496
            self.match(NeoBasicParser.FAIL)
            self.state = 2499
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [21, 23, 24, 25, 26, 27, 39, 40, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 141, 142, 143, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 321, 322, 323, 324, 325, 326, 327, 328, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 349, 370, 372, 415, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 466, 468, 470, 485, 486, 487, 496, 497]:
                self.state = 2497
                self.expressions()
                pass
            elif token in [457]:
                self.state = 2498
                self.logicalInstructionSuite()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrefixUnaryOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unaryArithmeticOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnaryArithmeticOperatorContext,0)


        def unarySpreadOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnarySpreadOperatorContext,0)


        def unaryLogicalOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnaryLogicalOperatorContext,0)


        def unaryArrayOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnaryArrayOperatorContext,0)


        def unaryCloneOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnaryCloneOperatorContext,0)


        def unaryMoveOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnaryMoveOperatorContext,0)


        def unaryMetaOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnaryMetaOperatorContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_prefixUnaryOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrefixUnaryOperator" ):
                listener.enterPrefixUnaryOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrefixUnaryOperator" ):
                listener.exitPrefixUnaryOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrefixUnaryOperator" ):
                return visitor.visitPrefixUnaryOperator(self)
            else:
                return visitor.visitChildren(self)




    def prefixUnaryOperator(self):

        localctx = NeoBasicParser.PrefixUnaryOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 572, self.RULE_prefixUnaryOperator)
        try:
            self.state = 2508
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [321, 322, 323, 324, 325, 326, 327]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2501
                self.unaryArithmeticOperator()
                pass
            elif token in [328]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2502
                self.unarySpreadOperator()
                pass
            elif token in [157]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2503
                self.unaryLogicalOperator()
                pass
            elif token in [160]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2504
                self.unaryArrayOperator()
                pass
            elif token in [158]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2505
                self.unaryCloneOperator()
                pass
            elif token in [159]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2506
                self.unaryMoveOperator()
                pass
            elif token in [142, 143]:
                self.enterOuterAlt(localctx, 7)
                self.state = 2507
                self.unaryMetaOperator()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryArithmeticOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CARET(self):
            return self.getToken(NeoBasicParser.CARET, 0)

        def SQUARE_ROOT(self):
            return self.getToken(NeoBasicParser.SQUARE_ROOT, 0)

        def FACTORIAL(self):
            return self.getToken(NeoBasicParser.FACTORIAL, 0)

        def INCREMENT(self):
            return self.getToken(NeoBasicParser.INCREMENT, 0)

        def DECREMENT(self):
            return self.getToken(NeoBasicParser.DECREMENT, 0)

        def PLUS(self):
            return self.getToken(NeoBasicParser.PLUS, 0)

        def HYPHEN(self):
            return self.getToken(NeoBasicParser.HYPHEN, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_unaryArithmeticOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryArithmeticOperator" ):
                listener.enterUnaryArithmeticOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryArithmeticOperator" ):
                listener.exitUnaryArithmeticOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryArithmeticOperator" ):
                return visitor.visitUnaryArithmeticOperator(self)
            else:
                return visitor.visitChildren(self)




    def unaryArithmeticOperator(self):

        localctx = NeoBasicParser.UnaryArithmeticOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 574, self.RULE_unaryArithmeticOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2510
            _la = self._input.LA(1)
            if not(((((_la - 321)) & ~0x3f) == 0 and ((1 << (_la - 321)) & 127) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryLogicalOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOT(self):
            return self.getToken(NeoBasicParser.NOT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_unaryLogicalOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryLogicalOperator" ):
                listener.enterUnaryLogicalOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryLogicalOperator" ):
                listener.exitUnaryLogicalOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryLogicalOperator" ):
                return visitor.visitUnaryLogicalOperator(self)
            else:
                return visitor.visitChildren(self)




    def unaryLogicalOperator(self):

        localctx = NeoBasicParser.UnaryLogicalOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 576, self.RULE_unaryLogicalOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2512
            self.match(NeoBasicParser.NOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryArrayOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEL(self):
            return self.getToken(NeoBasicParser.DEL, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_unaryArrayOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryArrayOperator" ):
                listener.enterUnaryArrayOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryArrayOperator" ):
                listener.exitUnaryArrayOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryArrayOperator" ):
                return visitor.visitUnaryArrayOperator(self)
            else:
                return visitor.visitChildren(self)




    def unaryArrayOperator(self):

        localctx = NeoBasicParser.UnaryArrayOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 578, self.RULE_unaryArrayOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2514
            self.match(NeoBasicParser.DEL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnarySpreadOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELLIPSIS(self):
            return self.getToken(NeoBasicParser.ELLIPSIS, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_unarySpreadOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnarySpreadOperator" ):
                listener.enterUnarySpreadOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnarySpreadOperator" ):
                listener.exitUnarySpreadOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnarySpreadOperator" ):
                return visitor.visitUnarySpreadOperator(self)
            else:
                return visitor.visitChildren(self)




    def unarySpreadOperator(self):

        localctx = NeoBasicParser.UnarySpreadOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 580, self.RULE_unarySpreadOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2516
            self.match(NeoBasicParser.ELLIPSIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryCloneOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEW(self):
            return self.getToken(NeoBasicParser.NEW, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_unaryCloneOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryCloneOperator" ):
                listener.enterUnaryCloneOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryCloneOperator" ):
                listener.exitUnaryCloneOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryCloneOperator" ):
                return visitor.visitUnaryCloneOperator(self)
            else:
                return visitor.visitChildren(self)




    def unaryCloneOperator(self):

        localctx = NeoBasicParser.UnaryCloneOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 582, self.RULE_unaryCloneOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2518
            self.match(NeoBasicParser.NEW)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryMoveOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAB(self):
            return self.getToken(NeoBasicParser.NAB, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_unaryMoveOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryMoveOperator" ):
                listener.enterUnaryMoveOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryMoveOperator" ):
                listener.exitUnaryMoveOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryMoveOperator" ):
                return visitor.visitUnaryMoveOperator(self)
            else:
                return visitor.visitChildren(self)




    def unaryMoveOperator(self):

        localctx = NeoBasicParser.UnaryMoveOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 584, self.RULE_unaryMoveOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2520
            self.match(NeoBasicParser.NAB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryMetaOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPEOF(self):
            return self.getToken(NeoBasicParser.TYPEOF, 0)

        def SIZEOF(self):
            return self.getToken(NeoBasicParser.SIZEOF, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_unaryMetaOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryMetaOperator" ):
                listener.enterUnaryMetaOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryMetaOperator" ):
                listener.exitUnaryMetaOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryMetaOperator" ):
                return visitor.visitUnaryMetaOperator(self)
            else:
                return visitor.visitChildren(self)




    def unaryMetaOperator(self):

        localctx = NeoBasicParser.UnaryMetaOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 586, self.RULE_unaryMetaOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2522
            _la = self._input.LA(1)
            if not(_la==142 or _la==143):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryArithmeticOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def binaryExponentialOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryExponentialOperatorContext,0)


        def binaryMultiplicativeOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryMultiplicativeOperatorContext,0)


        def binaryAdditiveOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryAdditiveOperatorContext,0)


        def bitShiftOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BitShiftOperatorContext,0)


        def binaryConjunctionOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryConjunctionOperatorContext,0)


        def binaryExclusiveDisjunctionOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryExclusiveDisjunctionOperatorContext,0)


        def binaryDisjunctionOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryDisjunctionOperatorContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryArithmeticOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryArithmeticOperator" ):
                listener.enterBinaryArithmeticOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryArithmeticOperator" ):
                listener.exitBinaryArithmeticOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryArithmeticOperator" ):
                return visitor.visitBinaryArithmeticOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryArithmeticOperator(self):

        localctx = NeoBasicParser.BinaryArithmeticOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 588, self.RULE_binaryArithmeticOperator)
        try:
            self.state = 2531
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [321, 322]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2524
                self.binaryExponentialOperator()
                pass
            elif token in [330, 331, 332, 333, 334, 335, 336, 337, 338, 339]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2525
                self.binaryMultiplicativeOperator()
                pass
            elif token in [326, 327]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2526
                self.binaryAdditiveOperator()
                pass
            elif token in [340, 341, 342]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2527
                self.bitShiftOperator()
                pass
            elif token in [150, 151, 152]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2528
                self.binaryConjunctionOperator()
                pass
            elif token in [155, 156]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2529
                self.binaryExclusiveDisjunctionOperator()
                pass
            elif token in [153, 154]:
                self.enterOuterAlt(localctx, 7)
                self.state = 2530
                self.binaryDisjunctionOperator()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryExponentialOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CARET(self):
            return self.getToken(NeoBasicParser.CARET, 0)

        def SQUARE_ROOT(self):
            return self.getToken(NeoBasicParser.SQUARE_ROOT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryExponentialOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryExponentialOperator" ):
                listener.enterBinaryExponentialOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryExponentialOperator" ):
                listener.exitBinaryExponentialOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryExponentialOperator" ):
                return visitor.visitBinaryExponentialOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryExponentialOperator(self):

        localctx = NeoBasicParser.BinaryExponentialOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 590, self.RULE_binaryExponentialOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2533
            _la = self._input.LA(1)
            if not(_la==321 or _la==322):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryMultiplicativeOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASTERISK(self):
            return self.getToken(NeoBasicParser.ASTERISK, 0)

        def SLASH(self):
            return self.getToken(NeoBasicParser.SLASH, 0)

        def DIVISION(self):
            return self.getToken(NeoBasicParser.DIVISION, 0)

        def PERCENT(self):
            return self.getToken(NeoBasicParser.PERCENT, 0)

        def QUOTIENT(self):
            return self.getToken(NeoBasicParser.QUOTIENT, 0)

        def PERCENTAGE_RATE(self):
            return self.getToken(NeoBasicParser.PERCENTAGE_RATE, 0)

        def PERCENTAGE_AMOUNT(self):
            return self.getToken(NeoBasicParser.PERCENTAGE_AMOUNT, 0)

        def PERCENTAGE_INCREASE(self):
            return self.getToken(NeoBasicParser.PERCENTAGE_INCREASE, 0)

        def PERCENTAGE_DECREASE(self):
            return self.getToken(NeoBasicParser.PERCENTAGE_DECREASE, 0)

        def PERCENTAGE_VARIATION(self):
            return self.getToken(NeoBasicParser.PERCENTAGE_VARIATION, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryMultiplicativeOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryMultiplicativeOperator" ):
                listener.enterBinaryMultiplicativeOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryMultiplicativeOperator" ):
                listener.exitBinaryMultiplicativeOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryMultiplicativeOperator" ):
                return visitor.visitBinaryMultiplicativeOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryMultiplicativeOperator(self):

        localctx = NeoBasicParser.BinaryMultiplicativeOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 592, self.RULE_binaryMultiplicativeOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2535
            _la = self._input.LA(1)
            if not(((((_la - 330)) & ~0x3f) == 0 and ((1 << (_la - 330)) & 1023) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryAdditiveOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(NeoBasicParser.PLUS, 0)

        def HYPHEN(self):
            return self.getToken(NeoBasicParser.HYPHEN, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryAdditiveOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryAdditiveOperator" ):
                listener.enterBinaryAdditiveOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryAdditiveOperator" ):
                listener.exitBinaryAdditiveOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryAdditiveOperator" ):
                return visitor.visitBinaryAdditiveOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryAdditiveOperator(self):

        localctx = NeoBasicParser.BinaryAdditiveOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 594, self.RULE_binaryAdditiveOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2537
            _la = self._input.LA(1)
            if not(_la==326 or _la==327):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BitShiftOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOUBLE_LEFT_ANGLE(self):
            return self.getToken(NeoBasicParser.DOUBLE_LEFT_ANGLE, 0)

        def DOUBLE_RIGHT_ANGLE(self):
            return self.getToken(NeoBasicParser.DOUBLE_RIGHT_ANGLE, 0)

        def UNSIGNED_RIGHT_SHIFT(self):
            return self.getToken(NeoBasicParser.UNSIGNED_RIGHT_SHIFT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_bitShiftOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitShiftOperator" ):
                listener.enterBitShiftOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitShiftOperator" ):
                listener.exitBitShiftOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBitShiftOperator" ):
                return visitor.visitBitShiftOperator(self)
            else:
                return visitor.visitChildren(self)




    def bitShiftOperator(self):

        localctx = NeoBasicParser.BitShiftOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 596, self.RULE_bitShiftOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2539
            _la = self._input.LA(1)
            if not(((((_la - 340)) & ~0x3f) == 0 and ((1 << (_la - 340)) & 7) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryConjunctionOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AND(self):
            return self.getToken(NeoBasicParser.AND, 0)

        def ANDN(self):
            return self.getToken(NeoBasicParser.ANDN, 0)

        def NAND(self):
            return self.getToken(NeoBasicParser.NAND, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryConjunctionOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryConjunctionOperator" ):
                listener.enterBinaryConjunctionOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryConjunctionOperator" ):
                listener.exitBinaryConjunctionOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryConjunctionOperator" ):
                return visitor.visitBinaryConjunctionOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryConjunctionOperator(self):

        localctx = NeoBasicParser.BinaryConjunctionOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 598, self.RULE_binaryConjunctionOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2541
            _la = self._input.LA(1)
            if not(((((_la - 150)) & ~0x3f) == 0 and ((1 << (_la - 150)) & 7) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryExclusiveDisjunctionOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def XOR(self):
            return self.getToken(NeoBasicParser.XOR, 0)

        def NXOR(self):
            return self.getToken(NeoBasicParser.NXOR, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryExclusiveDisjunctionOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryExclusiveDisjunctionOperator" ):
                listener.enterBinaryExclusiveDisjunctionOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryExclusiveDisjunctionOperator" ):
                listener.exitBinaryExclusiveDisjunctionOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryExclusiveDisjunctionOperator" ):
                return visitor.visitBinaryExclusiveDisjunctionOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryExclusiveDisjunctionOperator(self):

        localctx = NeoBasicParser.BinaryExclusiveDisjunctionOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 600, self.RULE_binaryExclusiveDisjunctionOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2543
            _la = self._input.LA(1)
            if not(_la==155 or _la==156):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryDisjunctionOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OR(self):
            return self.getToken(NeoBasicParser.OR, 0)

        def NOR(self):
            return self.getToken(NeoBasicParser.NOR, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryDisjunctionOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryDisjunctionOperator" ):
                listener.enterBinaryDisjunctionOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryDisjunctionOperator" ):
                listener.exitBinaryDisjunctionOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryDisjunctionOperator" ):
                return visitor.visitBinaryDisjunctionOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryDisjunctionOperator(self):

        localctx = NeoBasicParser.BinaryDisjunctionOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 602, self.RULE_binaryDisjunctionOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2545
            _la = self._input.LA(1)
            if not(_la==153 or _la==154):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryArrayOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNION(self):
            return self.getToken(NeoBasicParser.UNION, 0)

        def UNITE(self):
            return self.getToken(NeoBasicParser.UNITE, 0)

        def INTER(self):
            return self.getToken(NeoBasicParser.INTER, 0)

        def MINUS(self):
            return self.getToken(NeoBasicParser.MINUS, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryArrayOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryArrayOperator" ):
                listener.enterBinaryArrayOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryArrayOperator" ):
                listener.exitBinaryArrayOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryArrayOperator" ):
                return visitor.visitBinaryArrayOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryArrayOperator(self):

        localctx = NeoBasicParser.BinaryArrayOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 604, self.RULE_binaryArrayOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2547
            _la = self._input.LA(1)
            if not(((((_la - 161)) & ~0x3f) == 0 and ((1 << (_la - 161)) & 15) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryComparisonOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELVIS_TEST(self):
            return self.getToken(NeoBasicParser.ELVIS_TEST, 0)

        def THREE_WAY_TEST(self):
            return self.getToken(NeoBasicParser.THREE_WAY_TEST, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryComparisonOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryComparisonOperator" ):
                listener.enterBinaryComparisonOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryComparisonOperator" ):
                listener.exitBinaryComparisonOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryComparisonOperator" ):
                return visitor.visitBinaryComparisonOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryComparisonOperator(self):

        localctx = NeoBasicParser.BinaryComparisonOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 606, self.RULE_binaryComparisonOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2549
            _la = self._input.LA(1)
            if not(_la==343 or _la==344):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryRelationalOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRICT_EQUALITY(self):
            return self.getToken(NeoBasicParser.STRICT_EQUALITY, 0)

        def STRICT_INEQUALITY(self):
            return self.getToken(NeoBasicParser.STRICT_INEQUALITY, 0)

        def LOOSE_EQUALITY(self):
            return self.getToken(NeoBasicParser.LOOSE_EQUALITY, 0)

        def LOOSE_INEQUALITY(self):
            return self.getToken(NeoBasicParser.LOOSE_INEQUALITY, 0)

        def LEFT_ANGLE(self):
            return self.getToken(NeoBasicParser.LEFT_ANGLE, 0)

        def LESS_OR_EQUALS(self):
            return self.getToken(NeoBasicParser.LESS_OR_EQUALS, 0)

        def RIGHT_ANGLE(self):
            return self.getToken(NeoBasicParser.RIGHT_ANGLE, 0)

        def GREATER_OR_EQUALS(self):
            return self.getToken(NeoBasicParser.GREATER_OR_EQUALS, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryRelationalOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryRelationalOperator" ):
                listener.enterBinaryRelationalOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryRelationalOperator" ):
                listener.exitBinaryRelationalOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryRelationalOperator" ):
                return visitor.visitBinaryRelationalOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryRelationalOperator(self):

        localctx = NeoBasicParser.BinaryRelationalOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 608, self.RULE_binaryRelationalOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2551
            _la = self._input.LA(1)
            if not(((((_la - 345)) & ~0x3f) == 0 and ((1 << (_la - 345)) & 255) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryConditionalOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IS(self):
            return self.getToken(NeoBasicParser.IS, 0)

        def IS_NOT(self):
            return self.getToken(NeoBasicParser.IS_NOT, 0)

        def NOT_IS(self):
            return self.getToken(NeoBasicParser.NOT_IS, 0)

        def IN(self):
            return self.getToken(NeoBasicParser.IN, 0)

        def NOT_IN(self):
            return self.getToken(NeoBasicParser.NOT_IN, 0)

        def BETWEEN(self):
            return self.getToken(NeoBasicParser.BETWEEN, 0)

        def NOT_BETWEEN(self):
            return self.getToken(NeoBasicParser.NOT_BETWEEN, 0)

        def LIKE(self):
            return self.getToken(NeoBasicParser.LIKE, 0)

        def NOT_LIKE(self):
            return self.getToken(NeoBasicParser.NOT_LIKE, 0)

        def DIVISIBLE_BY(self):
            return self.getToken(NeoBasicParser.DIVISIBLE_BY, 0)

        def NOT_DIVISIBLE_BY(self):
            return self.getToken(NeoBasicParser.NOT_DIVISIBLE_BY, 0)

        def INSTANCEOF(self):
            return self.getToken(NeoBasicParser.INSTANCEOF, 0)

        def NOT_INSTANCEOF(self):
            return self.getToken(NeoBasicParser.NOT_INSTANCEOF, 0)

        def ANCESTOROF(self):
            return self.getToken(NeoBasicParser.ANCESTOROF, 0)

        def NOT_ANCESTOROF(self):
            return self.getToken(NeoBasicParser.NOT_ANCESTOROF, 0)

        def EXTENDS(self):
            return self.getToken(NeoBasicParser.EXTENDS, 0)

        def NOT_EXTENDS(self):
            return self.getToken(NeoBasicParser.NOT_EXTENDS, 0)

        def IMPLEMENTS(self):
            return self.getToken(NeoBasicParser.IMPLEMENTS, 0)

        def NOT_IMPLEMENTS(self):
            return self.getToken(NeoBasicParser.NOT_IMPLEMENTS, 0)

        def MIXES(self):
            return self.getToken(NeoBasicParser.MIXES, 0)

        def NOT_MIXES(self):
            return self.getToken(NeoBasicParser.NOT_MIXES, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryConditionalOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryConditionalOperator" ):
                listener.enterBinaryConditionalOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryConditionalOperator" ):
                listener.exitBinaryConditionalOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryConditionalOperator" ):
                return visitor.visitBinaryConditionalOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryConditionalOperator(self):

        localctx = NeoBasicParser.BinaryConditionalOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 610, self.RULE_binaryConditionalOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2553
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 60129542144) != 0) or ((((_la - 144)) & ~0x3f) == 0 and ((1 << (_la - 144)) & 63) != 0) or ((((_la - 353)) & ~0x3f) == 0 and ((1 << (_la - 353)) & 4095) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryMonadBindOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MONAD_BIND(self):
            return self.getToken(NeoBasicParser.MONAD_BIND, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryMonadBindOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryMonadBindOperator" ):
                listener.enterBinaryMonadBindOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryMonadBindOperator" ):
                listener.exitBinaryMonadBindOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryMonadBindOperator" ):
                return visitor.visitBinaryMonadBindOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryMonadBindOperator(self):

        localctx = NeoBasicParser.BinaryMonadBindOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 612, self.RULE_binaryMonadBindOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2555
            self.match(NeoBasicParser.MONAD_BIND)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryPipelineOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PIPELINE(self):
            return self.getToken(NeoBasicParser.PIPELINE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_binaryPipelineOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryPipelineOperator" ):
                listener.enterBinaryPipelineOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryPipelineOperator" ):
                listener.exitBinaryPipelineOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryPipelineOperator" ):
                return visitor.visitBinaryPipelineOperator(self)
            else:
                return visitor.visitChildren(self)




    def binaryPipelineOperator(self):

        localctx = NeoBasicParser.BinaryPipelineOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 614, self.RULE_binaryPipelineOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2557
            self.match(NeoBasicParser.PIPELINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CoalescingOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXCLAMATION(self):
            return self.getToken(NeoBasicParser.EXCLAMATION, 0)

        def DOUBLE_EXCLAMATION(self):
            return self.getToken(NeoBasicParser.DOUBLE_EXCLAMATION, 0)

        def QUESTION(self):
            return self.getToken(NeoBasicParser.QUESTION, 0)

        def DOUBLE_QUESTION(self):
            return self.getToken(NeoBasicParser.DOUBLE_QUESTION, 0)

        def ERROR_NONE_COALESCING(self):
            return self.getToken(NeoBasicParser.ERROR_NONE_COALESCING, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_coalescingOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoalescingOperator" ):
                listener.enterCoalescingOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoalescingOperator" ):
                listener.exitCoalescingOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCoalescingOperator" ):
                return visitor.visitCoalescingOperator(self)
            else:
                return visitor.visitChildren(self)




    def coalescingOperator(self):

        localctx = NeoBasicParser.CoalescingOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 616, self.RULE_coalescingOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2559
            _la = self._input.LA(1)
            if not(((((_la - 365)) & ~0x3f) == 0 and ((1 << (_la - 365)) & 31) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExecutionFlowOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXECUTE_SEQUENCE(self):
            return self.getToken(NeoBasicParser.EXECUTE_SEQUENCE, 0)

        def EXECUTE_SEQUENCE_OKAY(self):
            return self.getToken(NeoBasicParser.EXECUTE_SEQUENCE_OKAY, 0)

        def EXECUTE_SEQUENCE_FAIL(self):
            return self.getToken(NeoBasicParser.EXECUTE_SEQUENCE_FAIL, 0)

        def EXECUTE_BACKGROUND(self):
            return self.getToken(NeoBasicParser.EXECUTE_BACKGROUND, 0)

        def OUTPUT_REDIRECTION(self):
            return self.getToken(NeoBasicParser.OUTPUT_REDIRECTION, 0)

        def APPEND_OUTPUT_REDIRECTION(self):
            return self.getToken(NeoBasicParser.APPEND_OUTPUT_REDIRECTION, 0)

        def STDOUT_REDIRECTION(self):
            return self.getToken(NeoBasicParser.STDOUT_REDIRECTION, 0)

        def APPEND_STDOUT_REDIRECTION(self):
            return self.getToken(NeoBasicParser.APPEND_STDOUT_REDIRECTION, 0)

        def STDERR_REDIRECTION(self):
            return self.getToken(NeoBasicParser.STDERR_REDIRECTION, 0)

        def APPEND_STDERR_REDIRECTION(self):
            return self.getToken(NeoBasicParser.APPEND_STDERR_REDIRECTION, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_executionFlowOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExecutionFlowOperator" ):
                listener.enterExecutionFlowOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExecutionFlowOperator" ):
                listener.exitExecutionFlowOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExecutionFlowOperator" ):
                return visitor.visitExecutionFlowOperator(self)
            else:
                return visitor.visitChildren(self)




    def executionFlowOperator(self):

        localctx = NeoBasicParser.ExecutionFlowOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 618, self.RULE_executionFlowOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2561
            _la = self._input.LA(1)
            if not(((((_la - 379)) & ~0x3f) == 0 and ((1 << (_la - 379)) & 1023) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntervalOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTERVAL_INCLUSIVE(self):
            return self.getToken(NeoBasicParser.INTERVAL_INCLUSIVE, 0)

        def INTERVAL_LEFT_EXCLUSIVE(self):
            return self.getToken(NeoBasicParser.INTERVAL_LEFT_EXCLUSIVE, 0)

        def INTERVAL_RIGHT_EXCLUSIVE(self):
            return self.getToken(NeoBasicParser.INTERVAL_RIGHT_EXCLUSIVE, 0)

        def INTERVAL_EXCLUSIVE(self):
            return self.getToken(NeoBasicParser.INTERVAL_EXCLUSIVE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_intervalOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntervalOperator" ):
                listener.enterIntervalOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntervalOperator" ):
                listener.exitIntervalOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntervalOperator" ):
                return visitor.visitIntervalOperator(self)
            else:
                return visitor.visitChildren(self)




    def intervalOperator(self):

        localctx = NeoBasicParser.IntervalOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 620, self.RULE_intervalOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2563
            _la = self._input.LA(1)
            if not(((((_la - 370)) & ~0x3f) == 0 and ((1 << (_la - 370)) & 15) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LeftIntervalOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTERVAL_INCLUSIVE(self):
            return self.getToken(NeoBasicParser.INTERVAL_INCLUSIVE, 0)

        def INTERVAL_LEFT_EXCLUSIVE(self):
            return self.getToken(NeoBasicParser.INTERVAL_LEFT_EXCLUSIVE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_leftIntervalOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLeftIntervalOperator" ):
                listener.enterLeftIntervalOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLeftIntervalOperator" ):
                listener.exitLeftIntervalOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLeftIntervalOperator" ):
                return visitor.visitLeftIntervalOperator(self)
            else:
                return visitor.visitChildren(self)




    def leftIntervalOperator(self):

        localctx = NeoBasicParser.LeftIntervalOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 622, self.RULE_leftIntervalOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2565
            _la = self._input.LA(1)
            if not(_la==370 or _la==371):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RightIntervalOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTERVAL_INCLUSIVE(self):
            return self.getToken(NeoBasicParser.INTERVAL_INCLUSIVE, 0)

        def INTERVAL_RIGHT_EXCLUSIVE(self):
            return self.getToken(NeoBasicParser.INTERVAL_RIGHT_EXCLUSIVE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_rightIntervalOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRightIntervalOperator" ):
                listener.enterRightIntervalOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRightIntervalOperator" ):
                listener.exitRightIntervalOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRightIntervalOperator" ):
                return visitor.visitRightIntervalOperator(self)
            else:
                return visitor.visitChildren(self)




    def rightIntervalOperator(self):

        localctx = NeoBasicParser.RightIntervalOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 624, self.RULE_rightIntervalOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2567
            _la = self._input.LA(1)
            if not(_la==370 or _la==372):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singleAssignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.SingleAssignmentOperatorContext,0)


        def unpackingAssignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.UnpackingAssignmentOperatorContext,0)


        def compoundAssignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.CompoundAssignmentOperatorContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_assignmentOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentOperator" ):
                listener.enterAssignmentOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentOperator" ):
                listener.exitAssignmentOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignmentOperator" ):
                return visitor.visitAssignmentOperator(self)
            else:
                return visitor.visitChildren(self)




    def assignmentOperator(self):

        localctx = NeoBasicParser.AssignmentOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 626, self.RULE_assignmentOperator)
        try:
            self.state = 2572
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,226,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2569
                self.singleAssignmentOperator()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2570
                self.unpackingAssignmentOperator()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2571
                self.compoundAssignmentOperator()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SingleAssignmentOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUAL(self):
            return self.getToken(NeoBasicParser.EQUAL, 0)

        def DERIVED_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.DERIVED_ASSIGNMENT, 0)

        def POP_ONE_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.POP_ONE_ASSIGNMENT, 0)

        def PULL_ALL_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.PULL_ALL_ASSIGNMENT, 0)

        def PIPE_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.PIPE_ASSIGNMENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_singleAssignmentOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSingleAssignmentOperator" ):
                listener.enterSingleAssignmentOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSingleAssignmentOperator" ):
                listener.exitSingleAssignmentOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSingleAssignmentOperator" ):
                return visitor.visitSingleAssignmentOperator(self)
            else:
                return visitor.visitChildren(self)




    def singleAssignmentOperator(self):

        localctx = NeoBasicParser.SingleAssignmentOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 628, self.RULE_singleAssignmentOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2574
            _la = self._input.LA(1)
            if not(((((_la - 389)) & ~0x3f) == 0 and ((1 << (_la - 389)) & 31) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnpackingAssignmentOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUAL(self):
            return self.getToken(NeoBasicParser.EQUAL, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_unpackingAssignmentOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnpackingAssignmentOperator" ):
                listener.enterUnpackingAssignmentOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnpackingAssignmentOperator" ):
                listener.exitUnpackingAssignmentOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnpackingAssignmentOperator" ):
                return visitor.visitUnpackingAssignmentOperator(self)
            else:
                return visitor.visitChildren(self)




    def unpackingAssignmentOperator(self):

        localctx = NeoBasicParser.UnpackingAssignmentOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 630, self.RULE_unpackingAssignmentOperator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2576
            self.match(NeoBasicParser.EQUAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompoundAssignmentOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NTH_POWER_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.NTH_POWER_ASSIGNMENT, 0)

        def NTH_ROOT_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.NTH_ROOT_ASSIGNMENT, 0)

        def MULTIPLICATION_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.MULTIPLICATION_ASSIGNMENT, 0)

        def REAL_DIVISION_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.REAL_DIVISION_ASSIGNMENT, 0)

        def INTEGER_DIVISION_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.INTEGER_DIVISION_ASSIGNMENT, 0)

        def MODULO_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.MODULO_ASSIGNMENT, 0)

        def QUOTIENT_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.QUOTIENT_ASSIGNMENT, 0)

        def PERCENTAGE_RATE_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.PERCENTAGE_RATE_ASSIGNMENT, 0)

        def PERCENTAGE_AMOUNT_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.PERCENTAGE_AMOUNT_ASSIGNMENT, 0)

        def PERCENTAGE_INCREASE_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.PERCENTAGE_INCREASE_ASSIGNMENT, 0)

        def PERCENTAGE_DECREASE_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.PERCENTAGE_DECREASE_ASSIGNMENT, 0)

        def PERCENTAGE_VARIATION_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.PERCENTAGE_VARIATION_ASSIGNMENT, 0)

        def ADDITION_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.ADDITION_ASSIGNMENT, 0)

        def SUBTRACTION_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.SUBTRACTION_ASSIGNMENT, 0)

        def LEFT_SHIFT_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.LEFT_SHIFT_ASSIGNMENT, 0)

        def SIGNED_RIGHT_SHIFT_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.SIGNED_RIGHT_SHIFT_ASSIGNMENT, 0)

        def UNSIGNED_RIGHT_SHIFT_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.UNSIGNED_RIGHT_SHIFT_ASSIGNMENT, 0)

        def NONE_COALESCING_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.NONE_COALESCING_ASSIGNMENT, 0)

        def SHELL_PID_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.SHELL_PID_ASSIGNMENT, 0)

        def SHELL_BKG_PID_ASSIGNMENT(self):
            return self.getToken(NeoBasicParser.SHELL_BKG_PID_ASSIGNMENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_compoundAssignmentOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompoundAssignmentOperator" ):
                listener.enterCompoundAssignmentOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompoundAssignmentOperator" ):
                listener.exitCompoundAssignmentOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompoundAssignmentOperator" ):
                return visitor.visitCompoundAssignmentOperator(self)
            else:
                return visitor.visitChildren(self)




    def compoundAssignmentOperator(self):

        localctx = NeoBasicParser.CompoundAssignmentOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 632, self.RULE_compoundAssignmentOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2578
            _la = self._input.LA(1)
            if not(((((_la - 395)) & ~0x3f) == 0 and ((1 << (_la - 395)) & 1048575) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OverloadableOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def prefixUnaryOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.PrefixUnaryOperatorContext,0)


        def binaryExponentialOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryExponentialOperatorContext,0)


        def binaryMultiplicativeOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryMultiplicativeOperatorContext,0)


        def binaryAdditiveOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryAdditiveOperatorContext,0)


        def bitShiftOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BitShiftOperatorContext,0)


        def binaryConjunctionOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryConjunctionOperatorContext,0)


        def binaryExclusiveDisjunctionOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryExclusiveDisjunctionOperatorContext,0)


        def binaryDisjunctionOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryDisjunctionOperatorContext,0)


        def binaryArrayOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryArrayOperatorContext,0)


        def binaryComparisonOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryComparisonOperatorContext,0)


        def binaryRelationalOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryRelationalOperatorContext,0)


        def binaryConditionalOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryConditionalOperatorContext,0)


        def coalescingOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.CoalescingOperatorContext,0)


        def executionFlowOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.ExecutionFlowOperatorContext,0)


        def assignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.AssignmentOperatorContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_overloadableOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOverloadableOperator" ):
                listener.enterOverloadableOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOverloadableOperator" ):
                listener.exitOverloadableOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOverloadableOperator" ):
                return visitor.visitOverloadableOperator(self)
            else:
                return visitor.visitChildren(self)




    def overloadableOperator(self):

        localctx = NeoBasicParser.OverloadableOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 634, self.RULE_overloadableOperator)
        try:
            self.state = 2595
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,227,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2580
                self.prefixUnaryOperator()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2581
                self.binaryExponentialOperator()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2582
                self.binaryMultiplicativeOperator()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2583
                self.binaryAdditiveOperator()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2584
                self.bitShiftOperator()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2585
                self.binaryConjunctionOperator()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 2586
                self.binaryExclusiveDisjunctionOperator()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 2587
                self.binaryDisjunctionOperator()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 2588
                self.binaryArrayOperator()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 2589
                self.binaryComparisonOperator()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 2590
                self.binaryRelationalOperator()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 2591
                self.binaryConditionalOperator()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 2592
                self.coalescingOperator()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 2593
                self.executionFlowOperator()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 2594
                self.assignmentOperator()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SymbolDecoratorsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbolDecorator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.SymbolDecoratorContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.SymbolDecoratorContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_symbolDecorators

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSymbolDecorators" ):
                listener.enterSymbolDecorators(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSymbolDecorators" ):
                listener.exitSymbolDecorators(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSymbolDecorators" ):
                return visitor.visitSymbolDecorators(self)
            else:
                return visitor.visitChildren(self)




    def symbolDecorators(self):

        localctx = NeoBasicParser.SymbolDecoratorsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 636, self.RULE_symbolDecorators)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2597
            self.symbolDecorator()
            self.state = 2604
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,229,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2599
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==473:
                        self.state = 2598
                        self.match(NeoBasicParser.COMMA)


                    self.state = 2601
                    self.symbolDecorator() 
                self.state = 2606
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,229,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SymbolDecoratorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def annotationDecorator(self):
            return self.getTypedRuleContext(NeoBasicParser.AnnotationDecoratorContext,0)


        def aspectDecorator(self):
            return self.getTypedRuleContext(NeoBasicParser.AspectDecoratorContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_symbolDecorator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSymbolDecorator" ):
                listener.enterSymbolDecorator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSymbolDecorator" ):
                listener.exitSymbolDecorator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSymbolDecorator" ):
                return visitor.visitSymbolDecorator(self)
            else:
                return visitor.visitChildren(self)




    def symbolDecorator(self):

        localctx = NeoBasicParser.SymbolDecoratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 638, self.RULE_symbolDecorator)
        try:
            self.state = 2609
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [416]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2607
                self.annotationDecorator()
                pass
            elif token in [417]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2608
                self.aspectDecorator()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AnnotationDecoratorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATOM_IDENTIFIER(self):
            return self.getToken(NeoBasicParser.ATOM_IDENTIFIER, 0)

        def taggedValuePairs(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.TaggedValuePairsContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.TaggedValuePairsContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_annotationDecorator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnnotationDecorator" ):
                listener.enterAnnotationDecorator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnnotationDecorator" ):
                listener.exitAnnotationDecorator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnnotationDecorator" ):
                return visitor.visitAnnotationDecorator(self)
            else:
                return visitor.visitChildren(self)




    def annotationDecorator(self):

        localctx = NeoBasicParser.AnnotationDecoratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 640, self.RULE_annotationDecorator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2611
            self.match(NeoBasicParser.ATOM_IDENTIFIER)
            self.state = 2615
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,231,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2612
                    self.taggedValuePairs() 
                self.state = 2617
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,231,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AspectDecoratorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASPECT_IDENTIFIER(self):
            return self.getToken(NeoBasicParser.ASPECT_IDENTIFIER, 0)

        def taggedValuePairs(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.TaggedValuePairsContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.TaggedValuePairsContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_aspectDecorator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAspectDecorator" ):
                listener.enterAspectDecorator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAspectDecorator" ):
                listener.exitAspectDecorator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAspectDecorator" ):
                return visitor.visitAspectDecorator(self)
            else:
                return visitor.visitChildren(self)




    def aspectDecorator(self):

        localctx = NeoBasicParser.AspectDecoratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 642, self.RULE_aspectDecorator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2618
            self.match(NeoBasicParser.ASPECT_IDENTIFIER)
            self.state = 2622
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,232,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2619
                    self.taggedValuePairs() 
                self.state = 2624
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,232,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaggedValuePairsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def taggedValuePair(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.TaggedValuePairContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.TaggedValuePairContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_taggedValuePairs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaggedValuePairs" ):
                listener.enterTaggedValuePairs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaggedValuePairs" ):
                listener.exitTaggedValuePairs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTaggedValuePairs" ):
                return visitor.visitTaggedValuePairs(self)
            else:
                return visitor.visitChildren(self)




    def taggedValuePairs(self):

        localctx = NeoBasicParser.TaggedValuePairsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 644, self.RULE_taggedValuePairs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2625
            self.taggedValuePair()
            self.state = 2630
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,233,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2626
                    self.match(NeoBasicParser.COMMA)
                    self.state = 2627
                    self.taggedValuePair() 
                self.state = 2632
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,233,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaggedValuePairContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def IDENTIFIER(self):
            return self.getToken(NeoBasicParser.IDENTIFIER, 0)

        def EQUAL(self):
            return self.getToken(NeoBasicParser.EQUAL, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_taggedValuePair

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTaggedValuePair" ):
                listener.enterTaggedValuePair(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTaggedValuePair" ):
                listener.exitTaggedValuePair(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTaggedValuePair" ):
                return visitor.visitTaggedValuePair(self)
            else:
                return visitor.visitChildren(self)




    def taggedValuePair(self):

        localctx = NeoBasicParser.TaggedValuePairContext(self, self._ctx, self.state)
        self.enterRule(localctx, 646, self.RULE_taggedValuePair)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2635
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,234,self._ctx)
            if la_ == 1:
                self.state = 2633
                self.match(NeoBasicParser.IDENTIFIER)
                self.state = 2634
                self.match(NeoBasicParser.EQUAL)


            self.state = 2637
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenericTypeParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_ANGLE(self):
            return self.getToken(NeoBasicParser.LEFT_ANGLE, 0)

        def typeParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeParametersContext,0)


        def RIGHT_ANGLE(self):
            return self.getToken(NeoBasicParser.RIGHT_ANGLE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_genericTypeParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenericTypeParameters" ):
                listener.enterGenericTypeParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenericTypeParameters" ):
                listener.exitGenericTypeParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenericTypeParameters" ):
                return visitor.visitGenericTypeParameters(self)
            else:
                return visitor.visitChildren(self)




    def genericTypeParameters(self):

        localctx = NeoBasicParser.GenericTypeParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 648, self.RULE_genericTypeParameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2639
            self.match(NeoBasicParser.LEFT_ANGLE)
            self.state = 2640
            self.typeParameters()
            self.state = 2641
            self.match(NeoBasicParser.RIGHT_ANGLE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typeParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.TypeParameterContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.TypeParameterContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_typeParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeParameters" ):
                listener.enterTypeParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeParameters" ):
                listener.exitTypeParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeParameters" ):
                return visitor.visitTypeParameters(self)
            else:
                return visitor.visitChildren(self)




    def typeParameters(self):

        localctx = NeoBasicParser.TypeParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 650, self.RULE_typeParameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2643
            self.typeParameter()
            self.state = 2648
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==473:
                self.state = 2644
                self.match(NeoBasicParser.COMMA)
                self.state = 2645
                self.typeParameter()
                self.state = 2650
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.TypeContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.TypeContext,i)


        def IS(self):
            return self.getToken(NeoBasicParser.IS, 0)

        def ANCESTOROF(self):
            return self.getToken(NeoBasicParser.ANCESTOROF, 0)

        def EXTENDS(self):
            return self.getToken(NeoBasicParser.EXTENDS, 0)

        def IMPLEMENTS(self):
            return self.getToken(NeoBasicParser.IMPLEMENTS, 0)

        def MIXES(self):
            return self.getToken(NeoBasicParser.MIXES, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_typeParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeParameter" ):
                listener.enterTypeParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeParameter" ):
                listener.exitTypeParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeParameter" ):
                return visitor.visitTypeParameter(self)
            else:
                return visitor.visitChildren(self)




    def typeParameter(self):

        localctx = NeoBasicParser.TypeParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 652, self.RULE_typeParameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2651
            self.type_(0)
            self.state = 2654
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 60129542144) != 0) or _la==145 or _la==146:
                self.state = 2652
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 60129542144) != 0) or _la==145 or _la==146):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2653
                self.type_(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.TypeContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.TypeContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_types

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypes" ):
                listener.enterTypes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypes" ):
                listener.exitTypes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypes" ):
                return visitor.visitTypes(self)
            else:
                return visitor.visitChildren(self)




    def types(self):

        localctx = NeoBasicParser.TypesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 654, self.RULE_types)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2656
            self.type_(0)
            self.state = 2661
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,237,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2657
                    self.match(NeoBasicParser.COMMA)
                    self.state = 2658
                    self.type_(0) 
                self.state = 2663
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,237,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def prefixTypeModifier(self):
            return self.getTypedRuleContext(NeoBasicParser.PrefixTypeModifierContext,0)


        def type_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.TypeContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.TypeContext,i)


        def nativeType(self):
            return self.getTypedRuleContext(NeoBasicParser.NativeTypeContext,0)


        def procType(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcTypeContext,0)


        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def AND(self):
            return self.getToken(NeoBasicParser.AND, 0)

        def OR(self):
            return self.getToken(NeoBasicParser.OR, 0)

        def XOR(self):
            return self.getToken(NeoBasicParser.XOR, 0)

        def postfixTypeWrapper(self):
            return self.getTypedRuleContext(NeoBasicParser.PostfixTypeWrapperContext,0)


        def genericTypeParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.GenericTypeParametersContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType" ):
                listener.enterType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType" ):
                listener.exitType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType" ):
                return visitor.visitType(self)
            else:
                return visitor.visitChildren(self)



    def type_(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = NeoBasicParser.TypeContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 656
        self.enterRecursionRule(localctx, 656, self.RULE_type, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2671
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [468]:
                self.state = 2665
                self.prefixTypeModifier()
                self.state = 2666
                self.type_(9)
                pass
            elif token in [165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 297, 300, 303, 306]:
                self.state = 2668
                self.nativeType()
                pass
            elif token in [21, 23, 24, 25, 26, 27, 39, 40]:
                self.state = 2669
                self.procType()
                pass
            elif token in [415]:
                self.state = 2670
                self.qualifiedIdentifier()
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 2688
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,240,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 2686
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,239,self._ctx)
                    if la_ == 1:
                        localctx = NeoBasicParser.TypeContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_type)
                        self.state = 2673
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 2674
                        self.match(NeoBasicParser.AND)
                        self.state = 2675
                        self.type_(7)
                        pass

                    elif la_ == 2:
                        localctx = NeoBasicParser.TypeContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_type)
                        self.state = 2676
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 2677
                        self.match(NeoBasicParser.OR)
                        self.state = 2678
                        self.type_(6)
                        pass

                    elif la_ == 3:
                        localctx = NeoBasicParser.TypeContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_type)
                        self.state = 2679
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 2680
                        self.match(NeoBasicParser.XOR)
                        self.state = 2681
                        self.type_(5)
                        pass

                    elif la_ == 4:
                        localctx = NeoBasicParser.TypeContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_type)
                        self.state = 2682
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 2683
                        self.postfixTypeWrapper()
                        pass

                    elif la_ == 5:
                        localctx = NeoBasicParser.TypeContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_type)
                        self.state = 2684
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 2685
                        self.genericTypeParameters()
                        pass

             
                self.state = 2690
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,240,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class PrefixTypeModifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_BRACKET(self):
            return self.getToken(NeoBasicParser.LEFT_BRACKET, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def RIGHT_BRACKET(self):
            return self.getToken(NeoBasicParser.RIGHT_BRACKET, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_prefixTypeModifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrefixTypeModifier" ):
                listener.enterPrefixTypeModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrefixTypeModifier" ):
                listener.exitPrefixTypeModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrefixTypeModifier" ):
                return visitor.visitPrefixTypeModifier(self)
            else:
                return visitor.visitChildren(self)




    def prefixTypeModifier(self):

        localctx = NeoBasicParser.PrefixTypeModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 658, self.RULE_prefixTypeModifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2691
            self.match(NeoBasicParser.LEFT_BRACKET)
            self.state = 2692
            self.expressions()
            self.state = 2693
            self.match(NeoBasicParser.RIGHT_BRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PostfixTypeWrapperContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXCLAMATION(self):
            return self.getToken(NeoBasicParser.EXCLAMATION, 0)

        def QUESTION(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.QUESTION)
            else:
                return self.getToken(NeoBasicParser.QUESTION, i)

        def PIPE(self):
            return self.getToken(NeoBasicParser.PIPE, 0)

        def RIGHT_ANGLE(self):
            return self.getToken(NeoBasicParser.RIGHT_ANGLE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_postfixTypeWrapper

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPostfixTypeWrapper" ):
                listener.enterPostfixTypeWrapper(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPostfixTypeWrapper" ):
                listener.exitPostfixTypeWrapper(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPostfixTypeWrapper" ):
                return visitor.visitPostfixTypeWrapper(self)
            else:
                return visitor.visitChildren(self)




    def postfixTypeWrapper(self):

        localctx = NeoBasicParser.PostfixTypeWrapperContext(self, self._ctx, self.state)
        self.enterRule(localctx, 660, self.RULE_postfixTypeWrapper)
        try:
            self.state = 2709
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,241,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2695
                self.match(NeoBasicParser.EXCLAMATION)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2696
                self.match(NeoBasicParser.QUESTION)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2697
                self.match(NeoBasicParser.QUESTION)
                self.state = 2698
                self.match(NeoBasicParser.QUESTION)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2699
                self.match(NeoBasicParser.PIPE)
                self.state = 2700
                self.match(NeoBasicParser.RIGHT_ANGLE)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2701
                self.match(NeoBasicParser.EXCLAMATION)
                self.state = 2702
                self.match(NeoBasicParser.QUESTION)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2703
                self.match(NeoBasicParser.EXCLAMATION)
                self.state = 2704
                self.match(NeoBasicParser.QUESTION)
                self.state = 2705
                self.match(NeoBasicParser.QUESTION)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 2706
                self.match(NeoBasicParser.EXCLAMATION)
                self.state = 2707
                self.match(NeoBasicParser.PIPE)
                self.state = 2708
                self.match(NeoBasicParser.RIGHT_ANGLE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NativeTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def escalarType(self):
            return self.getTypedRuleContext(NeoBasicParser.EscalarTypeContext,0)


        def compoundType(self):
            return self.getTypedRuleContext(NeoBasicParser.CompoundTypeContext,0)


        def optionType(self):
            return self.getTypedRuleContext(NeoBasicParser.OptionTypeContext,0)


        def metaType(self):
            return self.getTypedRuleContext(NeoBasicParser.MetaTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_nativeType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNativeType" ):
                listener.enterNativeType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNativeType" ):
                listener.exitNativeType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNativeType" ):
                return visitor.visitNativeType(self)
            else:
                return visitor.visitChildren(self)




    def nativeType(self):

        localctx = NeoBasicParser.NativeTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 662, self.RULE_nativeType)
        try:
            self.state = 2715
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2711
                self.escalarType()
                pass
            elif token in [227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2712
                self.compoundType()
                pass
            elif token in [297, 300, 303, 306]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2713
                self.optionType()
                pass
            elif token in [165, 166, 167, 168, 169]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2714
                self.metaType()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def funcType(self):
            return self.getTypedRuleContext(NeoBasicParser.FuncTypeContext,0)


        def feedType(self):
            return self.getTypedRuleContext(NeoBasicParser.FeedTypeContext,0)


        def subType(self):
            return self.getTypedRuleContext(NeoBasicParser.SubTypeContext,0)


        def factType(self):
            return self.getTypedRuleContext(NeoBasicParser.FactTypeContext,0)


        def eventType(self):
            return self.getTypedRuleContext(NeoBasicParser.EventTypeContext,0)


        def operatorType(self):
            return self.getTypedRuleContext(NeoBasicParser.OperatorTypeContext,0)


        def getterType(self):
            return self.getTypedRuleContext(NeoBasicParser.GetterTypeContext,0)


        def setterType(self):
            return self.getTypedRuleContext(NeoBasicParser.SetterTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_procType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcType" ):
                listener.enterProcType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcType" ):
                listener.exitProcType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcType" ):
                return visitor.visitProcType(self)
            else:
                return visitor.visitChildren(self)




    def procType(self):

        localctx = NeoBasicParser.ProcTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 664, self.RULE_procType)
        try:
            self.state = 2725
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [23]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2717
                self.funcType()
                pass
            elif token in [24]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2718
                self.feedType()
                pass
            elif token in [25]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2719
                self.subType()
                pass
            elif token in [21]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2720
                self.factType()
                pass
            elif token in [27]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2721
                self.eventType()
                pass
            elif token in [26]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2722
                self.operatorType()
                pass
            elif token in [39]:
                self.enterOuterAlt(localctx, 7)
                self.state = 2723
                self.getterType()
                pass
            elif token in [40]:
                self.enterOuterAlt(localctx, 8)
                self.state = 2724
                self.setterType()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EscalarTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanType(self):
            return self.getTypedRuleContext(NeoBasicParser.BooleanTypeContext,0)


        def numericType(self):
            return self.getTypedRuleContext(NeoBasicParser.NumericTypeContext,0)


        def temporalType(self):
            return self.getTypedRuleContext(NeoBasicParser.TemporalTypeContext,0)


        def characterType(self):
            return self.getTypedRuleContext(NeoBasicParser.CharacterTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_escalarType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEscalarType" ):
                listener.enterEscalarType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEscalarType" ):
                listener.exitEscalarType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEscalarType" ):
                return visitor.visitEscalarType(self)
            else:
                return visitor.visitChildren(self)




    def escalarType(self):

        localctx = NeoBasicParser.EscalarTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 666, self.RULE_escalarType)
        try:
            self.state = 2731
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [170, 171, 172, 173, 174, 175]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2727
                self.booleanType()
                pass
            elif token in [176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2728
                self.numericType()
                pass
            elif token in [219, 220]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2729
                self.temporalType()
                pass
            elif token in [221, 222, 223, 224, 225, 226]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2730
                self.characterType()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOL8(self):
            return self.getToken(NeoBasicParser.BOOL8, 0)

        def BOOL16(self):
            return self.getToken(NeoBasicParser.BOOL16, 0)

        def BOOL32(self):
            return self.getToken(NeoBasicParser.BOOL32, 0)

        def BOOL64(self):
            return self.getToken(NeoBasicParser.BOOL64, 0)

        def BOOL128(self):
            return self.getToken(NeoBasicParser.BOOL128, 0)

        def BOOL(self):
            return self.getToken(NeoBasicParser.BOOL, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_booleanType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanType" ):
                listener.enterBooleanType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanType" ):
                listener.exitBooleanType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanType" ):
                return visitor.visitBooleanType(self)
            else:
                return visitor.visitChildren(self)




    def booleanType(self):

        localctx = NeoBasicParser.BooleanTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 668, self.RULE_booleanType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2733
            _la = self._input.LA(1)
            if not(((((_la - 170)) & ~0x3f) == 0 and ((1 << (_la - 170)) & 63) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numericNatural(self):
            return self.getTypedRuleContext(NeoBasicParser.NumericNaturalContext,0)


        def numericInteger(self):
            return self.getTypedRuleContext(NeoBasicParser.NumericIntegerContext,0)


        def numericReal(self):
            return self.getTypedRuleContext(NeoBasicParser.NumericRealContext,0)


        def numericDecimal(self):
            return self.getTypedRuleContext(NeoBasicParser.NumericDecimalContext,0)


        def numericRatio(self):
            return self.getTypedRuleContext(NeoBasicParser.NumericRatioContext,0)


        def numericComplex(self):
            return self.getTypedRuleContext(NeoBasicParser.NumericComplexContext,0)


        def numericQuaternion(self):
            return self.getTypedRuleContext(NeoBasicParser.NumericQuaternionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_numericType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericType" ):
                listener.enterNumericType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericType" ):
                listener.exitNumericType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericType" ):
                return visitor.visitNumericType(self)
            else:
                return visitor.visitChildren(self)




    def numericType(self):

        localctx = NeoBasicParser.NumericTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 670, self.RULE_numericType)
        try:
            self.state = 2742
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [176, 177, 178, 179, 180, 181, 182, 183]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2735
                self.numericNatural()
                pass
            elif token in [184, 185, 186, 187, 188, 189, 190]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2736
                self.numericInteger()
                pass
            elif token in [191, 192, 193, 194, 195, 196, 197]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2737
                self.numericReal()
                pass
            elif token in [198, 199, 200, 201, 202, 203, 204]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2738
                self.numericDecimal()
                pass
            elif token in [205, 206, 207, 208, 209, 210]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2739
                self.numericRatio()
                pass
            elif token in [211, 212, 213, 214]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2740
                self.numericComplex()
                pass
            elif token in [215, 216, 217, 218]:
                self.enterOuterAlt(localctx, 7)
                self.state = 2741
                self.numericQuaternion()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericNaturalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BYTE(self):
            return self.getToken(NeoBasicParser.BYTE, 0)

        def NAT8(self):
            return self.getToken(NeoBasicParser.NAT8, 0)

        def NAT16(self):
            return self.getToken(NeoBasicParser.NAT16, 0)

        def NAT32(self):
            return self.getToken(NeoBasicParser.NAT32, 0)

        def NAT64(self):
            return self.getToken(NeoBasicParser.NAT64, 0)

        def NAT128(self):
            return self.getToken(NeoBasicParser.NAT128, 0)

        def NAT(self):
            return self.getToken(NeoBasicParser.NAT, 0)

        def BIGNAT(self):
            return self.getToken(NeoBasicParser.BIGNAT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_numericNatural

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericNatural" ):
                listener.enterNumericNatural(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericNatural" ):
                listener.exitNumericNatural(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericNatural" ):
                return visitor.visitNumericNatural(self)
            else:
                return visitor.visitChildren(self)




    def numericNatural(self):

        localctx = NeoBasicParser.NumericNaturalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 672, self.RULE_numericNatural)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2744
            _la = self._input.LA(1)
            if not(((((_la - 176)) & ~0x3f) == 0 and ((1 << (_la - 176)) & 255) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericIntegerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT8(self):
            return self.getToken(NeoBasicParser.INT8, 0)

        def INT16(self):
            return self.getToken(NeoBasicParser.INT16, 0)

        def INT32(self):
            return self.getToken(NeoBasicParser.INT32, 0)

        def INT64(self):
            return self.getToken(NeoBasicParser.INT64, 0)

        def INT128(self):
            return self.getToken(NeoBasicParser.INT128, 0)

        def INT(self):
            return self.getToken(NeoBasicParser.INT, 0)

        def BIGINT(self):
            return self.getToken(NeoBasicParser.BIGINT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_numericInteger

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericInteger" ):
                listener.enterNumericInteger(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericInteger" ):
                listener.exitNumericInteger(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericInteger" ):
                return visitor.visitNumericInteger(self)
            else:
                return visitor.visitChildren(self)




    def numericInteger(self):

        localctx = NeoBasicParser.NumericIntegerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 674, self.RULE_numericInteger)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2746
            _la = self._input.LA(1)
            if not(((((_la - 184)) & ~0x3f) == 0 and ((1 << (_la - 184)) & 127) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericDecimalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DECIMAL8(self):
            return self.getToken(NeoBasicParser.DECIMAL8, 0)

        def DECIMAL16(self):
            return self.getToken(NeoBasicParser.DECIMAL16, 0)

        def DECIMAL32(self):
            return self.getToken(NeoBasicParser.DECIMAL32, 0)

        def DECIMAL64(self):
            return self.getToken(NeoBasicParser.DECIMAL64, 0)

        def DECIMAL128(self):
            return self.getToken(NeoBasicParser.DECIMAL128, 0)

        def DECIMAL(self):
            return self.getToken(NeoBasicParser.DECIMAL, 0)

        def MONEY(self):
            return self.getToken(NeoBasicParser.MONEY, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_numericDecimal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericDecimal" ):
                listener.enterNumericDecimal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericDecimal" ):
                listener.exitNumericDecimal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericDecimal" ):
                return visitor.visitNumericDecimal(self)
            else:
                return visitor.visitChildren(self)




    def numericDecimal(self):

        localctx = NeoBasicParser.NumericDecimalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 676, self.RULE_numericDecimal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2748
            _la = self._input.LA(1)
            if not(((((_la - 198)) & ~0x3f) == 0 and ((1 << (_la - 198)) & 127) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericRealContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REAL8(self):
            return self.getToken(NeoBasicParser.REAL8, 0)

        def REAL16(self):
            return self.getToken(NeoBasicParser.REAL16, 0)

        def REAL32(self):
            return self.getToken(NeoBasicParser.REAL32, 0)

        def REAL64(self):
            return self.getToken(NeoBasicParser.REAL64, 0)

        def REAL128(self):
            return self.getToken(NeoBasicParser.REAL128, 0)

        def REAL(self):
            return self.getToken(NeoBasicParser.REAL, 0)

        def BIGREAL(self):
            return self.getToken(NeoBasicParser.BIGREAL, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_numericReal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericReal" ):
                listener.enterNumericReal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericReal" ):
                listener.exitNumericReal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericReal" ):
                return visitor.visitNumericReal(self)
            else:
                return visitor.visitChildren(self)




    def numericReal(self):

        localctx = NeoBasicParser.NumericRealContext(self, self._ctx, self.state)
        self.enterRule(localctx, 678, self.RULE_numericReal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2750
            _la = self._input.LA(1)
            if not(((((_la - 191)) & ~0x3f) == 0 and ((1 << (_la - 191)) & 127) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericRatioContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RATIO8(self):
            return self.getToken(NeoBasicParser.RATIO8, 0)

        def RATIO16(self):
            return self.getToken(NeoBasicParser.RATIO16, 0)

        def RATIO32(self):
            return self.getToken(NeoBasicParser.RATIO32, 0)

        def RATIO64(self):
            return self.getToken(NeoBasicParser.RATIO64, 0)

        def RATIO128(self):
            return self.getToken(NeoBasicParser.RATIO128, 0)

        def RATIO(self):
            return self.getToken(NeoBasicParser.RATIO, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_numericRatio

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericRatio" ):
                listener.enterNumericRatio(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericRatio" ):
                listener.exitNumericRatio(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericRatio" ):
                return visitor.visitNumericRatio(self)
            else:
                return visitor.visitChildren(self)




    def numericRatio(self):

        localctx = NeoBasicParser.NumericRatioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 680, self.RULE_numericRatio)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2752
            _la = self._input.LA(1)
            if not(((((_la - 205)) & ~0x3f) == 0 and ((1 << (_la - 205)) & 63) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericComplexContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMPLEX32(self):
            return self.getToken(NeoBasicParser.COMPLEX32, 0)

        def COMPLEX64(self):
            return self.getToken(NeoBasicParser.COMPLEX64, 0)

        def COMPLEX128(self):
            return self.getToken(NeoBasicParser.COMPLEX128, 0)

        def COMPLEX(self):
            return self.getToken(NeoBasicParser.COMPLEX, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_numericComplex

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericComplex" ):
                listener.enterNumericComplex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericComplex" ):
                listener.exitNumericComplex(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericComplex" ):
                return visitor.visitNumericComplex(self)
            else:
                return visitor.visitChildren(self)




    def numericComplex(self):

        localctx = NeoBasicParser.NumericComplexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 682, self.RULE_numericComplex)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2754
            _la = self._input.LA(1)
            if not(((((_la - 211)) & ~0x3f) == 0 and ((1 << (_la - 211)) & 15) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericQuaternionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QUATERN32(self):
            return self.getToken(NeoBasicParser.QUATERN32, 0)

        def QUATERN64(self):
            return self.getToken(NeoBasicParser.QUATERN64, 0)

        def QUATERN128(self):
            return self.getToken(NeoBasicParser.QUATERN128, 0)

        def QUATERN(self):
            return self.getToken(NeoBasicParser.QUATERN, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_numericQuaternion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericQuaternion" ):
                listener.enterNumericQuaternion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericQuaternion" ):
                listener.exitNumericQuaternion(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericQuaternion" ):
                return visitor.visitNumericQuaternion(self)
            else:
                return visitor.visitChildren(self)




    def numericQuaternion(self):

        localctx = NeoBasicParser.NumericQuaternionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 684, self.RULE_numericQuaternion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2756
            _la = self._input.LA(1)
            if not(((((_la - 215)) & ~0x3f) == 0 and ((1 << (_la - 215)) & 15) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TemporalTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELAPSE(self):
            return self.getToken(NeoBasicParser.ELAPSE, 0)

        def DATE(self):
            return self.getToken(NeoBasicParser.DATE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_temporalType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemporalType" ):
                listener.enterTemporalType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemporalType" ):
                listener.exitTemporalType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTemporalType" ):
                return visitor.visitTemporalType(self)
            else:
                return visitor.visitChildren(self)




    def temporalType(self):

        localctx = NeoBasicParser.TemporalTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 686, self.RULE_temporalType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2758
            _la = self._input.LA(1)
            if not(_la==219 or _la==220):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CharacterTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASCII(self):
            return self.getToken(NeoBasicParser.ASCII, 0)

        def CHAR8(self):
            return self.getToken(NeoBasicParser.CHAR8, 0)

        def CHAR16(self):
            return self.getToken(NeoBasicParser.CHAR16, 0)

        def CHAR32(self):
            return self.getToken(NeoBasicParser.CHAR32, 0)

        def CHAR(self):
            return self.getToken(NeoBasicParser.CHAR, 0)

        def WCHAR(self):
            return self.getToken(NeoBasicParser.WCHAR, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_characterType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCharacterType" ):
                listener.enterCharacterType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCharacterType" ):
                listener.exitCharacterType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCharacterType" ):
                return visitor.visitCharacterType(self)
            else:
                return visitor.visitChildren(self)




    def characterType(self):

        localctx = NeoBasicParser.CharacterTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 688, self.RULE_characterType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2760
            _la = self._input.LA(1)
            if not(((((_la - 221)) & ~0x3f) == 0 and ((1 << (_la - 221)) & 63) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompoundTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sequenceType(self):
            return self.getTypedRuleContext(NeoBasicParser.SequenceTypeContext,0)


        def compositeType(self):
            return self.getTypedRuleContext(NeoBasicParser.CompositeTypeContext,0)


        def collectionType(self):
            return self.getTypedRuleContext(NeoBasicParser.CollectionTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_compoundType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompoundType" ):
                listener.enterCompoundType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompoundType" ):
                listener.exitCompoundType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompoundType" ):
                return visitor.visitCompoundType(self)
            else:
                return visitor.visitChildren(self)




    def compoundType(self):

        localctx = NeoBasicParser.CompoundTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 690, self.RULE_compoundType)
        try:
            self.state = 2765
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [227, 228, 229, 230, 231, 232, 233, 234, 235]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2762
                self.sequenceType()
                pass
            elif token in [236, 237, 238, 239, 240, 241]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2763
                self.compositeType()
                pass
            elif token in [242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2764
                self.collectionType()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SequenceTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ANSI(self):
            return self.getToken(NeoBasicParser.ANSI, 0)

        def STR8(self):
            return self.getToken(NeoBasicParser.STR8, 0)

        def STR16(self):
            return self.getToken(NeoBasicParser.STR16, 0)

        def STR32(self):
            return self.getToken(NeoBasicParser.STR32, 0)

        def STR(self):
            return self.getToken(NeoBasicParser.STR, 0)

        def CSTR(self):
            return self.getToken(NeoBasicParser.CSTR, 0)

        def WSTR(self):
            return self.getToken(NeoBasicParser.WSTR, 0)

        def REGEX(self):
            return self.getToken(NeoBasicParser.REGEX, 0)

        def BINARY(self):
            return self.getToken(NeoBasicParser.BINARY, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_sequenceType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSequenceType" ):
                listener.enterSequenceType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSequenceType" ):
                listener.exitSequenceType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSequenceType" ):
                return visitor.visitSequenceType(self)
            else:
                return visitor.visitChildren(self)




    def sequenceType(self):

        localctx = NeoBasicParser.SequenceTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 692, self.RULE_sequenceType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2767
            _la = self._input.LA(1)
            if not(((((_la - 227)) & ~0x3f) == 0 and ((1 << (_la - 227)) & 511) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompositeTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RANGE(self):
            return self.getToken(NeoBasicParser.RANGE, 0)

        def PAIR(self):
            return self.getToken(NeoBasicParser.PAIR, 0)

        def TUPLE(self):
            return self.getToken(NeoBasicParser.TUPLE, 0)

        def INET(self):
            return self.getToken(NeoBasicParser.INET, 0)

        def PATH(self):
            return self.getToken(NeoBasicParser.PATH, 0)

        def URI(self):
            return self.getToken(NeoBasicParser.URI, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_compositeType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompositeType" ):
                listener.enterCompositeType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompositeType" ):
                listener.exitCompositeType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompositeType" ):
                return visitor.visitCompositeType(self)
            else:
                return visitor.visitChildren(self)




    def compositeType(self):

        localctx = NeoBasicParser.CompositeTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 694, self.RULE_compositeType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2769
            _la = self._input.LA(1)
            if not(((((_la - 236)) & ~0x3f) == 0 and ((1 << (_la - 236)) & 63) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CollectionTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ARRAY(self):
            return self.getToken(NeoBasicParser.ARRAY, 0)

        def LIST(self):
            return self.getToken(NeoBasicParser.LIST, 0)

        def MAP(self):
            return self.getToken(NeoBasicParser.MAP, 0)

        def CHANNEL(self):
            return self.getToken(NeoBasicParser.CHANNEL, 0)

        def VECTOR(self):
            return self.getToken(NeoBasicParser.VECTOR, 0)

        def MATRIX(self):
            return self.getToken(NeoBasicParser.MATRIX, 0)

        def SET(self):
            return self.getToken(NeoBasicParser.SET, 0)

        def QUEUE(self):
            return self.getToken(NeoBasicParser.QUEUE, 0)

        def DEQUE(self):
            return self.getToken(NeoBasicParser.DEQUE, 0)

        def XML(self):
            return self.getToken(NeoBasicParser.XML, 0)

        def TABLE(self):
            return self.getToken(NeoBasicParser.TABLE, 0)

        def MEMO(self):
            return self.getToken(NeoBasicParser.MEMO, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_collectionType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCollectionType" ):
                listener.enterCollectionType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCollectionType" ):
                listener.exitCollectionType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCollectionType" ):
                return visitor.visitCollectionType(self)
            else:
                return visitor.visitChildren(self)




    def collectionType(self):

        localctx = NeoBasicParser.CollectionTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 696, self.RULE_collectionType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2771
            _la = self._input.LA(1)
            if not(((((_la - 242)) & ~0x3f) == 0 and ((1 << (_la - 242)) & 4095) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OptionTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RESULT(self):
            return self.getToken(NeoBasicParser.RESULT, 0)

        def MAYBE(self):
            return self.getToken(NeoBasicParser.MAYBE, 0)

        def EITHER(self):
            return self.getToken(NeoBasicParser.EITHER, 0)

        def STREAM(self):
            return self.getToken(NeoBasicParser.STREAM, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_optionType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOptionType" ):
                listener.enterOptionType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOptionType" ):
                listener.exitOptionType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOptionType" ):
                return visitor.visitOptionType(self)
            else:
                return visitor.visitChildren(self)




    def optionType(self):

        localctx = NeoBasicParser.OptionTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 698, self.RULE_optionType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2773
            _la = self._input.LA(1)
            if not(((((_la - 297)) & ~0x3f) == 0 and ((1 << (_la - 297)) & 585) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MetaTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATOM(self):
            return self.getToken(NeoBasicParser.ATOM, 0)

        def AUTO(self):
            return self.getToken(NeoBasicParser.AUTO, 0)

        def SPAN(self):
            return self.getToken(NeoBasicParser.SPAN, 0)

        def VIEW(self):
            return self.getToken(NeoBasicParser.VIEW, 0)

        def VOID(self):
            return self.getToken(NeoBasicParser.VOID, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_metaType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMetaType" ):
                listener.enterMetaType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMetaType" ):
                listener.exitMetaType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMetaType" ):
                return visitor.visitMetaType(self)
            else:
                return visitor.visitChildren(self)




    def metaType(self):

        localctx = NeoBasicParser.MetaTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 700, self.RULE_metaType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2775
            _la = self._input.LA(1)
            if not(((((_la - 165)) & ~0x3f) == 0 and ((1 << (_la - 165)) & 31) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FUNC(self):
            return self.getToken(NeoBasicParser.FUNC, 0)

        def parenthesizedParameterTypes(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParameterTypesContext,0)


        def procResultType(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcResultTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_funcType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncType" ):
                listener.enterFuncType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncType" ):
                listener.exitFuncType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncType" ):
                return visitor.visitFuncType(self)
            else:
                return visitor.visitChildren(self)




    def funcType(self):

        localctx = NeoBasicParser.FuncTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 702, self.RULE_funcType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2777
            self.match(NeoBasicParser.FUNC)
            self.state = 2778
            self.parenthesizedParameterTypes()
            self.state = 2779
            self.procResultType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FeedTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FEED(self):
            return self.getToken(NeoBasicParser.FEED, 0)

        def parenthesizedParameterTypes(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParameterTypesContext,0)


        def procResultType(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcResultTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_feedType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFeedType" ):
                listener.enterFeedType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFeedType" ):
                listener.exitFeedType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFeedType" ):
                return visitor.visitFeedType(self)
            else:
                return visitor.visitChildren(self)




    def feedType(self):

        localctx = NeoBasicParser.FeedTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 704, self.RULE_feedType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2781
            self.match(NeoBasicParser.FEED)
            self.state = 2782
            self.parenthesizedParameterTypes()
            self.state = 2783
            self.procResultType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUB(self):
            return self.getToken(NeoBasicParser.SUB, 0)

        def parenthesizedParameterTypes(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParameterTypesContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_subType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubType" ):
                listener.enterSubType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubType" ):
                listener.exitSubType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubType" ):
                return visitor.visitSubType(self)
            else:
                return visitor.visitChildren(self)




    def subType(self):

        localctx = NeoBasicParser.SubTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 706, self.RULE_subType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2785
            self.match(NeoBasicParser.SUB)
            self.state = 2786
            self.parenthesizedParameterTypes()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FactTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FACT(self):
            return self.getToken(NeoBasicParser.FACT, 0)

        def procParameterType(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcParameterTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_factType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFactType" ):
                listener.enterFactType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFactType" ):
                listener.exitFactType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactType" ):
                return visitor.visitFactType(self)
            else:
                return visitor.visitChildren(self)




    def factType(self):

        localctx = NeoBasicParser.FactTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 708, self.RULE_factType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2788
            self.match(NeoBasicParser.FACT)
            self.state = 2789
            self.procParameterType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperatorTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPERATOR(self):
            return self.getToken(NeoBasicParser.OPERATOR, 0)

        def parenthesizedParameterTypes(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParameterTypesContext,0)


        def procResultType(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcResultTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_operatorType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperatorType" ):
                listener.enterOperatorType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperatorType" ):
                listener.exitOperatorType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperatorType" ):
                return visitor.visitOperatorType(self)
            else:
                return visitor.visitChildren(self)




    def operatorType(self):

        localctx = NeoBasicParser.OperatorTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 710, self.RULE_operatorType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2791
            self.match(NeoBasicParser.OPERATOR)
            self.state = 2792
            self.parenthesizedParameterTypes()
            self.state = 2793
            self.procResultType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EventTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EVENT(self):
            return self.getToken(NeoBasicParser.EVENT, 0)

        def bracketedParameterTypes(self):
            return self.getTypedRuleContext(NeoBasicParser.BracketedParameterTypesContext,0)


        def procResultType(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcResultTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_eventType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEventType" ):
                listener.enterEventType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEventType" ):
                listener.exitEventType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEventType" ):
                return visitor.visitEventType(self)
            else:
                return visitor.visitChildren(self)




    def eventType(self):

        localctx = NeoBasicParser.EventTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 712, self.RULE_eventType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2795
            self.match(NeoBasicParser.EVENT)
            self.state = 2796
            self.bracketedParameterTypes()
            self.state = 2797
            self.procResultType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetterTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GETTER(self):
            return self.getToken(NeoBasicParser.GETTER, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_getterType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetterType" ):
                listener.enterGetterType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetterType" ):
                listener.exitGetterType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetterType" ):
                return visitor.visitGetterType(self)
            else:
                return visitor.visitChildren(self)




    def getterType(self):

        localctx = NeoBasicParser.GetterTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 714, self.RULE_getterType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2799
            self.match(NeoBasicParser.GETTER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetterTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SETTER(self):
            return self.getToken(NeoBasicParser.SETTER, 0)

        def parenthesizedParameterTypes(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedParameterTypesContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_setterType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetterType" ):
                listener.enterSetterType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetterType" ):
                listener.exitSetterType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetterType" ):
                return visitor.visitSetterType(self)
            else:
                return visitor.visitChildren(self)




    def setterType(self):

        localctx = NeoBasicParser.SetterTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 716, self.RULE_setterType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2801
            self.match(NeoBasicParser.SETTER)
            self.state = 2802
            self.parenthesizedParameterTypes()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParenthesizedParameterTypesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LEFT_PARENTHESIS, 0)

        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def procParameterTypes(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcParameterTypesContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_parenthesizedParameterTypes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenthesizedParameterTypes" ):
                listener.enterParenthesizedParameterTypes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenthesizedParameterTypes" ):
                listener.exitParenthesizedParameterTypes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenthesizedParameterTypes" ):
                return visitor.visitParenthesizedParameterTypes(self)
            else:
                return visitor.visitChildren(self)




    def parenthesizedParameterTypes(self):

        localctx = NeoBasicParser.ParenthesizedParameterTypesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 718, self.RULE_parenthesizedParameterTypes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2804
            self.match(NeoBasicParser.LEFT_PARENTHESIS)
            self.state = 2806
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1649529585664) != 0) or ((((_la - 165)) & ~0x3f) == 0 and ((1 << (_la - 165)) & -1) != 0) or ((((_la - 229)) & ~0x3f) == 0 and ((1 << (_la - 229)) & 33554431) != 0) or ((((_la - 297)) & ~0x3f) == 0 and ((1 << (_la - 297)) & 6442451529) != 0) or _la==370 or _la==415 or _la==468 or _la==475:
                self.state = 2805
                self.procParameterTypes()


            self.state = 2808
            self.match(NeoBasicParser.RIGHT_PARENTHESIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BracketedParameterTypesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_BRACKET(self):
            return self.getToken(NeoBasicParser.LEFT_BRACKET, 0)

        def RIGHT_BRACKET(self):
            return self.getToken(NeoBasicParser.RIGHT_BRACKET, 0)

        def procParameterTypes(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcParameterTypesContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_bracketedParameterTypes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBracketedParameterTypes" ):
                listener.enterBracketedParameterTypes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBracketedParameterTypes" ):
                listener.exitBracketedParameterTypes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBracketedParameterTypes" ):
                return visitor.visitBracketedParameterTypes(self)
            else:
                return visitor.visitChildren(self)




    def bracketedParameterTypes(self):

        localctx = NeoBasicParser.BracketedParameterTypesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 720, self.RULE_bracketedParameterTypes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2810
            self.match(NeoBasicParser.LEFT_BRACKET)
            self.state = 2812
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1649529585664) != 0) or ((((_la - 165)) & ~0x3f) == 0 and ((1 << (_la - 165)) & -1) != 0) or ((((_la - 229)) & ~0x3f) == 0 and ((1 << (_la - 229)) & 33554431) != 0) or ((((_la - 297)) & ~0x3f) == 0 and ((1 << (_la - 297)) & 6442451529) != 0) or _la==370 or _la==415 or _la==468 or _la==475:
                self.state = 2811
                self.procParameterTypes()


            self.state = 2814
            self.match(NeoBasicParser.RIGHT_BRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcParameterTypesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def procParameterType(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ProcParameterTypeContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ProcParameterTypeContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_procParameterTypes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcParameterTypes" ):
                listener.enterProcParameterTypes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcParameterTypes" ):
                listener.exitProcParameterTypes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcParameterTypes" ):
                return visitor.visitProcParameterTypes(self)
            else:
                return visitor.visitChildren(self)




    def procParameterTypes(self):

        localctx = NeoBasicParser.ProcParameterTypesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 722, self.RULE_procParameterTypes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2816
            self.procParameterType()
            self.state = 2821
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==473:
                self.state = 2817
                self.match(NeoBasicParser.COMMA)
                self.state = 2818
                self.procParameterType()
                self.state = 2823
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProcParameterTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def prefixParameterType(self):
            return self.getTypedRuleContext(NeoBasicParser.PrefixParameterTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_procParameterType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcParameterType" ):
                listener.enterProcParameterType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcParameterType" ):
                listener.exitProcParameterType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcParameterType" ):
                return visitor.visitProcParameterType(self)
            else:
                return visitor.visitChildren(self)




    def procParameterType(self):

        localctx = NeoBasicParser.ProcParameterTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 724, self.RULE_procParameterType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2825
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 328)) & ~0x3f) == 0 and ((1 << (_la - 328)) & 4398046511107) != 0) or _la==475:
                self.state = 2824
                self.prefixParameterType()


            self.state = 2827
            self.type_(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def escalarLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.EscalarLiteralContext,0)


        def optionLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.OptionLiteralContext,0)


        def compoundLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.CompoundLiteralContext,0)


        def lambdaLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.LambdaLiteralContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteral" ):
                return visitor.visitLiteral(self)
            else:
                return visitor.visitChildren(self)




    def literal(self):

        localctx = NeoBasicParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 726, self.RULE_literal)
        try:
            self.state = 2833
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,251,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2829
                self.escalarLiteral()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2830
                self.optionLiteral()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2831
                self.compoundLiteral()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2832
                self.lambdaLiteral()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EscalarLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.BooleanLiteralContext,0)


        def numericLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.NumericLiteralContext,0)


        def elapseLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.ElapseLiteralContext,0)


        def dateLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.DateLiteralContext,0)


        def characterLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.CharacterLiteralContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_escalarLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEscalarLiteral" ):
                listener.enterEscalarLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEscalarLiteral" ):
                listener.exitEscalarLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEscalarLiteral" ):
                return visitor.visitEscalarLiteral(self)
            else:
                return visitor.visitChildren(self)




    def escalarLiteral(self):

        localctx = NeoBasicParser.EscalarLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 728, self.RULE_escalarLiteral)
        try:
            self.state = 2840
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [254, 255]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2835
                self.booleanLiteral()
                pass
            elif token in [256, 257, 258, 259, 260, 261, 262, 418, 419, 420, 421, 422, 423, 425]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2836
                self.numericLiteral()
                pass
            elif token in [424, 438]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2837
                self.elapseLiteral()
                pass
            elif token in [263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 437]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2838
                self.dateLiteral()
                pass
            elif token in [275, 277, 278, 279, 280, 281, 282, 427, 428]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2839
                self.characterLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(NeoBasicParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(NeoBasicParser.FALSE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_booleanLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanLiteral" ):
                listener.enterBooleanLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanLiteral" ):
                listener.exitBooleanLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanLiteral" ):
                return visitor.visitBooleanLiteral(self)
            else:
                return visitor.visitChildren(self)




    def booleanLiteral(self):

        localctx = NeoBasicParser.BooleanLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 730, self.RULE_booleanLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2842
            _la = self._input.LA(1)
            if not(_la==254 or _la==255):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumericLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NATURAL_LIT(self):
            return self.getToken(NeoBasicParser.NATURAL_LIT, 0)

        def INTEGER_LIT(self):
            return self.getToken(NeoBasicParser.INTEGER_LIT, 0)

        def DECIMAL_LIT(self):
            return self.getToken(NeoBasicParser.DECIMAL_LIT, 0)

        def REAL_LIT(self):
            return self.getToken(NeoBasicParser.REAL_LIT, 0)

        def RATIO_LIT(self):
            return self.getToken(NeoBasicParser.RATIO_LIT, 0)

        def IMAGINARY_LIT(self):
            return self.getToken(NeoBasicParser.IMAGINARY_LIT, 0)

        def TERM_LIT(self):
            return self.getToken(NeoBasicParser.TERM_LIT, 0)

        def NONZERO(self):
            return self.getToken(NeoBasicParser.NONZERO, 0)

        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def ZERO(self):
            return self.getToken(NeoBasicParser.ZERO, 0)

        def MINVALUE(self):
            return self.getToken(NeoBasicParser.MINVALUE, 0)

        def MAXVALUE(self):
            return self.getToken(NeoBasicParser.MAXVALUE, 0)

        def NAN(self):
            return self.getToken(NeoBasicParser.NAN, 0)

        def POSITIVEINFINITY(self):
            return self.getToken(NeoBasicParser.POSITIVEINFINITY, 0)

        def NEGATIVEINFINITY(self):
            return self.getToken(NeoBasicParser.NEGATIVEINFINITY, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_numericLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericLiteral" ):
                listener.enterNumericLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericLiteral" ):
                listener.exitNumericLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericLiteral" ):
                return visitor.visitNumericLiteral(self)
            else:
                return visitor.visitChildren(self)




    def numericLiteral(self):

        localctx = NeoBasicParser.NumericLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 732, self.RULE_numericLiteral)
        try:
            self.state = 2859
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [418]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2844
                self.match(NeoBasicParser.NATURAL_LIT)
                pass
            elif token in [419]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2845
                self.match(NeoBasicParser.INTEGER_LIT)
                pass
            elif token in [420]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2846
                self.match(NeoBasicParser.DECIMAL_LIT)
                pass
            elif token in [421]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2847
                self.match(NeoBasicParser.REAL_LIT)
                pass
            elif token in [422]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2848
                self.match(NeoBasicParser.RATIO_LIT)
                pass
            elif token in [423]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2849
                self.match(NeoBasicParser.IMAGINARY_LIT)
                pass
            elif token in [425]:
                self.enterOuterAlt(localctx, 7)
                self.state = 2850
                self.match(NeoBasicParser.TERM_LIT)
                pass
            elif token in [256]:
                self.enterOuterAlt(localctx, 8)
                self.state = 2851
                self.match(NeoBasicParser.NONZERO)
                self.state = 2852
                self.parenthesizedExpression()
                pass
            elif token in [257]:
                self.enterOuterAlt(localctx, 9)
                self.state = 2853
                self.match(NeoBasicParser.ZERO)
                pass
            elif token in [258]:
                self.enterOuterAlt(localctx, 10)
                self.state = 2854
                self.match(NeoBasicParser.MINVALUE)
                pass
            elif token in [259]:
                self.enterOuterAlt(localctx, 11)
                self.state = 2855
                self.match(NeoBasicParser.MAXVALUE)
                pass
            elif token in [260]:
                self.enterOuterAlt(localctx, 12)
                self.state = 2856
                self.match(NeoBasicParser.NAN)
                pass
            elif token in [261]:
                self.enterOuterAlt(localctx, 13)
                self.state = 2857
                self.match(NeoBasicParser.POSITIVEINFINITY)
                pass
            elif token in [262]:
                self.enterOuterAlt(localctx, 14)
                self.state = 2858
                self.match(NeoBasicParser.NEGATIVEINFINITY)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElapseLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELAPSE_LIT(self):
            return self.getToken(NeoBasicParser.ELAPSE_LIT, 0)

        def ATOM_ELAPSE_LIT(self):
            return self.getToken(NeoBasicParser.ATOM_ELAPSE_LIT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_elapseLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElapseLiteral" ):
                listener.enterElapseLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElapseLiteral" ):
                listener.exitElapseLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElapseLiteral" ):
                return visitor.visitElapseLiteral(self)
            else:
                return visitor.visitChildren(self)




    def elapseLiteral(self):

        localctx = NeoBasicParser.ElapseLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 734, self.RULE_elapseLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2861
            _la = self._input.LA(1)
            if not(_la==424 or _la==438):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATOM_DOT_LIT(self):
            return self.getToken(NeoBasicParser.ATOM_DOT_LIT, 0)

        def LOCALDATE(self):
            return self.getToken(NeoBasicParser.LOCALDATE, 0)

        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def LOCALDATETIME(self):
            return self.getToken(NeoBasicParser.LOCALDATETIME, 0)

        def OFFSETDATE(self):
            return self.getToken(NeoBasicParser.OFFSETDATE, 0)

        def OFFSETDATETIME(self):
            return self.getToken(NeoBasicParser.OFFSETDATETIME, 0)

        def ZONEDDATE(self):
            return self.getToken(NeoBasicParser.ZONEDDATE, 0)

        def ZONEDDATETIME(self):
            return self.getToken(NeoBasicParser.ZONEDDATETIME, 0)

        def TOMORROW(self):
            return self.getToken(NeoBasicParser.TOMORROW, 0)

        def TODAY(self):
            return self.getToken(NeoBasicParser.TODAY, 0)

        def NOW(self):
            return self.getToken(NeoBasicParser.NOW, 0)

        def YESTERDAY(self):
            return self.getToken(NeoBasicParser.YESTERDAY, 0)

        def EON(self):
            return self.getToken(NeoBasicParser.EON, 0)

        def EPOCH(self):
            return self.getToken(NeoBasicParser.EPOCH, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_dateLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDateLiteral" ):
                listener.enterDateLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDateLiteral" ):
                listener.exitDateLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDateLiteral" ):
                return visitor.visitDateLiteral(self)
            else:
                return visitor.visitChildren(self)




    def dateLiteral(self):

        localctx = NeoBasicParser.DateLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 736, self.RULE_dateLiteral)
        try:
            self.state = 2894
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [437]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2863
                self.match(NeoBasicParser.ATOM_DOT_LIT)
                pass
            elif token in [263]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2864
                self.match(NeoBasicParser.LOCALDATE)
                self.state = 2866
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,254,self._ctx)
                if la_ == 1:
                    self.state = 2865
                    self.parenthesizedExpression()


                pass
            elif token in [264]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2868
                self.match(NeoBasicParser.LOCALDATETIME)
                self.state = 2870
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,255,self._ctx)
                if la_ == 1:
                    self.state = 2869
                    self.parenthesizedExpression()


                pass
            elif token in [265]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2872
                self.match(NeoBasicParser.OFFSETDATE)
                self.state = 2874
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,256,self._ctx)
                if la_ == 1:
                    self.state = 2873
                    self.parenthesizedExpression()


                pass
            elif token in [266]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2876
                self.match(NeoBasicParser.OFFSETDATETIME)
                self.state = 2878
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,257,self._ctx)
                if la_ == 1:
                    self.state = 2877
                    self.parenthesizedExpression()


                pass
            elif token in [267]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2880
                self.match(NeoBasicParser.ZONEDDATE)
                self.state = 2882
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,258,self._ctx)
                if la_ == 1:
                    self.state = 2881
                    self.parenthesizedExpression()


                pass
            elif token in [268]:
                self.enterOuterAlt(localctx, 7)
                self.state = 2884
                self.match(NeoBasicParser.ZONEDDATETIME)
                self.state = 2886
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,259,self._ctx)
                if la_ == 1:
                    self.state = 2885
                    self.parenthesizedExpression()


                pass
            elif token in [269]:
                self.enterOuterAlt(localctx, 8)
                self.state = 2888
                self.match(NeoBasicParser.TOMORROW)
                pass
            elif token in [270]:
                self.enterOuterAlt(localctx, 9)
                self.state = 2889
                self.match(NeoBasicParser.TODAY)
                pass
            elif token in [271]:
                self.enterOuterAlt(localctx, 10)
                self.state = 2890
                self.match(NeoBasicParser.NOW)
                pass
            elif token in [272]:
                self.enterOuterAlt(localctx, 11)
                self.state = 2891
                self.match(NeoBasicParser.YESTERDAY)
                pass
            elif token in [273]:
                self.enterOuterAlt(localctx, 12)
                self.state = 2892
                self.match(NeoBasicParser.EON)
                pass
            elif token in [274]:
                self.enterOuterAlt(localctx, 13)
                self.state = 2893
                self.match(NeoBasicParser.EPOCH)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CharacterLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASCII_LIT(self):
            return self.getToken(NeoBasicParser.ASCII_LIT, 0)

        def CHAR_LIT(self):
            return self.getToken(NeoBasicParser.CHAR_LIT, 0)

        def LETTER(self):
            return self.getToken(NeoBasicParser.LETTER, 0)

        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def DIGIT(self):
            return self.getToken(NeoBasicParser.DIGIT, 0)

        def PUNCTUATION(self):
            return self.getToken(NeoBasicParser.PUNCTUATION, 0)

        def SYMBOL(self):
            return self.getToken(NeoBasicParser.SYMBOL, 0)

        def SEPARATOR(self):
            return self.getToken(NeoBasicParser.SEPARATOR, 0)

        def NONPRINTABLE(self):
            return self.getToken(NeoBasicParser.NONPRINTABLE, 0)

        def NULL(self):
            return self.getToken(NeoBasicParser.NULL, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_characterLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCharacterLiteral" ):
                listener.enterCharacterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCharacterLiteral" ):
                listener.exitCharacterLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCharacterLiteral" ):
                return visitor.visitCharacterLiteral(self)
            else:
                return visitor.visitChildren(self)




    def characterLiteral(self):

        localctx = NeoBasicParser.CharacterLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 738, self.RULE_characterLiteral)
        try:
            self.state = 2911
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [427]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2896
                self.match(NeoBasicParser.ASCII_LIT)
                pass
            elif token in [428]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2897
                self.match(NeoBasicParser.CHAR_LIT)
                pass
            elif token in [275]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2898
                self.match(NeoBasicParser.LETTER)
                self.state = 2899
                self.parenthesizedExpression()
                pass
            elif token in [277]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2900
                self.match(NeoBasicParser.DIGIT)
                self.state = 2901
                self.parenthesizedExpression()
                pass
            elif token in [278]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2902
                self.match(NeoBasicParser.PUNCTUATION)
                self.state = 2903
                self.parenthesizedExpression()
                pass
            elif token in [279]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2904
                self.match(NeoBasicParser.SYMBOL)
                self.state = 2905
                self.parenthesizedExpression()
                pass
            elif token in [280]:
                self.enterOuterAlt(localctx, 7)
                self.state = 2906
                self.match(NeoBasicParser.SEPARATOR)
                self.state = 2907
                self.parenthesizedExpression()
                pass
            elif token in [281]:
                self.enterOuterAlt(localctx, 8)
                self.state = 2908
                self.match(NeoBasicParser.NONPRINTABLE)
                self.state = 2909
                self.parenthesizedExpression()
                pass
            elif token in [282]:
                self.enterOuterAlt(localctx, 9)
                self.state = 2910
                self.match(NeoBasicParser.NULL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OptionLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def resultLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.ResultLiteralContext,0)


        def maybeLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.MaybeLiteralContext,0)


        def eitherLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.EitherLiteralContext,0)


        def streamLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.StreamLiteralContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_optionLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOptionLiteral" ):
                listener.enterOptionLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOptionLiteral" ):
                listener.exitOptionLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOptionLiteral" ):
                return visitor.visitOptionLiteral(self)
            else:
                return visitor.visitChildren(self)




    def optionLiteral(self):

        localctx = NeoBasicParser.OptionLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 740, self.RULE_optionLiteral)
        try:
            self.state = 2917
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [298, 299]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2913
                self.resultLiteral()
                pass
            elif token in [301, 302]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2914
                self.maybeLiteral()
                pass
            elif token in [304, 305]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2915
                self.eitherLiteral()
                pass
            elif token in [307, 308]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2916
                self.streamLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResultLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OKAY(self):
            return self.getToken(NeoBasicParser.OKAY, 0)

        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def FAIL(self):
            return self.getToken(NeoBasicParser.FAIL, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_resultLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResultLiteral" ):
                listener.enterResultLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResultLiteral" ):
                listener.exitResultLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResultLiteral" ):
                return visitor.visitResultLiteral(self)
            else:
                return visitor.visitChildren(self)




    def resultLiteral(self):

        localctx = NeoBasicParser.ResultLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 742, self.RULE_resultLiteral)
        try:
            self.state = 2923
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [298]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2919
                self.match(NeoBasicParser.OKAY)
                self.state = 2920
                self.parenthesizedExpression()
                pass
            elif token in [299]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2921
                self.match(NeoBasicParser.FAIL)
                self.state = 2922
                self.parenthesizedExpression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MaybeLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SOME(self):
            return self.getToken(NeoBasicParser.SOME, 0)

        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def NONE(self):
            return self.getToken(NeoBasicParser.NONE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_maybeLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaybeLiteral" ):
                listener.enterMaybeLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaybeLiteral" ):
                listener.exitMaybeLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMaybeLiteral" ):
                return visitor.visitMaybeLiteral(self)
            else:
                return visitor.visitChildren(self)




    def maybeLiteral(self):

        localctx = NeoBasicParser.MaybeLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 744, self.RULE_maybeLiteral)
        try:
            self.state = 2928
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [301]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2925
                self.match(NeoBasicParser.SOME)
                self.state = 2926
                self.parenthesizedExpression()
                pass
            elif token in [302]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2927
                self.match(NeoBasicParser.NONE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EitherLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def YEA(self):
            return self.getToken(NeoBasicParser.YEA, 0)

        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def NAY(self):
            return self.getToken(NeoBasicParser.NAY, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_eitherLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEitherLiteral" ):
                listener.enterEitherLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEitherLiteral" ):
                listener.exitEitherLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEitherLiteral" ):
                return visitor.visitEitherLiteral(self)
            else:
                return visitor.visitChildren(self)




    def eitherLiteral(self):

        localctx = NeoBasicParser.EitherLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 746, self.RULE_eitherLiteral)
        try:
            self.state = 2934
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [304]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2930
                self.match(NeoBasicParser.YEA)
                self.state = 2931
                self.parenthesizedExpression()
                pass
            elif token in [305]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2932
                self.match(NeoBasicParser.NAY)
                self.state = 2933
                self.parenthesizedExpression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StreamLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATUM(self):
            return self.getToken(NeoBasicParser.DATUM, 0)

        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def EOT(self):
            return self.getToken(NeoBasicParser.EOT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_streamLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStreamLiteral" ):
                listener.enterStreamLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStreamLiteral" ):
                listener.exitStreamLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStreamLiteral" ):
                return visitor.visitStreamLiteral(self)
            else:
                return visitor.visitChildren(self)




    def streamLiteral(self):

        localctx = NeoBasicParser.StreamLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 748, self.RULE_streamLiteral)
        try:
            self.state = 2939
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [307]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2936
                self.match(NeoBasicParser.DATUM)
                self.state = 2937
                self.parenthesizedExpression()
                pass
            elif token in [308]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2938
                self.match(NeoBasicParser.EOT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompoundLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sequenceLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.SequenceLiteralContext,0)


        def musicalLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.MusicalLiteralContext,0)


        def compositeLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.CompositeLiteralContext,0)


        def xmlDocLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlDocLiteralContext,0)


        def collectionLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.CollectionLiteralContext,0)


        def objectLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.ObjectLiteralContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_compoundLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompoundLiteral" ):
                listener.enterCompoundLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompoundLiteral" ):
                listener.exitCompoundLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompoundLiteral" ):
                return visitor.visitCompoundLiteral(self)
            else:
                return visitor.visitChildren(self)




    def compoundLiteral(self):

        localctx = NeoBasicParser.CompoundLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 750, self.RULE_compoundLiteral)
        try:
            self.state = 2947
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,267,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2941
                self.sequenceLiteral()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2942
                self.musicalLiteral()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2943
                self.compositeLiteral()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2944
                self.xmlDocLiteral()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2945
                self.collectionLiteral()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2946
                self.objectLiteral()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SequenceLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEMPLATE_SINGLELINE_STRING_LIT(self):
            return self.getToken(NeoBasicParser.TEMPLATE_SINGLELINE_STRING_LIT, 0)

        def TEMPLATE_MULTILINE_STRING_LIT(self):
            return self.getToken(NeoBasicParser.TEMPLATE_MULTILINE_STRING_LIT, 0)

        def VERBATIM_SINGLELINE_STRING_LIT(self):
            return self.getToken(NeoBasicParser.VERBATIM_SINGLELINE_STRING_LIT, 0)

        def VERBATIM_MULTILINE_STRING_LIT(self):
            return self.getToken(NeoBasicParser.VERBATIM_MULTILINE_STRING_LIT, 0)

        def TRANSLATABLE_SINGLELINE_STRING_LIT(self):
            return self.getToken(NeoBasicParser.TRANSLATABLE_SINGLELINE_STRING_LIT, 0)

        def TRANSLATABLE_MULTILINE_STRING_LIT(self):
            return self.getToken(NeoBasicParser.TRANSLATABLE_MULTILINE_STRING_LIT, 0)

        def HEREDOC_STRING_LIT(self):
            return self.getToken(NeoBasicParser.HEREDOC_STRING_LIT, 0)

        def REGULAR_EXPRESSION_LIT(self):
            return self.getToken(NeoBasicParser.REGULAR_EXPRESSION_LIT, 0)

        def ATOM_DOT_LIT(self):
            return self.getToken(NeoBasicParser.ATOM_DOT_LIT, 0)

        def BINARY_LIT(self):
            return self.getToken(NeoBasicParser.BINARY_LIT, 0)

        def NONBLANK(self):
            return self.getToken(NeoBasicParser.NONBLANK, 0)

        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def BLANK(self):
            return self.getToken(NeoBasicParser.BLANK, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_sequenceLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSequenceLiteral" ):
                listener.enterSequenceLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSequenceLiteral" ):
                listener.exitSequenceLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSequenceLiteral" ):
                return visitor.visitSequenceLiteral(self)
            else:
                return visitor.visitChildren(self)




    def sequenceLiteral(self):

        localctx = NeoBasicParser.SequenceLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 752, self.RULE_sequenceLiteral)
        try:
            self.state = 2962
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [431]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2949
                self.match(NeoBasicParser.TEMPLATE_SINGLELINE_STRING_LIT)
                pass
            elif token in [432]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2950
                self.match(NeoBasicParser.TEMPLATE_MULTILINE_STRING_LIT)
                pass
            elif token in [429]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2951
                self.match(NeoBasicParser.VERBATIM_SINGLELINE_STRING_LIT)
                pass
            elif token in [430]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2952
                self.match(NeoBasicParser.VERBATIM_MULTILINE_STRING_LIT)
                pass
            elif token in [433]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2953
                self.match(NeoBasicParser.TRANSLATABLE_SINGLELINE_STRING_LIT)
                pass
            elif token in [434]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2954
                self.match(NeoBasicParser.TRANSLATABLE_MULTILINE_STRING_LIT)
                pass
            elif token in [435]:
                self.enterOuterAlt(localctx, 7)
                self.state = 2955
                self.match(NeoBasicParser.HEREDOC_STRING_LIT)
                pass
            elif token in [436]:
                self.enterOuterAlt(localctx, 8)
                self.state = 2956
                self.match(NeoBasicParser.REGULAR_EXPRESSION_LIT)
                pass
            elif token in [437]:
                self.enterOuterAlt(localctx, 9)
                self.state = 2957
                self.match(NeoBasicParser.ATOM_DOT_LIT)
                pass
            elif token in [426]:
                self.enterOuterAlt(localctx, 10)
                self.state = 2958
                self.match(NeoBasicParser.BINARY_LIT)
                pass
            elif token in [284]:
                self.enterOuterAlt(localctx, 11)
                self.state = 2959
                self.match(NeoBasicParser.NONBLANK)
                self.state = 2960
                self.parenthesizedExpression()
                pass
            elif token in [283]:
                self.enterOuterAlt(localctx, 12)
                self.state = 2961
                self.match(NeoBasicParser.BLANK)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEMPLATE_SINGLELINE_STRING_LIT(self):
            return self.getToken(NeoBasicParser.TEMPLATE_SINGLELINE_STRING_LIT, 0)

        def VERBATIM_SINGLELINE_STRING_LIT(self):
            return self.getToken(NeoBasicParser.VERBATIM_SINGLELINE_STRING_LIT, 0)

        def TRANSLATABLE_SINGLELINE_STRING_LIT(self):
            return self.getToken(NeoBasicParser.TRANSLATABLE_SINGLELINE_STRING_LIT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_stringLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringLiteral" ):
                listener.enterStringLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringLiteral" ):
                listener.exitStringLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringLiteral" ):
                return visitor.visitStringLiteral(self)
            else:
                return visitor.visitChildren(self)




    def stringLiteral(self):

        localctx = NeoBasicParser.StringLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 754, self.RULE_stringLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2964
            _la = self._input.LA(1)
            if not(((((_la - 429)) & ~0x3f) == 0 and ((1 << (_la - 429)) & 21) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MusicalLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATOM_MUSIC_LIT(self):
            return self.getToken(NeoBasicParser.ATOM_MUSIC_LIT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_musicalLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMusicalLiteral" ):
                listener.enterMusicalLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMusicalLiteral" ):
                listener.exitMusicalLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMusicalLiteral" ):
                return visitor.visitMusicalLiteral(self)
            else:
                return visitor.visitChildren(self)




    def musicalLiteral(self):

        localctx = NeoBasicParser.MusicalLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 756, self.RULE_musicalLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2966
            self.match(NeoBasicParser.ATOM_MUSIC_LIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompositeLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def rangeLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.RangeLiteralContext,0)


        def pairLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.PairLiteralContext,0)


        def tupleLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.TupleLiteralContext,0)


        def inetLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.InetLiteralContext,0)


        def uriLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.UriLiteralContext,0)


        def shellPathLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.ShellPathLiteralContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_compositeLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompositeLiteral" ):
                listener.enterCompositeLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompositeLiteral" ):
                listener.exitCompositeLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompositeLiteral" ):
                return visitor.visitCompositeLiteral(self)
            else:
                return visitor.visitChildren(self)




    def compositeLiteral(self):

        localctx = NeoBasicParser.CompositeLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 758, self.RULE_compositeLiteral)
        try:
            self.state = 2974
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,269,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2968
                self.rangeLiteral()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2969
                self.pairLiteral()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2970
                self.tupleLiteral()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2971
                self.inetLiteral()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2972
                self.uriLiteral()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2973
                self.shellPathLiteral()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RangeLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def escalarLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.EscalarLiteralContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.EscalarLiteralContext,i)


        def intervalOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.IntervalOperatorContext,0)


        def leftIntervalOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.LeftIntervalOperatorContext,0)


        def rightIntervalOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.RightIntervalOperatorContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_rangeLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRangeLiteral" ):
                listener.enterRangeLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRangeLiteral" ):
                listener.exitRangeLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRangeLiteral" ):
                return visitor.visitRangeLiteral(self)
            else:
                return visitor.visitChildren(self)




    def rangeLiteral(self):

        localctx = NeoBasicParser.RangeLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 760, self.RULE_rangeLiteral)
        try:
            self.state = 2986
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,270,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2976
                self.escalarLiteral()
                self.state = 2977
                self.intervalOperator()
                self.state = 2978
                self.escalarLiteral()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2980
                self.escalarLiteral()
                self.state = 2981
                self.leftIntervalOperator()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2983
                self.rightIntervalOperator()
                self.state = 2984
                self.escalarLiteral()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PairLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def escalarLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.EscalarLiteralContext,0)


        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_pairLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPairLiteral" ):
                listener.enterPairLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPairLiteral" ):
                listener.exitPairLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPairLiteral" ):
                return visitor.visitPairLiteral(self)
            else:
                return visitor.visitChildren(self)




    def pairLiteral(self):

        localctx = NeoBasicParser.PairLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 762, self.RULE_pairLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2988
            self.escalarLiteral()
            self.state = 2989
            self.match(NeoBasicParser.COLON)
            self.state = 2990
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TupleLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LEFT_PARENTHESIS, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def COMMA(self):
            return self.getToken(NeoBasicParser.COMMA, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_tupleLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTupleLiteral" ):
                listener.enterTupleLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTupleLiteral" ):
                listener.exitTupleLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTupleLiteral" ):
                return visitor.visitTupleLiteral(self)
            else:
                return visitor.visitChildren(self)




    def tupleLiteral(self):

        localctx = NeoBasicParser.TupleLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 764, self.RULE_tupleLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2992
            self.match(NeoBasicParser.LEFT_PARENTHESIS)
            self.state = 2993
            self.expressions()
            self.state = 2995
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==473:
                self.state = 2994
                self.match(NeoBasicParser.COMMA)


            self.state = 2997
            self.match(NeoBasicParser.RIGHT_PARENTHESIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InetLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATOM_DOT_LIT(self):
            return self.getToken(NeoBasicParser.ATOM_DOT_LIT, 0)

        def IPV4(self):
            return self.getToken(NeoBasicParser.IPV4, 0)

        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def IPV6(self):
            return self.getToken(NeoBasicParser.IPV6, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_inetLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInetLiteral" ):
                listener.enterInetLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInetLiteral" ):
                listener.exitInetLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInetLiteral" ):
                return visitor.visitInetLiteral(self)
            else:
                return visitor.visitChildren(self)




    def inetLiteral(self):

        localctx = NeoBasicParser.InetLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 766, self.RULE_inetLiteral)
        try:
            self.state = 3004
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [437]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2999
                self.match(NeoBasicParser.ATOM_DOT_LIT)
                pass
            elif token in [295]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3000
                self.match(NeoBasicParser.IPV4)
                self.state = 3001
                self.parenthesizedExpression()
                pass
            elif token in [296]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3002
                self.match(NeoBasicParser.IPV6)
                self.state = 3003
                self.parenthesizedExpression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UriLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def URL(self):
            return self.getToken(NeoBasicParser.URL, 0)

        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def URN(self):
            return self.getToken(NeoBasicParser.URN, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_uriLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUriLiteral" ):
                listener.enterUriLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUriLiteral" ):
                listener.exitUriLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUriLiteral" ):
                return visitor.visitUriLiteral(self)
            else:
                return visitor.visitChildren(self)




    def uriLiteral(self):

        localctx = NeoBasicParser.UriLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 768, self.RULE_uriLiteral)
        try:
            self.state = 3010
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [293]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3006
                self.match(NeoBasicParser.URL)
                self.state = 3007
                self.parenthesizedExpression()
                pass
            elif token in [294]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3008
                self.match(NeoBasicParser.URN)
                self.state = 3009
                self.parenthesizedExpression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShellPathLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHELL_PATH(self):
            return self.getToken(NeoBasicParser.SHELL_PATH, 0)

        def SHELL_STRING_PATH(self):
            return self.getToken(NeoBasicParser.SHELL_STRING_PATH, 0)

        def FOLDER(self):
            return self.getToken(NeoBasicParser.FOLDER, 0)

        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def FILE(self):
            return self.getToken(NeoBasicParser.FILE, 0)

        def LINKLINKFILE(self):
            return self.getToken(NeoBasicParser.LINKLINKFILE, 0)

        def PIPEFILE(self):
            return self.getToken(NeoBasicParser.PIPEFILE, 0)

        def SOCKETFILE(self):
            return self.getToken(NeoBasicParser.SOCKETFILE, 0)

        def BLOCKDEVICE(self):
            return self.getToken(NeoBasicParser.BLOCKDEVICE, 0)

        def CHARDEVICE(self):
            return self.getToken(NeoBasicParser.CHARDEVICE, 0)

        def NULLDEVICE(self):
            return self.getToken(NeoBasicParser.NULLDEVICE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_shellPathLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShellPathLiteral" ):
                listener.enterShellPathLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShellPathLiteral" ):
                listener.exitShellPathLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShellPathLiteral" ):
                return visitor.visitShellPathLiteral(self)
            else:
                return visitor.visitChildren(self)




    def shellPathLiteral(self):

        localctx = NeoBasicParser.ShellPathLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 770, self.RULE_shellPathLiteral)
        try:
            self.state = 3029
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [449]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3012
                self.match(NeoBasicParser.SHELL_PATH)
                pass
            elif token in [448]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3013
                self.match(NeoBasicParser.SHELL_STRING_PATH)
                pass
            elif token in [285]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3014
                self.match(NeoBasicParser.FOLDER)
                self.state = 3015
                self.parenthesizedExpression()
                pass
            elif token in [286]:
                self.enterOuterAlt(localctx, 4)
                self.state = 3016
                self.match(NeoBasicParser.FILE)
                self.state = 3017
                self.parenthesizedExpression()
                pass
            elif token in [287]:
                self.enterOuterAlt(localctx, 5)
                self.state = 3018
                self.match(NeoBasicParser.LINKLINKFILE)
                self.state = 3019
                self.parenthesizedExpression()
                pass
            elif token in [288]:
                self.enterOuterAlt(localctx, 6)
                self.state = 3020
                self.match(NeoBasicParser.PIPEFILE)
                self.state = 3021
                self.parenthesizedExpression()
                pass
            elif token in [289]:
                self.enterOuterAlt(localctx, 7)
                self.state = 3022
                self.match(NeoBasicParser.SOCKETFILE)
                self.state = 3023
                self.parenthesizedExpression()
                pass
            elif token in [290]:
                self.enterOuterAlt(localctx, 8)
                self.state = 3024
                self.match(NeoBasicParser.BLOCKDEVICE)
                self.state = 3025
                self.parenthesizedExpression()
                pass
            elif token in [291]:
                self.enterOuterAlt(localctx, 9)
                self.state = 3026
                self.match(NeoBasicParser.CHARDEVICE)
                self.state = 3027
                self.parenthesizedExpression()
                pass
            elif token in [292]:
                self.enterOuterAlt(localctx, 10)
                self.state = 3028
                self.match(NeoBasicParser.NULLDEVICE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShellPathLiteralsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shellPathLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ShellPathLiteralContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ShellPathLiteralContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_shellPathLiterals

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShellPathLiterals" ):
                listener.enterShellPathLiterals(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShellPathLiterals" ):
                listener.exitShellPathLiterals(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShellPathLiterals" ):
                return visitor.visitShellPathLiterals(self)
            else:
                return visitor.visitChildren(self)




    def shellPathLiterals(self):

        localctx = NeoBasicParser.ShellPathLiteralsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 772, self.RULE_shellPathLiterals)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3031
            self.shellPathLiteral()
            self.state = 3036
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==473:
                self.state = 3032
                self.match(NeoBasicParser.COMMA)
                self.state = 3033
                self.shellPathLiteral()
                self.state = 3038
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlDocLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def xmlDocElement(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlDocElementContext,0)


        def xmlDocFragment(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlDocFragmentContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlDocLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlDocLiteral" ):
                listener.enterXmlDocLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlDocLiteral" ):
                listener.exitXmlDocLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlDocLiteral" ):
                return visitor.visitXmlDocLiteral(self)
            else:
                return visitor.visitChildren(self)




    def xmlDocLiteral(self):

        localctx = NeoBasicParser.XmlDocLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 774, self.RULE_xmlDocLiteral)
        try:
            self.state = 3041
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [349]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3039
                self.xmlDocElement()
                pass
            elif token in [496, 497]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3040
                self.xmlDocFragment()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlDocElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def xmlElementPaired(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlElementPairedContext,0)


        def xmlElementSelfClosed(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlElementSelfClosedContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlDocElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlDocElement" ):
                listener.enterXmlDocElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlDocElement" ):
                listener.exitXmlDocElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlDocElement" ):
                return visitor.visitXmlDocElement(self)
            else:
                return visitor.visitChildren(self)




    def xmlDocElement(self):

        localctx = NeoBasicParser.XmlDocElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 776, self.RULE_xmlDocElement)
        try:
            self.state = 3045
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,277,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3043
                self.xmlElementPaired()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3044
                self.xmlElementSelfClosed()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlElementPairedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def xmlOpeningElement(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlOpeningElementContext,0)


        def xmlClosingElement(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlClosingElementContext,0)


        def xmlChildren(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.XmlChildrenContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.XmlChildrenContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlElementPaired

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlElementPaired" ):
                listener.enterXmlElementPaired(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlElementPaired" ):
                listener.exitXmlElementPaired(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlElementPaired" ):
                return visitor.visitXmlElementPaired(self)
            else:
                return visitor.visitChildren(self)




    def xmlElementPaired(self):

        localctx = NeoBasicParser.XmlElementPairedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 778, self.RULE_xmlElementPaired)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3047
            self.xmlOpeningElement()
            self.state = 3051
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==1 or _la==349 or _la==470:
                self.state = 3048
                self.xmlChildren()
                self.state = 3053
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 3054
            self.xmlClosingElement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlOpeningElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_ANGLE(self):
            return self.getToken(NeoBasicParser.LEFT_ANGLE, 0)

        def xmlTagName(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlTagNameContext,0)


        def RIGHT_ANGLE(self):
            return self.getToken(NeoBasicParser.RIGHT_ANGLE, 0)

        def xmlAttributes(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.XmlAttributesContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.XmlAttributesContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlOpeningElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlOpeningElement" ):
                listener.enterXmlOpeningElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlOpeningElement" ):
                listener.exitXmlOpeningElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlOpeningElement" ):
                return visitor.visitXmlOpeningElement(self)
            else:
                return visitor.visitChildren(self)




    def xmlOpeningElement(self):

        localctx = NeoBasicParser.XmlOpeningElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 780, self.RULE_xmlOpeningElement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3056
            self.match(NeoBasicParser.LEFT_ANGLE)
            self.state = 3057
            self.xmlTagName()
            self.state = 3061
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==415:
                self.state = 3058
                self.xmlAttributes()
                self.state = 3063
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 3064
            self.match(NeoBasicParser.RIGHT_ANGLE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlClosingElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def XML_CLOSING_TAG(self):
            return self.getToken(NeoBasicParser.XML_CLOSING_TAG, 0)

        def xmlTagName(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlTagNameContext,0)


        def RIGHT_ANGLE(self):
            return self.getToken(NeoBasicParser.RIGHT_ANGLE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlClosingElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlClosingElement" ):
                listener.enterXmlClosingElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlClosingElement" ):
                listener.exitXmlClosingElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlClosingElement" ):
                return visitor.visitXmlClosingElement(self)
            else:
                return visitor.visitChildren(self)




    def xmlClosingElement(self):

        localctx = NeoBasicParser.XmlClosingElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 782, self.RULE_xmlClosingElement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3066
            self.match(NeoBasicParser.XML_CLOSING_TAG)
            self.state = 3067
            self.xmlTagName()
            self.state = 3068
            self.match(NeoBasicParser.RIGHT_ANGLE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlElementSelfClosedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_ANGLE(self):
            return self.getToken(NeoBasicParser.LEFT_ANGLE, 0)

        def xmlTagName(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlTagNameContext,0)


        def XML_SELFCLOSING_TAG(self):
            return self.getToken(NeoBasicParser.XML_SELFCLOSING_TAG, 0)

        def xmlAttributes(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.XmlAttributesContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.XmlAttributesContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlElementSelfClosed

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlElementSelfClosed" ):
                listener.enterXmlElementSelfClosed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlElementSelfClosed" ):
                listener.exitXmlElementSelfClosed(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlElementSelfClosed" ):
                return visitor.visitXmlElementSelfClosed(self)
            else:
                return visitor.visitChildren(self)




    def xmlElementSelfClosed(self):

        localctx = NeoBasicParser.XmlElementSelfClosedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 784, self.RULE_xmlElementSelfClosed)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3070
            self.match(NeoBasicParser.LEFT_ANGLE)
            self.state = 3071
            self.xmlTagName()
            self.state = 3075
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==415:
                self.state = 3072
                self.xmlAttributes()
                self.state = 3077
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 3078
            self.match(NeoBasicParser.XML_SELFCLOSING_TAG)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlDocFragmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def xmlFragmentPaired(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlFragmentPairedContext,0)


        def xmlFragmentSelfClosed(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlFragmentSelfClosedContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlDocFragment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlDocFragment" ):
                listener.enterXmlDocFragment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlDocFragment" ):
                listener.exitXmlDocFragment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlDocFragment" ):
                return visitor.visitXmlDocFragment(self)
            else:
                return visitor.visitChildren(self)




    def xmlDocFragment(self):

        localctx = NeoBasicParser.XmlDocFragmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 786, self.RULE_xmlDocFragment)
        try:
            self.state = 3082
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [496]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3080
                self.xmlFragmentPaired()
                pass
            elif token in [497]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3081
                self.xmlFragmentSelfClosed()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlFragmentPairedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def XML_OPENING_FRAGMENT(self):
            return self.getToken(NeoBasicParser.XML_OPENING_FRAGMENT, 0)

        def XML_CLOSING_FRAGMENT(self):
            return self.getToken(NeoBasicParser.XML_CLOSING_FRAGMENT, 0)

        def xmlChildren(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.XmlChildrenContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.XmlChildrenContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlFragmentPaired

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlFragmentPaired" ):
                listener.enterXmlFragmentPaired(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlFragmentPaired" ):
                listener.exitXmlFragmentPaired(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlFragmentPaired" ):
                return visitor.visitXmlFragmentPaired(self)
            else:
                return visitor.visitChildren(self)




    def xmlFragmentPaired(self):

        localctx = NeoBasicParser.XmlFragmentPairedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 788, self.RULE_xmlFragmentPaired)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3084
            self.match(NeoBasicParser.XML_OPENING_FRAGMENT)
            self.state = 3088
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==1 or _la==349 or _la==470:
                self.state = 3085
                self.xmlChildren()
                self.state = 3090
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 3091
            self.match(NeoBasicParser.XML_CLOSING_FRAGMENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlFragmentSelfClosedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def XML_CLOSING_FRAGMENT(self):
            return self.getToken(NeoBasicParser.XML_CLOSING_FRAGMENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlFragmentSelfClosed

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlFragmentSelfClosed" ):
                listener.enterXmlFragmentSelfClosed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlFragmentSelfClosed" ):
                listener.exitXmlFragmentSelfClosed(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlFragmentSelfClosed" ):
                return visitor.visitXmlFragmentSelfClosed(self)
            else:
                return visitor.visitChildren(self)




    def xmlFragmentSelfClosed(self):

        localctx = NeoBasicParser.XmlFragmentSelfClosedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 790, self.RULE_xmlFragmentSelfClosed)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3093
            self.match(NeoBasicParser.XML_CLOSING_FRAGMENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlTagNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(NeoBasicParser.IDENTIFIER, 0)

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlTagName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlTagName" ):
                listener.enterXmlTagName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlTagName" ):
                listener.exitXmlTagName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlTagName" ):
                return visitor.visitXmlTagName(self)
            else:
                return visitor.visitChildren(self)




    def xmlTagName(self):

        localctx = NeoBasicParser.XmlTagNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 792, self.RULE_xmlTagName)
        try:
            self.state = 3097
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,283,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3095
                self.match(NeoBasicParser.IDENTIFIER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3096
                self.qualifiedIdentifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlAttributesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def xmlTagName(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlTagNameContext,0)


        def EQUAL(self):
            return self.getToken(NeoBasicParser.EQUAL, 0)

        def xmlAttributeValue(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlAttributeValueContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlAttributes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlAttributes" ):
                listener.enterXmlAttributes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlAttributes" ):
                listener.exitXmlAttributes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlAttributes" ):
                return visitor.visitXmlAttributes(self)
            else:
                return visitor.visitChildren(self)




    def xmlAttributes(self):

        localctx = NeoBasicParser.XmlAttributesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 794, self.RULE_xmlAttributes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3099
            self.xmlTagName()
            self.state = 3102
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==389:
                self.state = 3100
                self.match(NeoBasicParser.EQUAL)
                self.state = 3101
                self.xmlAttributeValue()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlAttributeValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def literal(self):
            return self.getTypedRuleContext(NeoBasicParser.LiteralContext,0)


        def expressionPlaceholder(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionPlaceholderContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlAttributeValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlAttributeValue" ):
                listener.enterXmlAttributeValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlAttributeValue" ):
                listener.exitXmlAttributeValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlAttributeValue" ):
                return visitor.visitXmlAttributeValue(self)
            else:
                return visitor.visitChildren(self)




    def xmlAttributeValue(self):

        localctx = NeoBasicParser.XmlAttributeValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 796, self.RULE_xmlAttributeValue)
        try:
            self.state = 3106
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,285,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3104
                self.literal()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3105
                self.expressionPlaceholder()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class XmlChildrenContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def xmlDocElement(self):
            return self.getTypedRuleContext(NeoBasicParser.XmlDocElementContext,0)


        def expressionPlaceholder(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionPlaceholderContext,0)


        def XML_CONTENT(self):
            return self.getToken(NeoBasicParser.XML_CONTENT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_xmlChildren

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXmlChildren" ):
                listener.enterXmlChildren(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXmlChildren" ):
                listener.exitXmlChildren(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXmlChildren" ):
                return visitor.visitXmlChildren(self)
            else:
                return visitor.visitChildren(self)




    def xmlChildren(self):

        localctx = NeoBasicParser.XmlChildrenContext(self, self._ctx, self.state)
        self.enterRule(localctx, 798, self.RULE_xmlChildren)
        try:
            self.state = 3111
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [349]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3108
                self.xmlDocElement()
                pass
            elif token in [470]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3109
                self.expressionPlaceholder()
                pass
            elif token in [1]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3110
                self.match(NeoBasicParser.XML_CONTENT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionPlaceholderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_CURLY(self):
            return self.getToken(NeoBasicParser.LEFT_CURLY, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def RIGHT_CURLY(self):
            return self.getToken(NeoBasicParser.RIGHT_CURLY, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_expressionPlaceholder

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionPlaceholder" ):
                listener.enterExpressionPlaceholder(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionPlaceholder" ):
                listener.exitExpressionPlaceholder(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressionPlaceholder" ):
                return visitor.visitExpressionPlaceholder(self)
            else:
                return visitor.visitChildren(self)




    def expressionPlaceholder(self):

        localctx = NeoBasicParser.ExpressionPlaceholderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 800, self.RULE_expressionPlaceholder)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3113
            self.match(NeoBasicParser.LEFT_CURLY)
            self.state = 3114
            self.expression(0)
            self.state = 3115
            self.match(NeoBasicParser.RIGHT_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CollectionLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def collectionLiteralValue(self):
            return self.getTypedRuleContext(NeoBasicParser.CollectionLiteralValueContext,0)


        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def arrayAosToSoaLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.ArrayAosToSoaLiteralContext,0)


        def listComprehension(self):
            return self.getTypedRuleContext(NeoBasicParser.ListComprehensionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_collectionLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCollectionLiteral" ):
                listener.enterCollectionLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCollectionLiteral" ):
                listener.exitCollectionLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCollectionLiteral" ):
                return visitor.visitCollectionLiteral(self)
            else:
                return visitor.visitChildren(self)




    def collectionLiteral(self):

        localctx = NeoBasicParser.CollectionLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 802, self.RULE_collectionLiteral)
        try:
            self.state = 3123
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,288,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3118
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,287,self._ctx)
                if la_ == 1:
                    self.state = 3117
                    self.type_(0)


                self.state = 3120
                self.collectionLiteralValue()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3121
                self.arrayAosToSoaLiteral()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3122
                self.listComprehension()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CollectionLiteralValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_BRACKET(self):
            return self.getToken(NeoBasicParser.LEFT_BRACKET, 0)

        def RIGHT_BRACKET(self):
            return self.getToken(NeoBasicParser.RIGHT_BRACKET, 0)

        def elements(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ElementsContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ElementsContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_collectionLiteralValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCollectionLiteralValue" ):
                listener.enterCollectionLiteralValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCollectionLiteralValue" ):
                listener.exitCollectionLiteralValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCollectionLiteralValue" ):
                return visitor.visitCollectionLiteralValue(self)
            else:
                return visitor.visitChildren(self)




    def collectionLiteralValue(self):

        localctx = NeoBasicParser.CollectionLiteralValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 804, self.RULE_collectionLiteralValue)
        self._la = 0 # Token type
        try:
            self.state = 3138
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,291,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3125
                self.match(NeoBasicParser.LEFT_BRACKET)
                self.state = 3126
                self.match(NeoBasicParser.RIGHT_BRACKET)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3127
                self.match(NeoBasicParser.LEFT_BRACKET)
                self.state = 3132 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 3128
                    self.elements()
                    self.state = 3130
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==473:
                        self.state = 3129
                        self.match(NeoBasicParser.COMMA)


                    self.state = 3134 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 1649529585664) != 0) or ((((_la - 127)) & ~0x3f) == 0 and ((1 << (_la - 127)) & -257706303489) != 0) or ((((_la - 191)) & ~0x3f) == 0 and ((1 << (_la - 191)) & -1) != 0) or ((((_la - 255)) & ~0x3f) == 0 and ((1 << (_la - 255)) & 18014398507384831) != 0) or ((((_la - 321)) & ~0x3f) == 0 and ((1 << (_la - 321)) & 2814750039736063) != 0) or ((((_la - 415)) & ~0x3f) == 0 and ((1 << (_la - 415)) & 47287830447128569) != 0) or ((((_la - 485)) & ~0x3f) == 0 and ((1 << (_la - 485)) & 6151) != 0)):
                        break

                self.state = 3136
                self.match(NeoBasicParser.RIGHT_BRACKET)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def element(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ElementContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ElementContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_elements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElements" ):
                listener.enterElements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElements" ):
                listener.exitElements(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElements" ):
                return visitor.visitElements(self)
            else:
                return visitor.visitChildren(self)




    def elements(self):

        localctx = NeoBasicParser.ElementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 806, self.RULE_elements)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3141 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 3140
                    self.element()

                else:
                    raise NoViableAltException(self)
                self.state = 3143 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,292,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def elementValue(self):
            return self.getTypedRuleContext(NeoBasicParser.ElementValueContext,0)


        def elementKey(self):
            return self.getTypedRuleContext(NeoBasicParser.ElementKeyContext,0)


        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_element

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElement" ):
                listener.enterElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElement" ):
                listener.exitElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElement" ):
                return visitor.visitElement(self)
            else:
                return visitor.visitChildren(self)




    def element(self):

        localctx = NeoBasicParser.ElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 808, self.RULE_element)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3148
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,293,self._ctx)
            if la_ == 1:
                self.state = 3145
                self.elementKey()
                self.state = 3146
                self.match(NeoBasicParser.COLON)


            self.state = 3150
            self.elementValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementKeyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_elementKey

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementKey" ):
                listener.enterElementKey(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementKey" ):
                listener.exitElementKey(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElementKey" ):
                return visitor.visitElementKey(self)
            else:
                return visitor.visitChildren(self)




    def elementKey(self):

        localctx = NeoBasicParser.ElementKeyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 810, self.RULE_elementKey)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3152
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElementValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_elementValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElementValue" ):
                listener.enterElementValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElementValue" ):
                listener.exitElementValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElementValue" ):
                return visitor.visitElementValue(self)
            else:
                return visitor.visitChildren(self)




    def elementValue(self):

        localctx = NeoBasicParser.ElementValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 812, self.RULE_elementValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3154
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayAosToSoaLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_BRACKET(self):
            return self.getToken(NeoBasicParser.LEFT_BRACKET, 0)

        def RIGHT_BRACKET(self):
            return self.getToken(NeoBasicParser.RIGHT_BRACKET, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_arrayAosToSoaLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayAosToSoaLiteral" ):
                listener.enterArrayAosToSoaLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayAosToSoaLiteral" ):
                listener.exitArrayAosToSoaLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayAosToSoaLiteral" ):
                return visitor.visitArrayAosToSoaLiteral(self)
            else:
                return visitor.visitChildren(self)




    def arrayAosToSoaLiteral(self):

        localctx = NeoBasicParser.ArrayAosToSoaLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 814, self.RULE_arrayAosToSoaLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3156
            self.match(NeoBasicParser.LEFT_BRACKET)
            self.state = 3157
            self.match(NeoBasicParser.RIGHT_BRACKET)
            self.state = 3158
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ListComprehensionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_BRACKET(self):
            return self.getToken(NeoBasicParser.LEFT_BRACKET, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def RIGHT_BRACKET(self):
            return self.getToken(NeoBasicParser.RIGHT_BRACKET, 0)

        def comprehensionClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ComprehensionClauseContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ComprehensionClauseContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_listComprehension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterListComprehension" ):
                listener.enterListComprehension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitListComprehension" ):
                listener.exitListComprehension(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitListComprehension" ):
                return visitor.visitListComprehension(self)
            else:
                return visitor.visitChildren(self)




    def listComprehension(self):

        localctx = NeoBasicParser.ListComprehensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 816, self.RULE_listComprehension)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3160
            self.match(NeoBasicParser.LEFT_BRACKET)
            self.state = 3161
            self.expressions()
            self.state = 3163 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 3162
                self.comprehensionClause()
                self.state = 3165 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==93):
                    break

            self.state = 3167
            self.match(NeoBasicParser.RIGHT_BRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComprehensionClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def forEachClause(self):
            return self.getTypedRuleContext(NeoBasicParser.ForEachClauseContext,0)


        def IF(self):
            return self.getToken(NeoBasicParser.IF, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_comprehensionClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComprehensionClause" ):
                listener.enterComprehensionClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComprehensionClause" ):
                listener.exitComprehensionClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComprehensionClause" ):
                return visitor.visitComprehensionClause(self)
            else:
                return visitor.visitChildren(self)




    def comprehensionClause(self):

        localctx = NeoBasicParser.ComprehensionClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 818, self.RULE_comprehensionClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3169
            self.forEachClause()
            self.state = 3172
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==77:
                self.state = 3170
                self.match(NeoBasicParser.IF)
                self.state = 3171
                self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def objectLiteralValue(self):
            return self.getTypedRuleContext(NeoBasicParser.ObjectLiteralValueContext,0)


        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_objectLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectLiteral" ):
                listener.enterObjectLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectLiteral" ):
                listener.exitObjectLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectLiteral" ):
                return visitor.visitObjectLiteral(self)
            else:
                return visitor.visitChildren(self)




    def objectLiteral(self):

        localctx = NeoBasicParser.ObjectLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 820, self.RULE_objectLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3175
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 1649529585664) != 0) or ((((_la - 165)) & ~0x3f) == 0 and ((1 << (_la - 165)) & -1) != 0) or ((((_la - 229)) & ~0x3f) == 0 and ((1 << (_la - 229)) & 33554431) != 0) or ((((_la - 297)) & ~0x3f) == 0 and ((1 << (_la - 297)) & 585) != 0) or _la==415 or _la==468:
                self.state = 3174
                self.type_(0)


            self.state = 3177
            self.objectLiteralValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectLiteralValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_CURLY(self):
            return self.getToken(NeoBasicParser.LEFT_CURLY, 0)

        def RIGHT_CURLY(self):
            return self.getToken(NeoBasicParser.RIGHT_CURLY, 0)

        def objectMembers(self):
            return self.getTypedRuleContext(NeoBasicParser.ObjectMembersContext,0)


        def COMMA(self):
            return self.getToken(NeoBasicParser.COMMA, 0)

        def logicalInstructionSuite(self):
            return self.getTypedRuleContext(NeoBasicParser.LogicalInstructionSuiteContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_objectLiteralValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectLiteralValue" ):
                listener.enterObjectLiteralValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectLiteralValue" ):
                listener.exitObjectLiteralValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectLiteralValue" ):
                return visitor.visitObjectLiteralValue(self)
            else:
                return visitor.visitChildren(self)




    def objectLiteralValue(self):

        localctx = NeoBasicParser.ObjectLiteralValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 822, self.RULE_objectLiteralValue)
        self._la = 0 # Token type
        try:
            self.state = 3192
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,298,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3179
                self.match(NeoBasicParser.LEFT_CURLY)
                self.state = 3180
                self.match(NeoBasicParser.RIGHT_CURLY)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3181
                self.match(NeoBasicParser.LEFT_CURLY)
                self.state = 3182
                self.objectMembers()
                self.state = 3184
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==473:
                    self.state = 3183
                    self.match(NeoBasicParser.COMMA)


                self.state = 3186
                self.match(NeoBasicParser.RIGHT_CURLY)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3188
                self.match(NeoBasicParser.LEFT_CURLY)
                self.state = 3189
                self.logicalInstructionSuite()
                self.state = 3190
                self.match(NeoBasicParser.RIGHT_CURLY)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectMembersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def objectMember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ObjectMemberContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ObjectMemberContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_objectMembers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectMembers" ):
                listener.enterObjectMembers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectMembers" ):
                listener.exitObjectMembers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectMembers" ):
                return visitor.visitObjectMembers(self)
            else:
                return visitor.visitChildren(self)




    def objectMembers(self):

        localctx = NeoBasicParser.ObjectMembersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 824, self.RULE_objectMembers)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3194
            self.objectMember()
            self.state = 3199
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,299,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 3195
                    self.match(NeoBasicParser.COMMA)
                    self.state = 3196
                    self.objectMember() 
                self.state = 3201
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,299,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def memberValue(self):
            return self.getTypedRuleContext(NeoBasicParser.MemberValueContext,0)


        def memberName(self):
            return self.getTypedRuleContext(NeoBasicParser.MemberNameContext,0)


        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_objectMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectMember" ):
                listener.enterObjectMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectMember" ):
                listener.exitObjectMember(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectMember" ):
                return visitor.visitObjectMember(self)
            else:
                return visitor.visitChildren(self)




    def objectMember(self):

        localctx = NeoBasicParser.ObjectMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 826, self.RULE_objectMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3205
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,300,self._ctx)
            if la_ == 1:
                self.state = 3202
                self.memberName()
                self.state = 3203
                self.match(NeoBasicParser.COLON)


            self.state = 3207
            self.memberValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MemberNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def inferredDecoratedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.InferredDecoratedIdentifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_memberName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMemberName" ):
                listener.enterMemberName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMemberName" ):
                listener.exitMemberName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMemberName" ):
                return visitor.visitMemberName(self)
            else:
                return visitor.visitChildren(self)




    def memberName(self):

        localctx = NeoBasicParser.MemberNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 828, self.RULE_memberName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3209
            self.inferredDecoratedIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MemberValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_memberValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMemberValue" ):
                listener.enterMemberValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMemberValue" ):
                listener.exitMemberValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMemberValue" ):
                return visitor.visitMemberValue(self)
            else:
                return visitor.visitChildren(self)




    def memberValue(self):

        localctx = NeoBasicParser.MemberValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 830, self.RULE_memberValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3211
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LambdaLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def lambdaClause(self):
            return self.getTypedRuleContext(NeoBasicParser.LambdaClauseContext,0)


        def lambdaStatement(self):
            return self.getTypedRuleContext(NeoBasicParser.LambdaStatementContext,0)


        def arithmeticComprehension(self):
            return self.getTypedRuleContext(NeoBasicParser.ArithmeticComprehensionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_lambdaLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLambdaLiteral" ):
                listener.enterLambdaLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLambdaLiteral" ):
                listener.exitLambdaLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLambdaLiteral" ):
                return visitor.visitLambdaLiteral(self)
            else:
                return visitor.visitChildren(self)




    def lambdaLiteral(self):

        localctx = NeoBasicParser.LambdaLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 832, self.RULE_lambdaLiteral)
        try:
            self.state = 3216
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [141]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3213
                self.lambdaClause()
                pass
            elif token in [487]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3214
                self.lambdaStatement()
                pass
            elif token in [150, 151, 152, 153, 154, 155, 156, 321, 322, 326, 327, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3215
                self.arithmeticComprehension()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LambdaClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LAMBDA(self):
            return self.getToken(NeoBasicParser.LAMBDA, 0)

        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def procParameters(self):
            return self.getTypedRuleContext(NeoBasicParser.ProcParametersContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_lambdaClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLambdaClause" ):
                listener.enterLambdaClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLambdaClause" ):
                listener.exitLambdaClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLambdaClause" ):
                return visitor.visitLambdaClause(self)
            else:
                return visitor.visitChildren(self)




    def lambdaClause(self):

        localctx = NeoBasicParser.LambdaClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 834, self.RULE_lambdaClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3218
            self.match(NeoBasicParser.LAMBDA)
            self.state = 3220
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==330 or ((((_la - 415)) & ~0x3f) == 0 and ((1 << (_la - 415)) & 7) != 0) or _la==482 or _la==484:
                self.state = 3219
                self.procParameters()


            self.state = 3222
            self.match(NeoBasicParser.COLON)
            self.state = 3223
            self.expressions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LambdaStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LAMBDA_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LAMBDA_PARENTHESIS, 0)

        def statementBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementBlockContext,0)


        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_lambdaStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLambdaStatement" ):
                listener.enterLambdaStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLambdaStatement" ):
                listener.exitLambdaStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLambdaStatement" ):
                return visitor.visitLambdaStatement(self)
            else:
                return visitor.visitChildren(self)




    def lambdaStatement(self):

        localctx = NeoBasicParser.LambdaStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 836, self.RULE_lambdaStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3225
            self.match(NeoBasicParser.LAMBDA_PARENTHESIS)
            self.state = 3226
            self.statementBlock()
            self.state = 3227
            self.match(NeoBasicParser.RIGHT_PARENTHESIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArithmeticComprehensionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def binaryArithmeticOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryArithmeticOperatorContext,0)


        def LAMBDA_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LAMBDA_PARENTHESIS, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def comprehensionClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ComprehensionClauseContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ComprehensionClauseContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_arithmeticComprehension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArithmeticComprehension" ):
                listener.enterArithmeticComprehension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArithmeticComprehension" ):
                listener.exitArithmeticComprehension(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArithmeticComprehension" ):
                return visitor.visitArithmeticComprehension(self)
            else:
                return visitor.visitChildren(self)




    def arithmeticComprehension(self):

        localctx = NeoBasicParser.ArithmeticComprehensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 838, self.RULE_arithmeticComprehension)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3229
            self.binaryArithmeticOperator()
            self.state = 3230
            self.match(NeoBasicParser.LAMBDA_PARENTHESIS)
            self.state = 3231
            self.expression(0)
            self.state = 3233 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 3232
                self.comprehensionClause()
                self.state = 3235 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==93):
                    break

            self.state = 3237
            self.match(NeoBasicParser.RIGHT_PARENTHESIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredeclaredValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def predefinedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.PredefinedIdentifierContext,0)


        def predefinedShellValue(self):
            return self.getTypedRuleContext(NeoBasicParser.PredefinedShellValueContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_predeclaredValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredeclaredValue" ):
                listener.enterPredeclaredValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredeclaredValue" ):
                listener.exitPredeclaredValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredeclaredValue" ):
                return visitor.visitPredeclaredValue(self)
            else:
                return visitor.visitChildren(self)




    def predeclaredValue(self):

        localctx = NeoBasicParser.PredeclaredValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 840, self.RULE_predeclaredValue)
        try:
            self.state = 3241
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [127, 128, 129, 130, 131, 132, 133, 486]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3239
                self.predefinedIdentifier()
                pass
            elif token in [440, 441, 442, 443, 444, 445, 446, 447]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3240
                self.predefinedShellValue()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredefinedIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def THIS(self):
            return self.getToken(NeoBasicParser.THIS, 0)

        def IOTA(self):
            return self.getToken(NeoBasicParser.IOTA, 0)

        def NTH(self):
            return self.getToken(NeoBasicParser.NTH, 0)

        def IT(self):
            return self.getToken(NeoBasicParser.IT, 0)

        def SELF(self):
            return self.getToken(NeoBasicParser.SELF, 0)

        def SUPER(self):
            return self.getToken(NeoBasicParser.SUPER, 0)

        def PARENT(self):
            return self.getToken(NeoBasicParser.PARENT, 0)

        def UNDERSCORE(self):
            return self.getToken(NeoBasicParser.UNDERSCORE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_predefinedIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredefinedIdentifier" ):
                listener.enterPredefinedIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredefinedIdentifier" ):
                listener.exitPredefinedIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredefinedIdentifier" ):
                return visitor.visitPredefinedIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def predefinedIdentifier(self):

        localctx = NeoBasicParser.PredefinedIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 842, self.RULE_predefinedIdentifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3243
            _la = self._input.LA(1)
            if not(((((_la - 127)) & ~0x3f) == 0 and ((1 << (_la - 127)) & 127) != 0) or _la==486):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredefinedShellValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHELL_CURRENT_OPTIONS(self):
            return self.getToken(NeoBasicParser.SHELL_CURRENT_OPTIONS, 0)

        def SHELL_EXIT_STATUS(self):
            return self.getToken(NeoBasicParser.SHELL_EXIT_STATUS, 0)

        def SHELL_ERROR_LEVEL(self):
            return self.getToken(NeoBasicParser.SHELL_ERROR_LEVEL, 0)

        def SHELL_BKG_EXIT_STATUS(self):
            return self.getToken(NeoBasicParser.SHELL_BKG_EXIT_STATUS, 0)

        def SHELL_BKG_ERROR_LEVEL(self):
            return self.getToken(NeoBasicParser.SHELL_BKG_ERROR_LEVEL, 0)

        def SHELL_FILE_DESCRIPTOR(self):
            return self.getToken(NeoBasicParser.SHELL_FILE_DESCRIPTOR, 0)

        def SHELL_CMD_ARGUMENT(self):
            return self.getToken(NeoBasicParser.SHELL_CMD_ARGUMENT, 0)

        def SHELL_ENV_VARIABLE(self):
            return self.getToken(NeoBasicParser.SHELL_ENV_VARIABLE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_predefinedShellValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredefinedShellValue" ):
                listener.enterPredefinedShellValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredefinedShellValue" ):
                listener.exitPredefinedShellValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredefinedShellValue" ):
                return visitor.visitPredefinedShellValue(self)
            else:
                return visitor.visitChildren(self)




    def predefinedShellValue(self):

        localctx = NeoBasicParser.PredefinedShellValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 844, self.RULE_predefinedShellValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3245
            _la = self._input.LA(1)
            if not(((((_la - 440)) & ~0x3f) == 0 and ((1 << (_la - 440)) & 255) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredeclaredFunctorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def predeclaredFact(self):
            return self.getTypedRuleContext(NeoBasicParser.PredeclaredFactContext,0)


        def predeclaredFmap(self):
            return self.getTypedRuleContext(NeoBasicParser.PredeclaredFmapContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_predeclaredFunctor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredeclaredFunctor" ):
                listener.enterPredeclaredFunctor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredeclaredFunctor" ):
                listener.exitPredeclaredFunctor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredeclaredFunctor" ):
                return visitor.visitPredeclaredFunctor(self)
            else:
                return visitor.visitChildren(self)




    def predeclaredFunctor(self):

        localctx = NeoBasicParser.PredeclaredFunctorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 846, self.RULE_predeclaredFunctor)
        try:
            self.state = 3249
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [254, 255, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 298, 299, 301, 302, 304, 305, 307, 308]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3247
                self.predeclaredFact()
                pass
            elif token in [134, 135, 136, 137, 138, 139]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3248
                self.predeclaredFmap()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredeclaredFactContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(NeoBasicParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(NeoBasicParser.FALSE, 0)

        def ZERO(self):
            return self.getToken(NeoBasicParser.ZERO, 0)

        def MINVALUE(self):
            return self.getToken(NeoBasicParser.MINVALUE, 0)

        def MAXVALUE(self):
            return self.getToken(NeoBasicParser.MAXVALUE, 0)

        def NAN(self):
            return self.getToken(NeoBasicParser.NAN, 0)

        def POSITIVEINFINITY(self):
            return self.getToken(NeoBasicParser.POSITIVEINFINITY, 0)

        def NEGATIVEINFINITY(self):
            return self.getToken(NeoBasicParser.NEGATIVEINFINITY, 0)

        def LOCALDATE(self):
            return self.getToken(NeoBasicParser.LOCALDATE, 0)

        def LOCALDATETIME(self):
            return self.getToken(NeoBasicParser.LOCALDATETIME, 0)

        def OFFSETDATE(self):
            return self.getToken(NeoBasicParser.OFFSETDATE, 0)

        def OFFSETDATETIME(self):
            return self.getToken(NeoBasicParser.OFFSETDATETIME, 0)

        def ZONEDDATE(self):
            return self.getToken(NeoBasicParser.ZONEDDATE, 0)

        def ZONEDDATETIME(self):
            return self.getToken(NeoBasicParser.ZONEDDATETIME, 0)

        def TOMORROW(self):
            return self.getToken(NeoBasicParser.TOMORROW, 0)

        def TODAY(self):
            return self.getToken(NeoBasicParser.TODAY, 0)

        def NOW(self):
            return self.getToken(NeoBasicParser.NOW, 0)

        def YESTERDAY(self):
            return self.getToken(NeoBasicParser.YESTERDAY, 0)

        def EON(self):
            return self.getToken(NeoBasicParser.EON, 0)

        def EPOCH(self):
            return self.getToken(NeoBasicParser.EPOCH, 0)

        def LETTER(self):
            return self.getToken(NeoBasicParser.LETTER, 0)

        def DIGIT(self):
            return self.getToken(NeoBasicParser.DIGIT, 0)

        def PUNCTUATION(self):
            return self.getToken(NeoBasicParser.PUNCTUATION, 0)

        def SYMBOL(self):
            return self.getToken(NeoBasicParser.SYMBOL, 0)

        def SEPARATOR(self):
            return self.getToken(NeoBasicParser.SEPARATOR, 0)

        def NONPRINTABLE(self):
            return self.getToken(NeoBasicParser.NONPRINTABLE, 0)

        def NULL(self):
            return self.getToken(NeoBasicParser.NULL, 0)

        def NONBLANK(self):
            return self.getToken(NeoBasicParser.NONBLANK, 0)

        def BLANK(self):
            return self.getToken(NeoBasicParser.BLANK, 0)

        def FOLDER(self):
            return self.getToken(NeoBasicParser.FOLDER, 0)

        def FILE(self):
            return self.getToken(NeoBasicParser.FILE, 0)

        def LINKLINKFILE(self):
            return self.getToken(NeoBasicParser.LINKLINKFILE, 0)

        def PIPEFILE(self):
            return self.getToken(NeoBasicParser.PIPEFILE, 0)

        def SOCKETFILE(self):
            return self.getToken(NeoBasicParser.SOCKETFILE, 0)

        def BLOCKDEVICE(self):
            return self.getToken(NeoBasicParser.BLOCKDEVICE, 0)

        def CHARDEVICE(self):
            return self.getToken(NeoBasicParser.CHARDEVICE, 0)

        def NULLDEVICE(self):
            return self.getToken(NeoBasicParser.NULLDEVICE, 0)

        def OKAY(self):
            return self.getToken(NeoBasicParser.OKAY, 0)

        def FAIL(self):
            return self.getToken(NeoBasicParser.FAIL, 0)

        def SOME(self):
            return self.getToken(NeoBasicParser.SOME, 0)

        def NONE(self):
            return self.getToken(NeoBasicParser.NONE, 0)

        def YEA(self):
            return self.getToken(NeoBasicParser.YEA, 0)

        def NAY(self):
            return self.getToken(NeoBasicParser.NAY, 0)

        def DATUM(self):
            return self.getToken(NeoBasicParser.DATUM, 0)

        def EOT(self):
            return self.getToken(NeoBasicParser.EOT, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_predeclaredFact

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredeclaredFact" ):
                listener.enterPredeclaredFact(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredeclaredFact" ):
                listener.exitPredeclaredFact(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredeclaredFact" ):
                return visitor.visitPredeclaredFact(self)
            else:
                return visitor.visitChildren(self)




    def predeclaredFact(self):

        localctx = NeoBasicParser.PredeclaredFactContext(self, self._ctx, self.state)
        self.enterRule(localctx, 848, self.RULE_predeclaredFact)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3251
            _la = self._input.LA(1)
            if not(((((_la - 254)) & ~0x3f) == 0 and ((1 << (_la - 254)) & 30874836259569659) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredeclaredFmapContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALL(self):
            return self.getToken(NeoBasicParser.ALL, 0)

        def ANY(self):
            return self.getToken(NeoBasicParser.ANY, 0)

        def LOT(self):
            return self.getToken(NeoBasicParser.LOT, 0)

        def NIL(self):
            return self.getToken(NeoBasicParser.NIL, 0)

        def ONE(self):
            return self.getToken(NeoBasicParser.ONE, 0)

        def TWO(self):
            return self.getToken(NeoBasicParser.TWO, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_predeclaredFmap

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredeclaredFmap" ):
                listener.enterPredeclaredFmap(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredeclaredFmap" ):
                listener.exitPredeclaredFmap(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredeclaredFmap" ):
                return visitor.visitPredeclaredFmap(self)
            else:
                return visitor.visitChildren(self)




    def predeclaredFmap(self):

        localctx = NeoBasicParser.PredeclaredFmapContext(self, self._ctx, self.state)
        self.enterRule(localctx, 850, self.RULE_predeclaredFmap)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3253
            _la = self._input.LA(1)
            if not(((((_la - 134)) & ~0x3f) == 0 and ((1 << (_la - 134)) & 63) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrimaryExpressionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.PrimaryExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_primaryExpressions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimaryExpressions" ):
                listener.enterPrimaryExpressions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimaryExpressions" ):
                listener.exitPrimaryExpressions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimaryExpressions" ):
                return visitor.visitPrimaryExpressions(self)
            else:
                return visitor.visitChildren(self)




    def primaryExpressions(self):

        localctx = NeoBasicParser.PrimaryExpressionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 852, self.RULE_primaryExpressions)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3255
            self.primaryExpression(0)
            self.state = 3260
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,306,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 3256
                    self.match(NeoBasicParser.COMMA)
                    self.state = 3257
                    self.primaryExpression(0) 
                self.state = 3262
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,306,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrimaryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primaryOperand(self):
            return self.getTypedRuleContext(NeoBasicParser.PrimaryOperandContext,0)


        def sos_Expression(self):
            return self.getTypedRuleContext(NeoBasicParser.Sos_ExpressionContext,0)


        def parenthesizedExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedExpressionContext,0)


        def prefixUnaryOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.PrefixUnaryOperatorContext,0)


        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.PrimaryExpressionContext,i)


        def primaryFunctor(self):
            return self.getTypedRuleContext(NeoBasicParser.PrimaryFunctorContext,0)


        def juxtapositionExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.JuxtapositionExpressionContext,0)


        def DOT(self):
            return self.getToken(NeoBasicParser.DOT, 0)

        def LEFT_BRACKET(self):
            return self.getToken(NeoBasicParser.LEFT_BRACKET, 0)

        def arrayIndexing(self):
            return self.getTypedRuleContext(NeoBasicParser.ArrayIndexingContext,0)


        def RIGHT_BRACKET(self):
            return self.getToken(NeoBasicParser.RIGHT_BRACKET, 0)

        def parenthesizedArguments(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedArgumentsContext,0)


        def SEMICOLON(self):
            return self.getToken(NeoBasicParser.SEMICOLON, 0)

        def formatType(self):
            return self.getTypedRuleContext(NeoBasicParser.FormatTypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_primaryExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimaryExpression" ):
                listener.enterPrimaryExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimaryExpression" ):
                listener.exitPrimaryExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimaryExpression" ):
                return visitor.visitPrimaryExpression(self)
            else:
                return visitor.visitChildren(self)



    def primaryExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = NeoBasicParser.PrimaryExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 854
        self.enterRecursionRule(localctx, 854, self.RULE_primaryExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3274
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,307,self._ctx)
            if la_ == 1:
                self.state = 3264
                self.primaryOperand()
                pass

            elif la_ == 2:
                self.state = 3265
                self.sos_Expression()
                pass

            elif la_ == 3:
                self.state = 3266
                self.parenthesizedExpression()
                pass

            elif la_ == 4:
                self.state = 3267
                self.prefixUnaryOperator()
                self.state = 3268
                self.primaryExpression(4)
                pass

            elif la_ == 5:
                self.state = 3270
                self.primaryFunctor()
                self.state = 3271
                self.primaryExpression(2)
                pass

            elif la_ == 6:
                self.state = 3273
                self.juxtapositionExpression()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 3291
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,309,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 3289
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,308,self._ctx)
                    if la_ == 1:
                        localctx = NeoBasicParser.PrimaryExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 3276
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 3277
                        self.match(NeoBasicParser.DOT)
                        self.state = 3278
                        self.primaryExpression(7)
                        pass

                    elif la_ == 2:
                        localctx = NeoBasicParser.PrimaryExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 3279
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 3280
                        self.match(NeoBasicParser.LEFT_BRACKET)
                        self.state = 3281
                        self.arrayIndexing()
                        self.state = 3282
                        self.match(NeoBasicParser.RIGHT_BRACKET)
                        pass

                    elif la_ == 3:
                        localctx = NeoBasicParser.PrimaryExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 3284
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 3285
                        self.parenthesizedArguments()
                        pass

                    elif la_ == 4:
                        localctx = NeoBasicParser.PrimaryExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 3286
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 3287
                        self.match(NeoBasicParser.SEMICOLON)
                        self.state = 3288
                        self.formatType()
                        pass

             
                self.state = 3293
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,309,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class PrimaryOperandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def predeclaredValue(self):
            return self.getTypedRuleContext(NeoBasicParser.PredeclaredValueContext,0)


        def literal(self):
            return self.getTypedRuleContext(NeoBasicParser.LiteralContext,0)


        def IDENTIFIER(self):
            return self.getToken(NeoBasicParser.IDENTIFIER, 0)

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_primaryOperand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimaryOperand" ):
                listener.enterPrimaryOperand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimaryOperand" ):
                listener.exitPrimaryOperand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimaryOperand" ):
                return visitor.visitPrimaryOperand(self)
            else:
                return visitor.visitChildren(self)




    def primaryOperand(self):

        localctx = NeoBasicParser.PrimaryOperandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 856, self.RULE_primaryOperand)
        try:
            self.state = 3299
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,310,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3294
                self.predeclaredValue()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3295
                self.literal()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3296
                self.match(NeoBasicParser.IDENTIFIER)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 3297
                self.qualifiedIdentifier()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 3298
                self.type_(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrimaryFunctorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def predeclaredFunctor(self):
            return self.getTypedRuleContext(NeoBasicParser.PredeclaredFunctorContext,0)


        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_primaryFunctor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimaryFunctor" ):
                listener.enterPrimaryFunctor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimaryFunctor" ):
                listener.exitPrimaryFunctor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimaryFunctor" ):
                return visitor.visitPrimaryFunctor(self)
            else:
                return visitor.visitChildren(self)




    def primaryFunctor(self):

        localctx = NeoBasicParser.PrimaryFunctorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 858, self.RULE_primaryFunctor)
        try:
            self.state = 3303
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [134, 135, 136, 137, 138, 139, 254, 255, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 298, 299, 301, 302, 304, 305, 307, 308]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3301
                self.predeclaredFunctor()
                pass
            elif token in [415]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3302
                self.qualifiedIdentifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Sos_ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LEFT_PARENTHESIS, 0)

        def statementSentence(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementSentenceContext,0)


        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_sos_Expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSos_Expression" ):
                listener.enterSos_Expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSos_Expression" ):
                listener.exitSos_Expression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSos_Expression" ):
                return visitor.visitSos_Expression(self)
            else:
                return visitor.visitChildren(self)




    def sos_Expression(self):

        localctx = NeoBasicParser.Sos_ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 860, self.RULE_sos_Expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3305
            self.match(NeoBasicParser.LEFT_PARENTHESIS)
            self.state = 3306
            self.statementSentence()
            self.state = 3307
            self.match(NeoBasicParser.RIGHT_PARENTHESIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParenthesizedExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.LEFT_PARENTHESIS, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def RIGHT_PARENTHESIS(self):
            return self.getToken(NeoBasicParser.RIGHT_PARENTHESIS, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_parenthesizedExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenthesizedExpression" ):
                listener.enterParenthesizedExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenthesizedExpression" ):
                listener.exitParenthesizedExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenthesizedExpression" ):
                return visitor.visitParenthesizedExpression(self)
            else:
                return visitor.visitChildren(self)




    def parenthesizedExpression(self):

        localctx = NeoBasicParser.ParenthesizedExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 862, self.RULE_parenthesizedExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3309
            self.match(NeoBasicParser.LEFT_PARENTHESIS)
            self.state = 3310
            self.expression(0)
            self.state = 3311
            self.match(NeoBasicParser.RIGHT_PARENTHESIS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayIndexingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def intervalExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.IntervalExpressionContext,0)


        def sliceExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.SliceExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_arrayIndexing

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayIndexing" ):
                listener.enterArrayIndexing(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayIndexing" ):
                listener.exitArrayIndexing(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArrayIndexing" ):
                return visitor.visitArrayIndexing(self)
            else:
                return visitor.visitChildren(self)




    def arrayIndexing(self):

        localctx = NeoBasicParser.ArrayIndexingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 864, self.RULE_arrayIndexing)
        try:
            self.state = 3316
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,312,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3313
                self.expressions()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3314
                self.intervalExpression(0)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3315
                self.sliceExpression(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntervalExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,i)


        def intervalOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.IntervalOperatorContext,0)


        def leftIntervalOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.LeftIntervalOperatorContext,0)


        def rightIntervalOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.RightIntervalOperatorContext,0)


        def intervalExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.IntervalExpressionContext,0)


        def INTERVAL_INCLUSIVE(self):
            return self.getToken(NeoBasicParser.INTERVAL_INCLUSIVE, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_intervalExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntervalExpression" ):
                listener.enterIntervalExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntervalExpression" ):
                listener.exitIntervalExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntervalExpression" ):
                return visitor.visitIntervalExpression(self)
            else:
                return visitor.visitChildren(self)



    def intervalExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = NeoBasicParser.IntervalExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 866
        self.enterRecursionRule(localctx, 866, self.RULE_intervalExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3329
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,313,self._ctx)
            if la_ == 1:
                self.state = 3319
                self.expression(0)
                self.state = 3320
                self.intervalOperator()
                self.state = 3321
                self.expression(0)
                pass

            elif la_ == 2:
                self.state = 3323
                self.expression(0)
                self.state = 3324
                self.leftIntervalOperator()
                pass

            elif la_ == 3:
                self.state = 3326
                self.rightIntervalOperator()
                self.state = 3327
                self.expression(0)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 3336
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,314,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = NeoBasicParser.IntervalExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_intervalExpression)
                    self.state = 3331
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 3332
                    self.match(NeoBasicParser.INTERVAL_INCLUSIVE)
                    self.state = 3333
                    self.expression(0) 
                self.state = 3338
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,314,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class SliceExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,i)


        def COLON(self):
            return self.getToken(NeoBasicParser.COLON, 0)

        def sliceExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.SliceExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_sliceExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSliceExpression" ):
                listener.enterSliceExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSliceExpression" ):
                listener.exitSliceExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSliceExpression" ):
                return visitor.visitSliceExpression(self)
            else:
                return visitor.visitChildren(self)



    def sliceExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = NeoBasicParser.SliceExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 868
        self.enterRecursionRule(localctx, 868, self.RULE_sliceExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3349
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,315,self._ctx)
            if la_ == 1:
                self.state = 3340
                self.expression(0)
                self.state = 3341
                self.match(NeoBasicParser.COLON)
                self.state = 3342
                self.expression(0)
                pass

            elif la_ == 2:
                self.state = 3344
                self.match(NeoBasicParser.COLON)
                self.state = 3345
                self.expression(0)
                pass

            elif la_ == 3:
                self.state = 3346
                self.expression(0)
                self.state = 3347
                self.match(NeoBasicParser.COLON)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 3356
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,316,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = NeoBasicParser.SliceExpressionContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_sliceExpression)
                    self.state = 3351
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 3352
                    self.match(NeoBasicParser.COLON)
                    self.state = 3353
                    self.expression(0) 
                self.state = 3358
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,316,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class FormatTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def type_(self):
            return self.getTypedRuleContext(NeoBasicParser.TypeContext,0)


        def ATOM_IDENTIFIER(self):
            return self.getToken(NeoBasicParser.ATOM_IDENTIFIER, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.StringLiteralContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_formatType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormatType" ):
                listener.enterFormatType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormatType" ):
                listener.exitFormatType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFormatType" ):
                return visitor.visitFormatType(self)
            else:
                return visitor.visitChildren(self)




    def formatType(self):

        localctx = NeoBasicParser.FormatTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 870, self.RULE_formatType)
        try:
            self.state = 3362
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [21, 23, 24, 25, 26, 27, 39, 40, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 297, 300, 303, 306, 415, 468]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3359
                self.type_(0)
                pass
            elif token in [416]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3360
                self.match(NeoBasicParser.ATOM_IDENTIFIER)
                pass
            elif token in [429, 431, 433]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3361
                self.stringLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JuxtapositionExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sequenceLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.SequenceLiteralContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.SequenceLiteralContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_juxtapositionExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJuxtapositionExpression" ):
                listener.enterJuxtapositionExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJuxtapositionExpression" ):
                listener.exitJuxtapositionExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJuxtapositionExpression" ):
                return visitor.visitJuxtapositionExpression(self)
            else:
                return visitor.visitChildren(self)




    def juxtapositionExpression(self):

        localctx = NeoBasicParser.JuxtapositionExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 872, self.RULE_juxtapositionExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3365 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 3364
                    self.sequenceLiteral()

                else:
                    raise NoViableAltException(self)
                self.state = 3367 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,318,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.COMMA)
            else:
                return self.getToken(NeoBasicParser.COMMA, i)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_expressions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressions" ):
                listener.enterExpressions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressions" ):
                listener.exitExpressions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressions" ):
                return visitor.visitExpressions(self)
            else:
                return visitor.visitChildren(self)




    def expressions(self):

        localctx = NeoBasicParser.ExpressionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 874, self.RULE_expressions)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3369
            self.expression(0)
            self.state = 3374
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,319,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 3370
                    self.match(NeoBasicParser.COMMA)
                    self.state = 3371
                    self.expression(0) 
                self.state = 3376
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,319,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primaryExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.PrimaryExpressionContext,0)


        def guardsExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.GuardsExpressionContext,0)


        def macroExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.MacroExpressionContext,0)


        def shellProcess(self):
            return self.getTypedRuleContext(NeoBasicParser.ShellProcessContext,0)


        def assignmentExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.AssignmentExpressionContext,0)


        def FUNCTOR(self, i:int=None):
            if i is None:
                return self.getTokens(NeoBasicParser.FUNCTOR)
            else:
                return self.getToken(NeoBasicParser.FUNCTOR, i)

        def primaryFunctor(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.PrimaryFunctorContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.PrimaryFunctorContext,i)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,i)


        def expressions(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionsContext,0)


        def parenthesizedArguments(self):
            return self.getTypedRuleContext(NeoBasicParser.ParenthesizedArgumentsContext,0)


        def lambdaLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.LambdaLiteralContext,0)


        def binaryExponentialOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryExponentialOperatorContext,0)


        def binaryMultiplicativeOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryMultiplicativeOperatorContext,0)


        def bitShiftOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BitShiftOperatorContext,0)


        def binaryAdditiveOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryAdditiveOperatorContext,0)


        def binaryArrayOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryArrayOperatorContext,0)


        def binaryComparisonOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryComparisonOperatorContext,0)


        def binaryRelationalOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryRelationalOperatorContext,0)


        def binaryConditionalOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryConditionalOperatorContext,0)


        def binaryConjunctionOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryConjunctionOperatorContext,0)


        def binaryExclusiveDisjunctionOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryExclusiveDisjunctionOperatorContext,0)


        def binaryDisjunctionOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryDisjunctionOperatorContext,0)


        def binaryMonadBindOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryMonadBindOperatorContext,0)


        def binaryPipelineOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.BinaryPipelineOperatorContext,0)


        def IF(self):
            return self.getToken(NeoBasicParser.IF, 0)

        def ELSE(self):
            return self.getToken(NeoBasicParser.ELSE, 0)

        def coalescingOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.CoalescingOperatorContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)



    def expression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = NeoBasicParser.ExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 876
        self.enterRecursionRule(localctx, 876, self.RULE_expression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3407
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,323,self._ctx)
            if la_ == 1:
                self.state = 3378
                self.primaryExpression(0)
                pass

            elif la_ == 2:
                self.state = 3379
                self.guardsExpression()
                pass

            elif la_ == 3:
                self.state = 3380
                self.macroExpression()
                pass

            elif la_ == 4:
                self.state = 3381
                self.shellProcess()
                pass

            elif la_ == 5:
                self.state = 3382
                self.assignmentExpression()
                pass

            elif la_ == 6:
                self.state = 3383
                self.primaryExpression(0)
                self.state = 3386 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 3384
                        self.match(NeoBasicParser.FUNCTOR)
                        self.state = 3385
                        self.primaryFunctor()

                    else:
                        raise NoViableAltException(self)
                    self.state = 3388 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,320,self._ctx)

                self.state = 3391
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,321,self._ctx)
                if la_ == 1:
                    self.state = 3390
                    self.expression(0)


                pass

            elif la_ == 7:
                self.state = 3393
                self.primaryFunctor()
                self.state = 3398
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==375:
                    self.state = 3394
                    self.match(NeoBasicParser.FUNCTOR)
                    self.state = 3395
                    self.primaryFunctor()
                    self.state = 3400
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 3401
                self.expressions()
                pass

            elif la_ == 8:
                self.state = 3403
                self.primaryExpression(0)
                self.state = 3404
                self.parenthesizedArguments()
                self.state = 3405
                self.lambdaLiteral()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 3474
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,326,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 3472
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,325,self._ctx)
                    if la_ == 1:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3409
                        if not self.precpred(self._ctx, 22):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 22)")
                        self.state = 3410
                        self.binaryExponentialOperator()
                        self.state = 3411
                        self.expression(23)
                        pass

                    elif la_ == 2:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3413
                        if not self.precpred(self._ctx, 21):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 21)")
                        self.state = 3414
                        self.binaryMultiplicativeOperator()
                        self.state = 3415
                        self.expression(22)
                        pass

                    elif la_ == 3:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3417
                        if not self.precpred(self._ctx, 20):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 20)")
                        self.state = 3418
                        self.bitShiftOperator()
                        self.state = 3419
                        self.expression(21)
                        pass

                    elif la_ == 4:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3421
                        if not self.precpred(self._ctx, 19):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 19)")
                        self.state = 3422
                        self.binaryAdditiveOperator()
                        self.state = 3423
                        self.expression(20)
                        pass

                    elif la_ == 5:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3425
                        if not self.precpred(self._ctx, 18):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 18)")
                        self.state = 3426
                        self.binaryArrayOperator()
                        self.state = 3427
                        self.expression(19)
                        pass

                    elif la_ == 6:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3429
                        if not self.precpred(self._ctx, 17):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 17)")
                        self.state = 3430
                        self.binaryComparisonOperator()
                        self.state = 3431
                        self.expression(18)
                        pass

                    elif la_ == 7:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3433
                        if not self.precpred(self._ctx, 16):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
                        self.state = 3434
                        self.binaryRelationalOperator()
                        self.state = 3435
                        self.expression(17)
                        pass

                    elif la_ == 8:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3437
                        if not self.precpred(self._ctx, 15):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
                        self.state = 3438
                        self.binaryConditionalOperator()
                        self.state = 3439
                        self.expression(16)
                        pass

                    elif la_ == 9:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3441
                        if not self.precpred(self._ctx, 14):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 14)")
                        self.state = 3442
                        self.binaryConjunctionOperator()
                        self.state = 3443
                        self.expression(15)
                        pass

                    elif la_ == 10:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3445
                        if not self.precpred(self._ctx, 13):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
                        self.state = 3446
                        self.binaryExclusiveDisjunctionOperator()
                        self.state = 3447
                        self.expression(14)
                        pass

                    elif la_ == 11:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3449
                        if not self.precpred(self._ctx, 12):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
                        self.state = 3450
                        self.binaryDisjunctionOperator()
                        self.state = 3451
                        self.expression(13)
                        pass

                    elif la_ == 12:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3453
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 11)")
                        self.state = 3454
                        self.binaryMonadBindOperator()
                        self.state = 3455
                        self.expression(12)
                        pass

                    elif la_ == 13:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3457
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 3458
                        self.binaryPipelineOperator()
                        self.state = 3459
                        self.expression(11)
                        pass

                    elif la_ == 14:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3461
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 3462
                        self.match(NeoBasicParser.IF)
                        self.state = 3463
                        self.expression(0)
                        self.state = 3464
                        self.match(NeoBasicParser.ELSE)
                        self.state = 3465
                        self.expression(9)
                        pass

                    elif la_ == 15:
                        localctx = NeoBasicParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 3467
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 3468
                        self.coalescingOperator()
                        self.state = 3470
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,324,self._ctx)
                        if la_ == 1:
                            self.state = 3469
                            self.expression(0)


                        pass

             
                self.state = 3476
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,326,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class GuardsExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def guardClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.GuardClauseContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.GuardClauseContext,i)


        def guardDefault(self):
            return self.getTypedRuleContext(NeoBasicParser.GuardDefaultContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_guardsExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGuardsExpression" ):
                listener.enterGuardsExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGuardsExpression" ):
                listener.exitGuardsExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGuardsExpression" ):
                return visitor.visitGuardsExpression(self)
            else:
                return visitor.visitChildren(self)




    def guardsExpression(self):

        localctx = NeoBasicParser.GuardsExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 878, self.RULE_guardsExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3478 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 3477
                    self.guardClause()

                else:
                    raise NoViableAltException(self)
                self.state = 3480 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,327,self._ctx)

            self.state = 3483
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,328,self._ctx)
            if la_ == 1:
                self.state = 3482
                self.guardDefault()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GuardClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PIPE(self):
            return self.getToken(NeoBasicParser.PIPE, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,i)


        def IMPLICIT_RETURN(self):
            return self.getToken(NeoBasicParser.IMPLICIT_RETURN, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_guardClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGuardClause" ):
                listener.enterGuardClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGuardClause" ):
                listener.exitGuardClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGuardClause" ):
                return visitor.visitGuardClause(self)
            else:
                return visitor.visitChildren(self)




    def guardClause(self):

        localctx = NeoBasicParser.GuardClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 880, self.RULE_guardClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3485
            self.match(NeoBasicParser.PIPE)
            self.state = 3486
            self.expression(0)
            self.state = 3487
            self.match(NeoBasicParser.IMPLICIT_RETURN)
            self.state = 3488
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GuardDefaultContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PIPE(self):
            return self.getToken(NeoBasicParser.PIPE, 0)

        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_guardDefault

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGuardDefault" ):
                listener.enterGuardDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGuardDefault" ):
                listener.exitGuardDefault(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGuardDefault" ):
                return visitor.visitGuardDefault(self)
            else:
                return visitor.visitChildren(self)




    def guardDefault(self):

        localctx = NeoBasicParser.GuardDefaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 882, self.RULE_guardDefault)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3490
            self.match(NeoBasicParser.PIPE)
            self.state = 3491
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MacroExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def macroCall(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.MacroCallContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.MacroCallContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_macroExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMacroExpression" ):
                listener.enterMacroExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMacroExpression" ):
                listener.exitMacroExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMacroExpression" ):
                return visitor.visitMacroExpression(self)
            else:
                return visitor.visitChildren(self)




    def macroExpression(self):

        localctx = NeoBasicParser.MacroExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 884, self.RULE_macroExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3494 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 3493
                    self.macroCall()

                else:
                    raise NoViableAltException(self)
                self.state = 3496 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,329,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MacroCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedIdentifier(self):
            return self.getTypedRuleContext(NeoBasicParser.QualifiedIdentifierContext,0)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeoBasicParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,i)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_macroCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMacroCall" ):
                listener.enterMacroCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMacroCall" ):
                listener.exitMacroCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMacroCall" ):
                return visitor.visitMacroCall(self)
            else:
                return visitor.visitChildren(self)




    def macroCall(self):

        localctx = NeoBasicParser.MacroCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 886, self.RULE_macroCall)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3498
            self.qualifiedIdentifier()
            self.state = 3502
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,330,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 3499
                    self.expression(0) 
                self.state = 3504
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,330,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ShellProcessContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shellPathLiteral(self):
            return self.getTypedRuleContext(NeoBasicParser.ShellPathLiteralContext,0)


        def LEFT_CURLY(self):
            return self.getToken(NeoBasicParser.LEFT_CURLY, 0)

        def statementBlock(self):
            return self.getTypedRuleContext(NeoBasicParser.StatementBlockContext,0)


        def RIGHT_CURLY(self):
            return self.getToken(NeoBasicParser.RIGHT_CURLY, 0)

        def getRuleIndex(self):
            return NeoBasicParser.RULE_shellProcess

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShellProcess" ):
                listener.enterShellProcess(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShellProcess" ):
                listener.exitShellProcess(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShellProcess" ):
                return visitor.visitShellProcess(self)
            else:
                return visitor.visitChildren(self)




    def shellProcess(self):

        localctx = NeoBasicParser.ShellProcessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 888, self.RULE_shellProcess)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3505
            self.shellPathLiteral()
            self.state = 3506
            self.match(NeoBasicParser.LEFT_CURLY)
            self.state = 3507
            self.statementBlock()
            self.state = 3508
            self.match(NeoBasicParser.RIGHT_CURLY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def primaryExpression(self):
            return self.getTypedRuleContext(NeoBasicParser.PrimaryExpressionContext,0)


        def assignmentOperator(self):
            return self.getTypedRuleContext(NeoBasicParser.AssignmentOperatorContext,0)


        def expression(self):
            return self.getTypedRuleContext(NeoBasicParser.ExpressionContext,0)


        def getRuleIndex(self):
            return NeoBasicParser.RULE_assignmentExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentExpression" ):
                listener.enterAssignmentExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentExpression" ):
                listener.exitAssignmentExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignmentExpression" ):
                return visitor.visitAssignmentExpression(self)
            else:
                return visitor.visitChildren(self)




    def assignmentExpression(self):

        localctx = NeoBasicParser.AssignmentExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 890, self.RULE_assignmentExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3510
            self.primaryExpression(0)
            self.state = 3511
            self.assignmentOperator()
            self.state = 3512
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[196] = self.simpleStatement_sempred
        self._predicates[328] = self.type_sempred
        self._predicates[427] = self.primaryExpression_sempred
        self._predicates[433] = self.intervalExpression_sempred
        self._predicates[434] = self.sliceExpression_sempred
        self._predicates[438] = self.expression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def simpleStatement_sempred(self, localctx:SimpleStatementContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 10)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 9)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 7)
         

    def type_sempred(self, localctx:TypeContext, predIndex:int):
            if predIndex == 4:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 8:
                return self.precpred(self._ctx, 7)
         

    def primaryExpression_sempred(self, localctx:PrimaryExpressionContext, predIndex:int):
            if predIndex == 9:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 10:
                return self.precpred(self._ctx, 7)
         

            if predIndex == 11:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 12:
                return self.precpred(self._ctx, 3)
         

    def intervalExpression_sempred(self, localctx:IntervalExpressionContext, predIndex:int):
            if predIndex == 13:
                return self.precpred(self._ctx, 1)
         

    def sliceExpression_sempred(self, localctx:SliceExpressionContext, predIndex:int):
            if predIndex == 14:
                return self.precpred(self._ctx, 1)
         

    def expression_sempred(self, localctx:ExpressionContext, predIndex:int):
            if predIndex == 15:
                return self.precpred(self._ctx, 22)
         

            if predIndex == 16:
                return self.precpred(self._ctx, 21)
         

            if predIndex == 17:
                return self.precpred(self._ctx, 20)
         

            if predIndex == 18:
                return self.precpred(self._ctx, 19)
         

            if predIndex == 19:
                return self.precpred(self._ctx, 18)
         

            if predIndex == 20:
                return self.precpred(self._ctx, 17)
         

            if predIndex == 21:
                return self.precpred(self._ctx, 16)
         

            if predIndex == 22:
                return self.precpred(self._ctx, 15)
         

            if predIndex == 23:
                return self.precpred(self._ctx, 14)
         

            if predIndex == 24:
                return self.precpred(self._ctx, 13)
         

            if predIndex == 25:
                return self.precpred(self._ctx, 12)
         

            if predIndex == 26:
                return self.precpred(self._ctx, 11)
         

            if predIndex == 27:
                return self.precpred(self._ctx, 10)
         

            if predIndex == 28:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 29:
                return self.precpred(self._ctx, 9)
         




